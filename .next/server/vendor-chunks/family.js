"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/family";
exports.ids = ["vendor-chunks/family"];
exports.modules = {

/***/ "(ssr)/./node_modules/family/lib/family-accounts-connector-DNek4H7L.js":
/*!***********************************************************************!*\
  !*** ./node_modules/family/lib/family-accounts-connector-DNek4H7L.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ CommunicationTypes),\n/* harmony export */   E: () => (/* binding */ EthereumProviderConnectionTimeoutError),\n/* harmony export */   F: () => (/* binding */ FamilyAccountsSdk),\n/* harmony export */   S: () => (/* binding */ SessionStatus),\n/* harmony export */   a: () => (/* binding */ SdkStatus),\n/* harmony export */   b: () => (/* binding */ SessionCreateResult),\n/* harmony export */   c: () => (/* binding */ createFamilyAccountsClient),\n/* harmony export */   d: () => (/* binding */ EthereumProvider),\n/* harmony export */   e: () => (/* binding */ familyAccountsConnector),\n/* harmony export */   f: () => (/* binding */ familyAccountsCustomActions),\n/* harmony export */   i: () => (/* binding */ invariant),\n/* harmony export */   p: () => (/* binding */ production)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/address/getAddress.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/clients/transports/custom.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/clients/decorators/public.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/errors/rpc.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/promise/withTimeout.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/promise/withRetry.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n\n\n\nconst isString = (input) => {\n  return typeof input === \"string\";\n};\n\nclass CausedError extends Error {\n  cause;\n  constructor(message, options) {\n    super(message, options);\n    if (options?.cause) {\n      this.cause = options.cause;\n      this.message = `${this.message}\nCAUSE: ${this.cause.message}`;\n      if (typeof this.cause.stack === \"string\") {\n        this.stack = (this.stack ?? \"\") + \"\\nCAUSE: \" + this.cause.stack;\n      }\n    }\n  }\n}\n\nclass Deferred {\n  promise;\n  resolve;\n  reject;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst minutesToMs = (minutes) => minutes * 6e4;\nconst secondsToMs = (seconds) => seconds * 1e3;\nconst msToSeconds = (ms) => ms / 1e3;\n\nclass InvariantError extends CausedError {\n  constructor(message, options) {\n    super(`InvariantError: ${message}`, options);\n  }\n}\nfunction invariant(condition, message, cause) {\n  if (!condition) {\n    throw new InvariantError(message, { cause });\n  }\n}\n\nfunction assertError(error) {\n  if (!(error instanceof Error)) {\n    throw new InvariantError(\n      `Invalid error type. Received ${typeof error}, expected instance of Error`\n    );\n  }\n}\n\nfunction never(message, options) {\n  throw new InvariantError(message, options);\n}\n\nvar SessionStatus;\n(function (SessionStatus) {\n    SessionStatus[\"AUTHENTICATED\"] = \"AUTHENTICATED\";\n    SessionStatus[\"NOT_AUTHENTICATED\"] = \"NOT_AUTHENTICATED\";\n})(SessionStatus || (SessionStatus = {}));\n\nvar CommunicationTypes;\n(function (CommunicationTypes) {\n    /**\n     * Session\n     */\n    CommunicationTypes[\"sessionInit\"] = \"sessionInit\";\n    CommunicationTypes[\"sessionGetCurrent\"] = \"sessionGetCurrent\";\n    CommunicationTypes[\"sessionClear\"] = \"sessionClear\";\n    /**\n     * Ethereum\n     */\n    CommunicationTypes[\"ethereumJsonRpcRequest\"] = \"ethereumJsonRpcRequest\";\n    CommunicationTypes[\"ethereumJsonRpcRequiresApproval\"] = \"ethereumJsonRpcRequiresApproval\";\n})(CommunicationTypes || (CommunicationTypes = {}));\n\nvar SubscriptionTypes;\n(function (SubscriptionTypes) {\n    /**\n     * Session related\n     */\n    SubscriptionTypes[\"sessionChanged\"] = \"sessionChanged\";\n    /**\n     * Network related\n     */\n    SubscriptionTypes[\"ethereumNetworkChanged\"] = \"ethereumNetworkChanged\";\n    /**\n     * Modal related\n     */\n    SubscriptionTypes[\"modalOpen\"] = \"modalOpen\";\n    SubscriptionTypes[\"modalClose\"] = \"modalClose\";\n    SubscriptionTypes[\"modalUpdate\"] = \"modalUpdate\";\n})(SubscriptionTypes || (SubscriptionTypes = {}));\n\nvar PopupCommunicationTypes;\n(function (PopupCommunicationTypes) {\n    PopupCommunicationTypes[\"authStart\"] = \"authStart\";\n    PopupCommunicationTypes[\"rpcRequest\"] = \"rpcRequest\";\n})(PopupCommunicationTypes || (PopupCommunicationTypes = {}));\n\nclass State {\n    static setExecutorWindow = (_window) => {\n        window.____fa_wrapper = {\n            window: _window,\n            origin: window.____fa_wrapper?.origin,\n        };\n    };\n    static getExecutorWindow = () => {\n        if (!window.____fa_wrapper?.window) {\n            throw new Error('You must call `connect` to start up the sdk-web-elements');\n        }\n        return window.____fa_wrapper.window;\n    };\n    static setExecutorOrigin = (origin) => {\n        const instance = window.____fa_wrapper;\n        if (instance) {\n            instance.origin = origin;\n            return;\n        }\n        window.____fa_wrapper = {\n            origin,\n            window: window.____fa_wrapper?.window,\n        };\n    };\n    static getExecutorOrigin = () => {\n        if (!window.____fa_wrapper?.origin) {\n            throw new Error('You must call `connect` to start up the sdk-web-elements');\n        }\n        return window.____fa_wrapper.origin;\n    };\n}\n\nlet postRobot = null;\n/**\n * We do not import `post-robot` right away as it would cause SSR issues given `post-robot` requires access to `window` right away\n */\nconst initPostRobot = async () => {\n    postRobot = await __webpack_require__.e(/*! import() */ \"vendor-chunks/family\").then(__webpack_require__.bind(__webpack_require__, /*! ./index-DD_kndDs.js */ \"(ssr)/./node_modules/family/lib/index-DD_kndDs.js\")).then(function (n) { return n.i; });\n};\nconst getPostRobot = () => {\n    invariant(postRobot, 'You need to init post robot first');\n    return postRobot;\n};\n\nconst DEFAULT_PROXY_TIMEOUT$1 = minutesToMs(1);\nconst proxy = async (request, config) => {\n    if (typeof window === 'undefined') {\n        throw new Error(\"Can't proxy in a non browser environment\");\n    }\n    const data = 'data' in request ? request.data : undefined;\n    const event = await getPostRobot().send(State.getExecutorWindow(), request.type, data, {\n        timeout: config?.timeout ?? DEFAULT_PROXY_TIMEOUT$1,\n    });\n    return event.data;\n};\nconst listeners = new Map();\n/**\n * Subscribe to a specific event\n * Supports multiple subscriptions to the same event\n * see https://github.com/krakenjs/post-robot/issues/48\n */\nconst subscribe = (type, callback) => {\n    if (typeof window === 'undefined') {\n        throw new Error(\"Can't subscribe in a non browser environment\");\n    }\n    if (listeners.has(type)) {\n        listeners.get(type)?.callbacks.push(callback);\n    }\n    else {\n        const listener = getPostRobot().on(type, { window: State.getExecutorWindow() }, (event) => {\n            listeners.get(type)?.callbacks.forEach((c) => c(event.data));\n            return Promise.resolve();\n        });\n        listeners.set(type, { listener, callbacks: [callback] });\n    }\n    return () => {\n        const listenerInfo = listeners.get(type);\n        if (!listenerInfo) {\n            return;\n        }\n        const newCallbacks = listenerInfo.callbacks.filter((c) => c !== callback);\n        if (newCallbacks.length === 0) {\n            listenerInfo.listener.cancel();\n            listeners.delete(type);\n        }\n        else {\n            listenerInfo.callbacks = newCallbacks;\n        }\n    };\n};\n\nconst getMasterIframeUrl = () => {\n    return State.getExecutorOrigin() + '/injected/master';\n};\n\nclass IntegratedClientModalController {\n    unsubscribe;\n    autoHeight = false;\n    constructor(container, iframe) {\n        const modalOpenUnsubscribe = subscribe(SubscriptionTypes.modalOpen, ({ height }) => {\n            document.body.style.setProperty('overflow', 'hidden', 'important');\n            // avoid scrollbar jumping when hidden is applied\n            document.body.style.setProperty('padding-right', '15px', 'important');\n            container.style.setProperty('display', 'flex');\n            if (this.autoHeight)\n                iframe.style.setProperty('height', height.toString() + 'px');\n        });\n        const modalCloseUnsubscribe = subscribe(SubscriptionTypes.modalClose, () => {\n            document.body.style.removeProperty('overflow');\n            document.body.style.removeProperty('padding-right');\n            container.style.setProperty('display', 'none');\n        });\n        const modalUpdateUnsubscribe = subscribe(SubscriptionTypes.modalUpdate, ({ height }) => {\n            if (this.autoHeight)\n                iframe.style.setProperty('height', height.toString() + 'px');\n        });\n        this.unsubscribe = () => {\n            modalOpenUnsubscribe();\n            modalCloseUnsubscribe();\n            modalUpdateUnsubscribe();\n        };\n    }\n    disconnect() {\n        this.unsubscribe();\n    }\n}\n\nconst IFRAME_ID = 'family-accounts-master-iframe';\nconst CONNECTION_TIMEOUT$1 = 20000;\nlet modalController = null;\nconst createElements = ({ fullscreen } = {}) => {\n    if (fullscreen) {\n        const container = document.createElement('div');\n        container.style.display = 'none';\n        container.style.position = 'fixed';\n        container.style.inset = '0';\n        container.style.zIndex = '2147483647';\n        const iframe = document.createElement('iframe');\n        iframe.style.position = 'absolute';\n        iframe.style.top = '0';\n        iframe.style.left = '0';\n        iframe.style.width = '100vw';\n        iframe.style.height = '100vh';\n        iframe.id = IFRAME_ID;\n        iframe.src = getMasterIframeUrl();\n        container.appendChild(iframe);\n        return { container, iframe };\n    }\n    else {\n        const container = document.createElement('div');\n        container.style.display = 'none';\n        container.style.alignItems = 'center';\n        container.style.justifyContent = 'center';\n        container.style.position = 'fixed';\n        container.style.top = '0';\n        container.style.left = '0';\n        container.style.width = '100vw';\n        container.style.height = '100vh';\n        container.style.zIndex = '2147483647';\n        const backdrop = document.createElement('div');\n        backdrop.style.position = 'absolute';\n        backdrop.style.inset = '0';\n        backdrop.style.backgroundColor = 'rgba(0,0,0,0.5)';\n        backdrop.style.zIndex = '-1';\n        const iframe = document.createElement('iframe');\n        iframe.style.borderRadius = '10px';\n        iframe.style.boxShadow = '0 0 10px 0 rgba(0,0,0,0.5)';\n        iframe.id = IFRAME_ID;\n        iframe.src = getMasterIframeUrl();\n        container.appendChild(backdrop);\n        container.appendChild(iframe);\n        return { container, iframe };\n    }\n};\n/**\n * Injects the sdk-web-executor so the sdk-web-elements can call the web-elements\n */\nconst connect = ({ environment }) => {\n    const connected = isConnected();\n    // do nothing if already connected\n    if (connected) {\n        return null;\n    }\n    return new Promise((resolve, reject) => {\n        let fulfilled = false;\n        // if it takes longer then CONNECTION_TIMEOUT seconds error!\n        const timeout = setTimeout(() => {\n            fulfilled = true;\n            reject(`The sdk-web-elements failed to connect within ${msToSeconds(CONNECTION_TIMEOUT$1)} seconds, please contact support.`);\n        }, CONNECTION_TIMEOUT$1);\n        const origin = environment.webElementsAppUrl;\n        State.setExecutorOrigin(origin);\n        const { container, iframe } = createElements({\n            fullscreen: true,\n        });\n        iframe.onload = () => {\n            if (fulfilled) {\n                return;\n            }\n            fulfilled = true;\n            clearTimeout(timeout);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            State.setExecutorWindow(iframe.contentWindow);\n            modalController = new IntegratedClientModalController(container, iframe);\n            resolve();\n        };\n        // we need to init post-robot before appending iframe\n        // to make sure listeners are properly setup\n        void initPostRobot().then(() => {\n            document.body.appendChild(container);\n        });\n    });\n};\nconst isConnected = () => {\n    const connector = document.getElementById(IFRAME_ID);\n    return !!connector && !!modalController;\n};\n/**\n * Removes the injected sdk-web-executor\n */\nconst disconnect = () => {\n    const connected = isConnected();\n    // do nothing if not connected\n    if (!connected) {\n        return;\n    }\n    const connector = document.getElementById(IFRAME_ID);\n    invariant(connector, 'The connector is not defined');\n    invariant(modalController, 'The modal controller is not defined');\n    modalController.disconnect();\n    connector.remove();\n};\n\nconst DEVICE_LOCAL_STORAGE_KEY = 'family_accounts__device_id';\nconst getDeviceId = () => localStorage.getItem(DEVICE_LOCAL_STORAGE_KEY);\nconst setDeviceId = (deviceId) => localStorage.setItem(DEVICE_LOCAL_STORAGE_KEY, deviceId);\nconst SESSION_KEY_LOCAL_STORAGE_KEY = 'family_accounts__session_key';\nconst getSessionKey = () => {\n    return localStorage.getItem(SESSION_KEY_LOCAL_STORAGE_KEY);\n};\nconst setSessionKey = (sessionKey) => {\n    return localStorage.setItem(SESSION_KEY_LOCAL_STORAGE_KEY, sessionKey);\n};\nconst removeSessionKey = () => {\n    return localStorage.removeItem(SESSION_KEY_LOCAL_STORAGE_KEY);\n};\n\nconst production = {\n    name: 'production',\n    webElementsAppUrl: 'https://app.family.co',\n};\n\nconst DEFAULT_PROXY_TIMEOUT = minutesToMs(1);\nconst calculatePopupPosition = (width, height) => {\n    const left = window.screenX + (window.outerWidth - width) / 2;\n    const top = window.screenY + (window.outerHeight - height) / 2;\n    return {\n        left,\n        top,\n    };\n};\nconst getPopupSize = (size) => {\n    switch (size) {\n        case PopupSize.MEDIUM:\n            return {\n                width: 444,\n                height: 586,\n            };\n        case PopupSize.INHERITED:\n            return {\n                width: window.outerWidth,\n                height: window.outerHeight,\n            };\n    }\n};\nvar PopupSize;\n(function (PopupSize) {\n    PopupSize[\"MEDIUM\"] = \"MEDIUM\";\n    PopupSize[\"INHERITED\"] = \"INHERITED\";\n})(PopupSize || (PopupSize = {}));\nconst openPopup = (url, name, size = PopupSize.MEDIUM) => {\n    const { width, height } = getPopupSize(size);\n    const { top, left } = calculatePopupPosition(width, height);\n    const options = `width=${width},height=${height},left=${left},top=${top},menubar=no,toolbar=no,location=no,status=no`;\n    return window.open(url, name, options);\n};\nconst proxyPopup = async (popup, request, config) => {\n    const data = 'data' in request ? request.data : undefined;\n    const event = await getPostRobot().send(popup, request.type, data, {\n        timeout: config?.timeout ?? DEFAULT_PROXY_TIMEOUT,\n    });\n    return event.data;\n};\n\nlet connectionChangeListeners = [];\nvar SdkStatus;\n(function (SdkStatus) {\n    SdkStatus[SdkStatus[\"DISCONNECTED\"] = 0] = \"DISCONNECTED\";\n    SdkStatus[SdkStatus[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    SdkStatus[SdkStatus[\"CONNECTED\"] = 2] = \"CONNECTED\";\n})(SdkStatus || (SdkStatus = {}));\nlet sdkStatus = SdkStatus.DISCONNECTED;\nconst requireConnectedSdk = () => {\n    if (sdkStatus !== SdkStatus.CONNECTED) {\n        throw new Error('Family Accounts is not connected. Make sure to call FamilyAccountsSdk.connect() first.');\n    }\n};\nvar SessionCreateResult;\n(function (SessionCreateResult) {\n    /**\n     * User successfully authenticated\n     */\n    SessionCreateResult[\"SUCCESS\"] = \"SUCCESS\";\n    /**\n     * User cancelled popup by closing it or by timeout\n     */\n    SessionCreateResult[\"USER_CANCELLED\"] = \"USER_CANCELLED\";\n    /**\n     * Popup was blocked by the browser\n     */\n    SessionCreateResult[\"BROWSER_BLOCKED\"] = \"BROWSER_BLOCKED\";\n})(SessionCreateResult || (SessionCreateResult = {}));\nconst FamilyAccountsSdk = {\n    async connect(config = { environment: production }) {\n        if (sdkStatus === SdkStatus.CONNECTED) {\n            throw new Error('Family Accounts is already connected. Do not call FamilyAccountsSdk.connect() more than once.');\n        }\n        if (sdkStatus === SdkStatus.CONNECTING) {\n            throw new Error('Family Accounts is already connecting. Do not call FamilyAccountsSdk.connect() more than once.');\n        }\n        sdkStatus = SdkStatus.CONNECTING;\n        await connect(config);\n        await this.session.init();\n        sdkStatus = SdkStatus.CONNECTED;\n        connectionChangeListeners.forEach((listener) => listener(true));\n    },\n    isConnected: () => sdkStatus === SdkStatus.CONNECTED,\n    isConnecting: () => sdkStatus === SdkStatus.CONNECTING,\n    async disconnect() {\n        if (sdkStatus !== SdkStatus.CONNECTED) {\n            throw new Error('Family accounts is not connected');\n        }\n        const currentSession = await this.session.getCurrent();\n        if (currentSession.status === SessionStatus.AUTHENTICATED) {\n            await this.session.clear();\n        }\n        disconnect();\n        sdkStatus = SdkStatus.DISCONNECTED;\n        connectionChangeListeners.forEach((listener) => listener(false));\n        return Promise.resolve();\n    },\n    onConnectionChange: (callback) => {\n        connectionChangeListeners.push(callback);\n        return () => {\n            connectionChangeListeners = connectionChangeListeners.filter((listener) => listener !== callback);\n        };\n    },\n    session: {\n        create: async () => {\n            requireConnectedSdk();\n            const popup = openPopup(`${State.getExecutorOrigin()}/popup/auth`, 'FamilyAccountsAuthentication');\n            if (!popup) {\n                return {\n                    status: SessionCreateResult.BROWSER_BLOCKED,\n                };\n            }\n            try {\n                const response = await proxyPopup(popup, {\n                    type: PopupCommunicationTypes.authStart,\n                }, {\n                    // note: popup has own timeout, this is purely to keep the event alive\n                    timeout: minutesToMs(10),\n                });\n                setSessionKey(response.clientSessionKey);\n                setDeviceId(response.deviceId);\n                return {\n                    status: SessionCreateResult.SUCCESS,\n                    deviceId: response.deviceId,\n                    clientSessionKey: response.clientSessionKey,\n                    idToken: response.idToken,\n                    wallet: {\n                        address: response.wallet.address,\n                    },\n                };\n            }\n            catch {\n                // quite likely a timeout, window was closed or user rejected connection\n                return {\n                    status: SessionCreateResult.USER_CANCELLED,\n                };\n            }\n        },\n        // TODO: Remove `init` from the public API\n        init: () => {\n            const deviceId = getDeviceId();\n            const clientSessionKey = getSessionKey();\n            return proxy({\n                type: CommunicationTypes.sessionInit,\n                data: {\n                    deviceId,\n                    clientSessionKey,\n                },\n            });\n        },\n        getCurrent: () => {\n            requireConnectedSdk();\n            return proxy({\n                type: CommunicationTypes.sessionGetCurrent,\n            });\n        },\n        onChange: (callback) => {\n            requireConnectedSdk();\n            return subscribe(SubscriptionTypes.sessionChanged, callback);\n        },\n        clear: () => {\n            requireConnectedSdk();\n            removeSessionKey();\n            return proxy({\n                type: CommunicationTypes.sessionClear,\n            });\n        },\n    },\n    ethereum: {\n        onNetworkChange: (callback) => {\n            requireConnectedSdk();\n            return subscribe(SubscriptionTypes.ethereumNetworkChanged, callback);\n        },\n    },\n};\n\nconst isIntersectionObserverV2Supported = () => 'IntersectionObserverEntry' in window && 'isVisible' in IntersectionObserverEntry.prototype;\n\n// A list of methods that potentially require user approval\n// If it's a well known method we can handle without user approval\n// But to meet Safari requirements we need to get the first decision point in a non-blocking way\n// Make sure it's in sync with `APPROVAL_REQUIRED_METHODS` from `JsonRpcService`\nconst POTENTIALLY_APPROVAL_REQUIRED_METHODS = [\n    'personal_sign',\n    'eth_sendTransaction',\n    'eth_signTypedData_v4',\n    'wallet_addEthereumChain',\n    'family_switchAccounts',\n];\nclass RpcError extends Error {\n    code;\n    message;\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        this.message = message;\n    }\n    static userRejectedRequest(message) {\n        return new RpcError(4001, message);\n    }\n    static unauthorized(message) {\n        return new RpcError(4100, message);\n    }\n}\nclass LocalRpcHandler {\n    args;\n    constructor(args) {\n        this.args = args;\n    }\n    async handle() {\n        switch (this.args.method) {\n            case 'eth_requestAccounts':\n                return this.handleRequestAccounts();\n            default: {\n                never('Unsupported method');\n            }\n        }\n    }\n    async handleRequestAccounts() {\n        try {\n            const session = await FamilyAccountsSdk.session.getCurrent();\n            if (session.status === SessionStatus.AUTHENTICATED) {\n                return [session.wallet.address];\n            }\n            const createdSession = await FamilyAccountsSdk.session.create();\n            switch (createdSession.status) {\n                case SessionCreateResult.SUCCESS:\n                    return [createdSession.wallet.address];\n                case SessionCreateResult.BROWSER_BLOCKED:\n                    throw RpcError.userRejectedRequest('Browser blocked Family Accounts authentication popup');\n                case SessionCreateResult.USER_CANCELLED:\n                    throw RpcError.userRejectedRequest('User cancelled authentication request');\n            }\n        }\n        catch (error) {\n            // if the error already looks like a rpc error then throw it\n            if (error instanceof Error && 'code' in error) {\n                throw error;\n            }\n            // most likely can't happen\n            throw RpcError.userRejectedRequest('Unknown reason');\n        }\n    }\n}\nclass MasterIframeRpcHandler {\n    args;\n    // The default post message timeout is 10 seconds\n    DEFAULT_RPC_CALL_TIMEOUT = secondsToMs(10);\n    DEFAULT_RPC_SIGN_TIMEOUT = minutesToMs(10);\n    constructor(args) {\n        this.args = args;\n    }\n    async handle() {\n        const timeout = POTENTIALLY_APPROVAL_REQUIRED_METHODS.includes(this.args.method)\n            ? // if its sending a transaction make the timeout very\n                // long as they may get a approval modal displayed\n                // and if so have a `forever` time to approval it\n                this.DEFAULT_RPC_SIGN_TIMEOUT\n            : this.DEFAULT_RPC_CALL_TIMEOUT;\n        try {\n            const result = await proxy({\n                type: CommunicationTypes.ethereumJsonRpcRequest,\n                data: this.args,\n            }, {\n                timeout,\n            });\n            invariant(result !== undefined, 'The JSON RPC result should not be undefined');\n            return result;\n        }\n        catch (error) {\n            // if the error already looks like a rpc error then throw it\n            if (error instanceof Error && 'code' in error) {\n                throw error;\n            }\n            // most likely can't happen\n            throw RpcError.userRejectedRequest('Unknown reason');\n        }\n    }\n}\n/**\n * A handler for rpc request in case intersection observer is not supported\n * Note: It's build in a way to work with safari popup blocker in mind where popups are blocked if they are happen in a Promise\n */\nclass PopupModalRpcHandler {\n    args;\n    // if it takes longer to detect if approval is required (e.g. simulation time intensive)\n    // we would then treat it as approval required to not block the UI\n    APPROVAL_REQUIRED_TIMEOUT = 300;\n    constructor(args) {\n        this.args = args;\n    }\n    handle() {\n        let requestRequiresApproval = null;\n        // note: can't use async/await here as will block popup modal on Safari\n        void requiresUserApproval(this.args).then((result) => {\n            requestRequiresApproval = result;\n        });\n        const deferred = new Deferred();\n        // note: set timeout is allowed by Safari to open popups\n        setTimeout(async () => {\n            // user approval is not required so we can handle it in the master iframe\n            if (requestRequiresApproval === false) {\n                new MasterIframeRpcHandler(this.args).handle().then(deferred.resolve, deferred.reject);\n                return;\n            }\n            const popup = openPopup(`${State.getExecutorOrigin()}/popup/rpc`, 'FamilyAccountsRpc', PopupSize.INHERITED);\n            if (!popup) {\n                deferred.reject(RpcError.userRejectedRequest('Popup blocked'));\n                return;\n            }\n            const clientSessionKey = getSessionKey();\n            const deviceId = getDeviceId();\n            if (!clientSessionKey || !deviceId) {\n                deferred.reject(RpcError.unauthorized('User not authorized'));\n                return;\n            }\n            try {\n                const result = await proxyPopup(popup, {\n                    type: PopupCommunicationTypes.rpcRequest,\n                    data: {\n                        request: this.args,\n                        clientSessionKey,\n                        deviceId,\n                    },\n                }, {\n                    // note: popup has own timeout, this is purely to keep the event alive\n                    timeout: minutesToMs(10),\n                });\n                deferred.resolve(result);\n            }\n            catch (error) {\n                assertError(error);\n                // if the error already looks like a rpc error then throw it\n                if (error instanceof Error && 'code' in error) {\n                    deferred.reject(error);\n                    return;\n                }\n                // quite likely a timeout, window was closed or user rejected connection\n                deferred.reject(RpcError.userRejectedRequest('Popup was closed by the user'));\n            }\n        }, this.APPROVAL_REQUIRED_TIMEOUT);\n        return deferred.promise;\n    }\n}\nconst requiresUserApproval = async (args) => {\n    try {\n        return await proxy({\n            type: CommunicationTypes.ethereumJsonRpcRequiresApproval,\n            data: args,\n        });\n    }\n    catch (error) {\n        // if the error already looks like a rpc error then throw it\n        if (error instanceof Error && 'code' in error) {\n            throw error;\n        }\n        // most likely can't happen\n        throw RpcError.userRejectedRequest('Unknown reason');\n    }\n};\nfunction getRpcRequestHandler(args) {\n    if (args.method === 'eth_requestAccounts') {\n        return new LocalRpcHandler(args);\n    }\n    if (isIntersectionObserverV2Supported()) {\n        // note: master iframe will reject requests if intersection observer is not supported\n        return new MasterIframeRpcHandler(args);\n    }\n    if (!POTENTIALLY_APPROVAL_REQUIRED_METHODS.includes(args.method)) {\n        return new MasterIframeRpcHandler(args);\n    }\n    return new PopupModalRpcHandler(args);\n}\n\nconst CONNECTION_TIMEOUT = secondsToMs(5);\nclass EthereumProviderConnectionTimeoutError extends Error {\n    constructor() {\n        super('EIP1193 provider connection timeout. Make sure to call `FamilyAccountsSdk.connect()` before using the provider.');\n    }\n}\n/**\n * This follows the EIP - https://eips.ethereum.org/EIPS/eip-1193\n */\nclass EthereumProvider {\n    _eventEmitter = new events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n    _accountsChangedUnsubscriptionCallback = null;\n    _networkChangedUnsubscriptionCallback = null;\n    _connectUnsubscriptionCallback = null;\n    _disconnectUnsubscriptionCallback = null;\n    _config;\n    constructor(options) {\n        this._config = options;\n    }\n    log(...args) {\n        if (this._config?.debug) {\n            // eslint-disable-next-line no-console\n            console.log(...args);\n        }\n    }\n    /**\n     * @returns true if the provider is connected and ready to process requests\n     */\n    isConnected() {\n        return FamilyAccountsSdk.isConnected();\n    }\n    /**\n     * JSONRPC request\n     * @param args The request arguments\n     */\n    // return type is loose as we don't want to type all the possible return types given it's a proxy\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request(args) {\n        await this.waitForConnection();\n        const requestHandler = getRpcRequestHandler({\n            method: args.method,\n            // normalize params to be an array\n            params: Array.isArray(args.params) ? args.params : [args.params],\n        });\n        return requestHandler.handle();\n    }\n    /**\n     * JSONRPC request\n     * @param method The request jsonrpc method\n     * @param params The request parameters\n     * @deprecated Please use `request` instead.\n     */\n    async send(method, params) {\n        return this.request({ method, params });\n    }\n    on(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener) {\n        // we don't support `message` event\n        if (eventName === 'message') {\n            return this;\n        }\n        this.log('on', eventName);\n        if (this._eventEmitter.listenerCount(eventName) === 0) {\n            switch (eventName) {\n                case 'accountsChanged':\n                    void this.subscribeToAccountChangeEvent().catch((...args) => this.log('accountsChanged', args));\n                    break;\n                case 'chainChanged':\n                    void this.subscribeToNetworkChangeEvent();\n                    break;\n                case 'connect':\n                    void this.subscribeToConnectEvent().catch((...args) => this.log('connect', args));\n                    break;\n                case 'disconnect':\n                    void this.subscribeToDisconnectEvent().catch((...args) => this.log('disconnect', args));\n                    break;\n            }\n        }\n        this._eventEmitter.on(eventName, listener);\n        return this;\n    }\n    /**\n     * Remove the provider event emitters\n     * @param eventName The event name\n     * @param listener The listener to callback\n     */\n    removeListener(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener) {\n        // we don't support `message` event\n        if (eventName === 'message') {\n            return this;\n        }\n        this._eventEmitter.removeListener(eventName, listener);\n        if (this._eventEmitter.listenerCount(eventName) === 0) {\n            switch (eventName) {\n                case 'accountsChanged':\n                    void this.unsubscribeFromAccountChangeEvent().catch((...args) => this.log('accountsChanged', args));\n                    break;\n                case 'chainChanged':\n                    void this.unsubscribeFromNetworkChangeEvent();\n                    break;\n                case 'connect':\n                    void this.unsubscribeFromConnectEvent().catch((...args) => this.log('connect', args));\n                    break;\n                case 'disconnect':\n                    void this.unsubscribeFromDisconnectEvent().catch((...args) => this.log('disconnect', args));\n                    break;\n            }\n        }\n        return this;\n    }\n    subscribeToNetworkChangeEvent() {\n        invariant(!this._networkChangedUnsubscriptionCallback, 'Already subscribed to network change event');\n        this._networkChangedUnsubscriptionCallback = FamilyAccountsSdk.ethereum.onNetworkChange((newValue) => {\n            this._eventEmitter.emit('chainChanged', newValue.chainId);\n        });\n    }\n    unsubscribeFromNetworkChangeEvent() {\n        invariant(this._networkChangedUnsubscriptionCallback, 'Not subscribed to network change event');\n        this._networkChangedUnsubscriptionCallback();\n        this._networkChangedUnsubscriptionCallback = null;\n    }\n    async subscribeToAccountChangeEvent() {\n        await this.waitForConnection();\n        invariant(!this._accountsChangedUnsubscriptionCallback, 'Already subscribed to account change event');\n        let prevConnectedAccount = null;\n        // to avoid race condition issues with immediate unsubscribing we should not wait for session promise and immediately attach listener\n        // otherwise there is a short amount of time when `this._accountsChangedUnsubscriptionCallback` is not assigned but `unsubscribeFromAccountChangeEvent` called\n        void FamilyAccountsSdk.session.getCurrent().then((currentSession) => {\n            prevConnectedAccount =\n                currentSession.status === SessionStatus.AUTHENTICATED\n                    ? currentSession.wallet.address\n                    : null;\n        });\n        this._accountsChangedUnsubscriptionCallback = FamilyAccountsSdk.session.onChange((newValue) => {\n            const newConnectedAccount = newValue.status === SessionStatus.AUTHENTICATED ? newValue.wallet.address : null;\n            // session change affects more than just the account\n            // ONLY emit the event if the account changes\n            if (prevConnectedAccount !== newConnectedAccount) {\n                this._eventEmitter.emit('accountsChanged', newConnectedAccount === null ? [] : [newConnectedAccount]);\n                prevConnectedAccount = newConnectedAccount;\n            }\n        });\n    }\n    async unsubscribeFromAccountChangeEvent() {\n        await this.waitForConnection();\n        invariant(this._accountsChangedUnsubscriptionCallback, 'Not subscribed to account change event');\n        this._accountsChangedUnsubscriptionCallback();\n        this._accountsChangedUnsubscriptionCallback = null;\n    }\n    async subscribeToConnectEvent() {\n        await this.waitForConnection();\n        invariant(!this._connectUnsubscriptionCallback, 'Already subscribed to connect event');\n        this._connectUnsubscriptionCallback = FamilyAccountsSdk.onConnectionChange(async (isConnected) => {\n            if (isConnected) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const chainId = await this.request({ method: 'eth_chainId' });\n                if (!isString(chainId))\n                    return; // Invalid chainId\n                invariant(isString(chainId), 'Invalid chainId');\n                this._eventEmitter.emit('connect', {\n                    chainId,\n                });\n            }\n        });\n    }\n    async unsubscribeFromConnectEvent() {\n        await this.waitForConnection();\n        invariant(this._connectUnsubscriptionCallback, 'Not subscribed to connect event');\n        this._connectUnsubscriptionCallback();\n        this._connectUnsubscriptionCallback = null;\n    }\n    async subscribeToDisconnectEvent() {\n        await this.waitForConnection();\n        invariant(!this._disconnectUnsubscriptionCallback, 'Already subscribed to disconnect event');\n        this._disconnectUnsubscriptionCallback = FamilyAccountsSdk.onConnectionChange((isConnected) => {\n            if (!isConnected) {\n                this._eventEmitter.emit('disconnect');\n            }\n        });\n    }\n    async unsubscribeFromDisconnectEvent() {\n        await this.waitForConnection();\n        invariant(this._disconnectUnsubscriptionCallback, 'Not subscribed to account disconnect event');\n        this._disconnectUnsubscriptionCallback();\n        this._disconnectUnsubscriptionCallback = null;\n    }\n    /**\n     * Wait for the provider to be connected\n     * This is done to make provider compatible with `wagmi` `injected` connector that tries to attach events before the provider is connected\n     */\n    async waitForConnection() {\n        if (FamilyAccountsSdk.isConnected()) {\n            return;\n        }\n        // sdk is connecting, wait for it to finish\n        if (FamilyAccountsSdk.isConnecting()) {\n            const deferred = new Deferred();\n            const unsubscribe = FamilyAccountsSdk.onConnectionChange((isConnected) => {\n                if (isConnected) {\n                    deferred.resolve();\n                }\n            });\n            const { timeout } = await Promise.race([\n                deferred.promise.then(() => ({ timeout: false })),\n                delay(CONNECTION_TIMEOUT).then(() => ({ timeout: true })),\n            ]);\n            unsubscribe();\n            if (timeout) {\n                throw new EthereumProviderConnectionTimeoutError();\n            }\n            return;\n        }\n        const { timeout } = await Promise.race([\n            FamilyAccountsSdk.connect(this._config?.options).then(() => ({ timeout: false })),\n            delay(CONNECTION_TIMEOUT).then(() => ({ timeout: true })),\n        ]);\n        if (timeout) {\n            throw new EthereumProviderConnectionTimeoutError();\n        }\n    }\n}\n\nconst familyAccountsCustomActions = (client) => ({\n    getIdToken: async () => {\n        const currentSession = await FamilyAccountsSdk.session.getCurrent();\n        if (currentSession.status !== SessionStatus.AUTHENTICATED) {\n            return null;\n        }\n        return currentSession.idToken;\n    },\n    switchAccounts: async () => {\n        const addresses = await client.request({ method: 'family_switchAccounts', params: [] }, { retryCount: 0 });\n        return addresses.map((address) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address));\n    },\n    disconnect: async () => {\n        await client.request({\n            method: 'wallet_revokePermissions',\n            params: [\n                {\n                    eth_accounts: {},\n                },\n            ],\n        }, { retryCount: 0 });\n    },\n});\nconst createFamilyAccountsClient = async () => {\n    const currentSession = await FamilyAccountsSdk.session.getCurrent();\n    invariant(currentSession.status === SessionStatus.AUTHENTICATED, 'Account must be connected to create a Family Accounts client.');\n    const client = (0,viem__WEBPACK_IMPORTED_MODULE_2__.createWalletClient)({\n        account: currentSession.wallet.address,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.custom)(new EthereumProvider()),\n    })\n        .extend(viem__WEBPACK_IMPORTED_MODULE_4__.publicActions)\n        .extend(familyAccountsCustomActions);\n    return client;\n};\n\nconst version$1 = '2.16.5';\n\nconst getVersion = () => `@wagmi/core@${version$1}`;\n\nvar __classPrivateFieldGet = ( false) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BaseError_instances, _BaseError_walk;\nclass BaseError extends Error {\n    get docsBaseUrl() {\n        return 'https://wagmi.sh/core';\n    }\n    get version() {\n        return getVersion();\n    }\n    constructor(shortMessage, options = {}) {\n        super();\n        _BaseError_instances.add(this);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'WagmiCoreError'\n        });\n        const details = options.cause instanceof BaseError\n            ? options.cause.details\n            : options.cause?.message\n                ? options.cause.message\n                : options.details;\n        const docsPath = options.cause instanceof BaseError\n            ? options.cause.docsPath || options.docsPath\n            : options.docsPath;\n        this.message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(options.metaMessages ? [...options.metaMessages, ''] : []),\n            ...(docsPath\n                ? [\n                    `Docs: ${this.docsBaseUrl}${docsPath}.html${options.docsSlug ? `#${options.docsSlug}` : ''}`,\n                ]\n                : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: ${this.version}`,\n        ].join('\\n');\n        if (options.cause)\n            this.cause = options.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = options.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return __classPrivateFieldGet(this, _BaseError_instances, \"m\", _BaseError_walk).call(this, this, fn);\n    }\n}\n_BaseError_instances = new WeakSet(), _BaseError_walk = function _BaseError_walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err.cause)\n        return __classPrivateFieldGet(this, _BaseError_instances, \"m\", _BaseError_walk).call(this, err.cause, fn);\n    return err;\n};\n\nclass ChainNotConfiguredError extends BaseError {\n    constructor() {\n        super('Chain not configured.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ChainNotConfiguredError'\n        });\n    }\n}\n\nclass ProviderNotFoundError extends BaseError {\n    constructor() {\n        super('Provider not found.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ProviderNotFoundError'\n        });\n    }\n}\n\nfunction createConnector(createConnectorFn) {\n    return createConnectorFn;\n}\n\ninjected.type = 'injected';\nfunction injected(parameters = {}) {\n    const { shimDisconnect = true, unstable_shimAsyncInject } = parameters;\n    function getTarget() {\n        const target = parameters.target;\n        if (typeof target === 'function') {\n            const result = target();\n            if (result)\n                return result;\n        }\n        if (typeof target === 'object')\n            return target;\n        if (typeof target === 'string')\n            return {\n                ...(targetMap[target] ?? {\n                    id: target,\n                    name: `${target[0].toUpperCase()}${target.slice(1)}`,\n                    provider: `is${target[0].toUpperCase()}${target.slice(1)}`,\n                }),\n            };\n        return {\n            id: 'injected',\n            name: 'Injected',\n            provider(window) {\n                return window?.ethereum;\n            },\n        };\n    }\n    let accountsChanged;\n    let chainChanged;\n    let connect;\n    let disconnect;\n    return createConnector((config) => ({\n        get icon() {\n            return getTarget().icon;\n        },\n        get id() {\n            return getTarget().id;\n        },\n        get name() {\n            return getTarget().name;\n        },\n        /** @deprecated */\n        get supportsSimulation() {\n            return true;\n        },\n        type: injected.type,\n        async setup() {\n            const provider = await this.getProvider();\n            // Only start listening for events if `target` is set, otherwise `injected()` will also receive events\n            if (provider?.on && parameters.target) {\n                if (!connect) {\n                    connect = this.onConnect.bind(this);\n                    provider.on('connect', connect);\n                }\n                // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n                // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n            }\n        },\n        async connect({ chainId, isReconnecting } = {}) {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            let accounts = [];\n            if (isReconnecting)\n                accounts = await this.getAccounts().catch(() => []);\n            else if (shimDisconnect) {\n                // Attempt to show another prompt for selecting account if `shimDisconnect` flag is enabled\n                try {\n                    const permissions = await provider.request({\n                        method: 'wallet_requestPermissions',\n                        params: [{ eth_accounts: {} }],\n                    });\n                    accounts = permissions[0]?.caveats?.[0]?.value?.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n                    // `'wallet_requestPermissions'` can return a different order of accounts than `'eth_accounts'`\n                    // switch to `'eth_accounts'` ordering if more than one account is connected\n                    // https://github.com/wevm/wagmi/issues/4140\n                    if (accounts.length > 0) {\n                        const sortedAccounts = await this.getAccounts();\n                        accounts = sortedAccounts;\n                    }\n                }\n                catch (err) {\n                    const error = err;\n                    // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n                    // Only bubble up error if user rejects request\n                    if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError.code)\n                        throw new viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError(error);\n                    // Or prompt is already open\n                    if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.ResourceUnavailableRpcError.code)\n                        throw error;\n                }\n            }\n            try {\n                if (!accounts?.length && !isReconnecting) {\n                    const requestedAccounts = await provider.request({\n                        method: 'eth_requestAccounts',\n                    });\n                    accounts = requestedAccounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n                }\n                // Manage EIP-1193 event listeners\n                // https://eips.ethereum.org/EIPS/eip-1193#events\n                if (connect) {\n                    provider.removeListener('connect', connect);\n                    connect = undefined;\n                }\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n                // Switch to chain if provided\n                let currentChainId = await this.getChainId();\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError.code)\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                // Remove disconnected shim if it exists\n                if (shimDisconnect)\n                    await config.storage?.removeItem(`${this.id}.disconnected`);\n                // Add connected shim if no target exists\n                if (!parameters.target)\n                    await config.storage?.setItem('injected.connected', true);\n                return { accounts, chainId: currentChainId };\n            }\n            catch (err) {\n                const error = err;\n                if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError.code)\n                    throw new viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError(error);\n                if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.ResourceUnavailableRpcError.code)\n                    throw new viem__WEBPACK_IMPORTED_MODULE_5__.ResourceUnavailableRpcError(error);\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            // Manage EIP-1193 event listeners\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            if (!connect) {\n                connect = this.onConnect.bind(this);\n                provider.on('connect', connect);\n            }\n            // Experimental support for MetaMask disconnect\n            // https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md\n            try {\n                // Adding timeout as not all wallets support this method and can hang\n                // https://github.com/wevm/wagmi/issues/4064\n                await (0,viem__WEBPACK_IMPORTED_MODULE_6__.withTimeout)(() => \n                // TODO: Remove explicit type for viem@3\n                provider.request({\n                    // `'wallet_revokePermissions'` added in `viem@2.10.3`\n                    method: 'wallet_revokePermissions',\n                    params: [{ eth_accounts: {} }],\n                }), { timeout: 100 });\n            }\n            catch { }\n            // Add shim signalling connector is disconnected\n            if (shimDisconnect) {\n                await config.storage?.setItem(`${this.id}.disconnected`, true);\n            }\n            if (!parameters.target)\n                await config.storage?.removeItem('injected.connected');\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            const accounts = await provider.request({ method: 'eth_accounts' });\n            return accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            const hexChainId = await provider.request({ method: 'eth_chainId' });\n            return Number(hexChainId);\n        },\n        async getProvider() {\n            if (typeof window === 'undefined')\n                return undefined;\n            let provider;\n            const target = getTarget();\n            if (typeof target.provider === 'function')\n                provider = target.provider(window);\n            else if (typeof target.provider === 'string')\n                provider = findProvider(window, target.provider);\n            else\n                provider = target.provider;\n            // Some wallets do not conform to EIP-1193 (e.g. Trust Wallet)\n            // https://github.com/wevm/wagmi/issues/3526#issuecomment-1912683002\n            if (provider && !provider.removeListener) {\n                // Try using `off` handler if it exists, otherwise noop\n                if ('off' in provider && typeof provider.off === 'function')\n                    provider.removeListener =\n                        provider.off;\n                else\n                    provider.removeListener = () => { };\n            }\n            return provider;\n        },\n        async isAuthorized() {\n            try {\n                const isDisconnected = shimDisconnect &&\n                    // If shim exists in storage, connector is disconnected\n                    (await config.storage?.getItem(`${this.id}.disconnected`));\n                if (isDisconnected)\n                    return false;\n                // Don't allow injected connector to connect if no target is set and it hasn't already connected\n                // (e.g. flag in storage is not set). This prevents a targetless injected connector from connecting\n                // automatically whenever there is a targeted connector configured.\n                if (!parameters.target) {\n                    const connected = await config.storage?.getItem('injected.connected');\n                    if (!connected)\n                        return false;\n                }\n                const provider = await this.getProvider();\n                if (!provider) {\n                    if (unstable_shimAsyncInject !== undefined &&\n                        unstable_shimAsyncInject !== false) {\n                        // If no provider is found, check for async injection\n                        // https://github.com/wevm/references/issues/167\n                        // https://github.com/MetaMask/detect-provider\n                        const handleEthereum = async () => {\n                            if (typeof window !== 'undefined')\n                                window.removeEventListener('ethereum#initialized', handleEthereum);\n                            const provider = await this.getProvider();\n                            return !!provider;\n                        };\n                        const timeout = typeof unstable_shimAsyncInject === 'number'\n                            ? unstable_shimAsyncInject\n                            : 1_000;\n                        const res = await Promise.race([\n                            ...(typeof window !== 'undefined'\n                                ? [\n                                    new Promise((resolve) => window.addEventListener('ethereum#initialized', () => resolve(handleEthereum()), { once: true })),\n                                ]\n                                : []),\n                            new Promise((resolve) => setTimeout(() => resolve(handleEthereum()), timeout)),\n                        ]);\n                        if (res)\n                            return true;\n                    }\n                    throw new ProviderNotFoundError();\n                }\n                // Use retry strategy as some injected wallets (e.g. MetaMask) fail to\n                // immediately resolve JSON-RPC requests on page load.\n                const accounts = await (0,viem__WEBPACK_IMPORTED_MODULE_7__.withRetry)(() => this.getAccounts());\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ addEthereumChainParameter, chainId }) {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            const chain = config.chains.find((x) => x.id === chainId);\n            if (!chain)\n                throw new viem__WEBPACK_IMPORTED_MODULE_5__.SwitchChainError(new ChainNotConfiguredError());\n            const promise = new Promise((resolve) => {\n                const listener = ((data) => {\n                    if ('chainId' in data && data.chainId === chainId) {\n                        config.emitter.off('change', listener);\n                        resolve();\n                    }\n                });\n                config.emitter.on('change', listener);\n            });\n            try {\n                await Promise.all([\n                    provider\n                        .request({\n                        method: 'wallet_switchEthereumChain',\n                        params: [{ chainId: (0,viem__WEBPACK_IMPORTED_MODULE_8__.numberToHex)(chainId) }],\n                    })\n                        // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n                        // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n                        // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n                        // this callback or an externally emitted `'chainChanged'` event.\n                        // https://github.com/MetaMask/metamask-extension/issues/24247\n                        .then(async () => {\n                        const currentChainId = await this.getChainId();\n                        if (currentChainId === chainId)\n                            config.emitter.emit('change', { chainId });\n                    }),\n                    promise,\n                ]);\n                return chain;\n            }\n            catch (err) {\n                const error = err;\n                // Indicates chain is not added to provider\n                if (error.code === 4902 ||\n                    // Unwrapping for MetaMask Mobile\n                    // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n                    error\n                        ?.data?.originalError?.code === 4902) {\n                    try {\n                        const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};\n                        let blockExplorerUrls;\n                        if (addEthereumChainParameter?.blockExplorerUrls)\n                            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n                        else if (blockExplorer)\n                            blockExplorerUrls = [\n                                blockExplorer.url,\n                                ...Object.values(blockExplorers).map((x) => x.url),\n                            ];\n                        let rpcUrls;\n                        if (addEthereumChainParameter?.rpcUrls?.length)\n                            rpcUrls = addEthereumChainParameter.rpcUrls;\n                        else\n                            rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n                        const addEthereumChain = {\n                            blockExplorerUrls,\n                            chainId: (0,viem__WEBPACK_IMPORTED_MODULE_8__.numberToHex)(chainId),\n                            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                            iconUrls: addEthereumChainParameter?.iconUrls,\n                            nativeCurrency: addEthereumChainParameter?.nativeCurrency ??\n                                chain.nativeCurrency,\n                            rpcUrls,\n                        };\n                        await Promise.all([\n                            provider\n                                .request({\n                                method: 'wallet_addEthereumChain',\n                                params: [addEthereumChain],\n                            })\n                                .then(async () => {\n                                const currentChainId = await this.getChainId();\n                                if (currentChainId === chainId)\n                                    config.emitter.emit('change', { chainId });\n                                else\n                                    throw new viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError(new Error('User rejected switch after adding network.'));\n                            }),\n                            promise,\n                        ]);\n                        return chain;\n                    }\n                    catch (error) {\n                        throw new viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError(error);\n                    }\n                }\n                if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError.code)\n                    throw new viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError(error);\n                throw new viem__WEBPACK_IMPORTED_MODULE_5__.SwitchChainError(error);\n            }\n        },\n        async onAccountsChanged(accounts) {\n            // Disconnect if there are no accounts\n            if (accounts.length === 0)\n                this.onDisconnect();\n            // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n            else if (config.emitter.listenerCount('connect')) {\n                const chainId = (await this.getChainId()).toString();\n                this.onConnect({ chainId });\n                // Remove disconnected shim if it exists\n                if (shimDisconnect)\n                    await config.storage?.removeItem(`${this.id}.disconnected`);\n            }\n            // Regular change event\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onConnect(connectInfo) {\n            const accounts = await this.getAccounts();\n            if (accounts.length === 0)\n                return;\n            const chainId = Number(connectInfo.chainId);\n            config.emitter.emit('connect', { accounts, chainId });\n            // Manage EIP-1193 event listeners\n            const provider = await this.getProvider();\n            if (provider) {\n                if (connect) {\n                    provider.removeListener('connect', connect);\n                    connect = undefined;\n                }\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n            }\n        },\n        async onDisconnect(error) {\n            const provider = await this.getProvider();\n            // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n            // https://github.com/MetaMask/providers/pull/120\n            if (error && error.code === 1013) {\n                if (provider && !!(await this.getAccounts()).length)\n                    return;\n            }\n            // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically\n            // only called when the wallet is disconnected through the wallet's interface, meaning the wallet\n            // actually disconnected and we don't need to simulate it.\n            config.emitter.emit('disconnect');\n            // Manage EIP-1193 event listeners\n            if (provider) {\n                if (chainChanged) {\n                    provider.removeListener('chainChanged', chainChanged);\n                    chainChanged = undefined;\n                }\n                if (disconnect) {\n                    provider.removeListener('disconnect', disconnect);\n                    disconnect = undefined;\n                }\n                if (!connect) {\n                    connect = this.onConnect.bind(this);\n                    provider.on('connect', connect);\n                }\n            }\n        },\n    }));\n}\nconst targetMap = {\n    coinbaseWallet: {\n        id: 'coinbaseWallet',\n        name: 'Coinbase Wallet',\n        provider(window) {\n            if (window?.coinbaseWalletExtension)\n                return window.coinbaseWalletExtension;\n            return findProvider(window, 'isCoinbaseWallet');\n        },\n    },\n    metaMask: {\n        id: 'metaMask',\n        name: 'MetaMask',\n        provider(window) {\n            return findProvider(window, (provider) => {\n                if (!provider.isMetaMask)\n                    return false;\n                // Brave tries to make itself look like MetaMask\n                // Could also try RPC `web3_clientVersion` if following is unreliable\n                if (provider.isBraveWallet && !provider._events && !provider._state)\n                    return false;\n                // Other wallets that try to look like MetaMask\n                const flags = [\n                    'isApexWallet',\n                    'isAvalanche',\n                    'isBitKeep',\n                    'isBlockWallet',\n                    'isKuCoinWallet',\n                    'isMathWallet',\n                    'isOkxWallet',\n                    'isOKExWallet',\n                    'isOneInchIOSWallet',\n                    'isOneInchAndroidWallet',\n                    'isOpera',\n                    'isPhantom',\n                    'isPortal',\n                    'isRabby',\n                    'isTokenPocket',\n                    'isTokenary',\n                    'isUniswapWallet',\n                    'isZerion',\n                ];\n                for (const flag of flags)\n                    if (provider[flag])\n                        return false;\n                return true;\n            });\n        },\n    },\n    phantom: {\n        id: 'phantom',\n        name: 'Phantom',\n        provider(window) {\n            if (window?.phantom?.ethereum)\n                return window.phantom?.ethereum;\n            return findProvider(window, 'isPhantom');\n        },\n    },\n};\nfunction findProvider(window, select) {\n    function isProvider(provider) {\n        if (typeof select === 'function')\n            return select(provider);\n        if (typeof select === 'string')\n            return provider[select];\n        return true;\n    }\n    const ethereum = window.ethereum;\n    if (ethereum?.providers)\n        return ethereum.providers.find((provider) => isProvider(provider));\n    if (ethereum && isProvider(ethereum))\n        return ethereum;\n    return undefined;\n}\n\nconst Logo = 'data:image/png;base64,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';\n\nvar version = \"0.1.0\";\n\nconst familyAccountsConnector = (options) => {\n    const provider = new EthereumProvider(options);\n    return injected({\n        // note: we don't support `wallet_requestPermissions` at this point\n        shimDisconnect: false,\n        target() {\n            return {\n                id: 'familyAccountsProvider',\n                name: 'Family Accounts',\n                provider,\n                icon: Logo,\n            };\n        },\n    });\n};\nfamilyAccountsConnector.version = version;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFtaWx5L2xpYi9mYW1pbHktYWNjb3VudHMtY29ubmVjdG9yLUROZWs0SDdMLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyTDtBQUNySjs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4Qzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHVCQUF1QjtBQUM1RTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOztBQUUrVCIsInNvdXJjZXMiOlsid2VicGFjazovL2JsaW5rLXN0YXJ0ZXItbW9uYWQvLi9ub2RlX21vZHVsZXMvZmFtaWx5L2xpYi9mYW1pbHktYWNjb3VudHMtY29ubmVjdG9yLUROZWs0SDdMLmpzPzIxYmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcywgY3JlYXRlV2FsbGV0Q2xpZW50LCBjdXN0b20sIHB1YmxpY0FjdGlvbnMsIFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvciwgUmVzb3VyY2VVbmF2YWlsYWJsZVJwY0Vycm9yLCB3aXRoVGltZW91dCwgd2l0aFJldHJ5LCBTd2l0Y2hDaGFpbkVycm9yLCBudW1iZXJUb0hleCB9IGZyb20gJ3ZpZW0nO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxuY29uc3QgaXNTdHJpbmcgPSAoaW5wdXQpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIjtcbn07XG5cbmNsYXNzIENhdXNlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjYXVzZTtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zPy5jYXVzZSkge1xuICAgICAgdGhpcy5jYXVzZSA9IG9wdGlvbnMuY2F1c2U7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBgJHt0aGlzLm1lc3NhZ2V9XG5DQVVTRTogJHt0aGlzLmNhdXNlLm1lc3NhZ2V9YDtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5jYXVzZS5zdGFjayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLnN0YWNrID0gKHRoaXMuc3RhY2sgPz8gXCJcIikgKyBcIlxcbkNBVVNFOiBcIiArIHRoaXMuY2F1c2Uuc3RhY2s7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIERlZmVycmVkIHtcbiAgcHJvbWlzZTtcbiAgcmVzb2x2ZTtcbiAgcmVqZWN0O1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgZGVsYXkgPSAobXMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5cbmNvbnN0IG1pbnV0ZXNUb01zID0gKG1pbnV0ZXMpID0+IG1pbnV0ZXMgKiA2ZTQ7XG5jb25zdCBzZWNvbmRzVG9NcyA9IChzZWNvbmRzKSA9PiBzZWNvbmRzICogMWUzO1xuY29uc3QgbXNUb1NlY29uZHMgPSAobXMpID0+IG1zIC8gMWUzO1xuXG5jbGFzcyBJbnZhcmlhbnRFcnJvciBleHRlbmRzIENhdXNlZEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGBJbnZhcmlhbnRFcnJvcjogJHttZXNzYWdlfWAsIG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlLCBjYXVzZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihtZXNzYWdlLCB7IGNhdXNlIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVycm9yKGVycm9yKSB7XG4gIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKFxuICAgICAgYEludmFsaWQgZXJyb3IgdHlwZS4gUmVjZWl2ZWQgJHt0eXBlb2YgZXJyb3J9LCBleHBlY3RlZCBpbnN0YW5jZSBvZiBFcnJvcmBcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5ldmVyKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKG1lc3NhZ2UsIG9wdGlvbnMpO1xufVxuXG52YXIgU2Vzc2lvblN0YXR1cztcbihmdW5jdGlvbiAoU2Vzc2lvblN0YXR1cykge1xuICAgIFNlc3Npb25TdGF0dXNbXCJBVVRIRU5USUNBVEVEXCJdID0gXCJBVVRIRU5USUNBVEVEXCI7XG4gICAgU2Vzc2lvblN0YXR1c1tcIk5PVF9BVVRIRU5USUNBVEVEXCJdID0gXCJOT1RfQVVUSEVOVElDQVRFRFwiO1xufSkoU2Vzc2lvblN0YXR1cyB8fCAoU2Vzc2lvblN0YXR1cyA9IHt9KSk7XG5cbnZhciBDb21tdW5pY2F0aW9uVHlwZXM7XG4oZnVuY3Rpb24gKENvbW11bmljYXRpb25UeXBlcykge1xuICAgIC8qKlxuICAgICAqIFNlc3Npb25cbiAgICAgKi9cbiAgICBDb21tdW5pY2F0aW9uVHlwZXNbXCJzZXNzaW9uSW5pdFwiXSA9IFwic2Vzc2lvbkluaXRcIjtcbiAgICBDb21tdW5pY2F0aW9uVHlwZXNbXCJzZXNzaW9uR2V0Q3VycmVudFwiXSA9IFwic2Vzc2lvbkdldEN1cnJlbnRcIjtcbiAgICBDb21tdW5pY2F0aW9uVHlwZXNbXCJzZXNzaW9uQ2xlYXJcIl0gPSBcInNlc3Npb25DbGVhclwiO1xuICAgIC8qKlxuICAgICAqIEV0aGVyZXVtXG4gICAgICovXG4gICAgQ29tbXVuaWNhdGlvblR5cGVzW1wiZXRoZXJldW1Kc29uUnBjUmVxdWVzdFwiXSA9IFwiZXRoZXJldW1Kc29uUnBjUmVxdWVzdFwiO1xuICAgIENvbW11bmljYXRpb25UeXBlc1tcImV0aGVyZXVtSnNvblJwY1JlcXVpcmVzQXBwcm92YWxcIl0gPSBcImV0aGVyZXVtSnNvblJwY1JlcXVpcmVzQXBwcm92YWxcIjtcbn0pKENvbW11bmljYXRpb25UeXBlcyB8fCAoQ29tbXVuaWNhdGlvblR5cGVzID0ge30pKTtcblxudmFyIFN1YnNjcmlwdGlvblR5cGVzO1xuKGZ1bmN0aW9uIChTdWJzY3JpcHRpb25UeXBlcykge1xuICAgIC8qKlxuICAgICAqIFNlc3Npb24gcmVsYXRlZFxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvblR5cGVzW1wic2Vzc2lvbkNoYW5nZWRcIl0gPSBcInNlc3Npb25DaGFuZ2VkXCI7XG4gICAgLyoqXG4gICAgICogTmV0d29yayByZWxhdGVkXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uVHlwZXNbXCJldGhlcmV1bU5ldHdvcmtDaGFuZ2VkXCJdID0gXCJldGhlcmV1bU5ldHdvcmtDaGFuZ2VkXCI7XG4gICAgLyoqXG4gICAgICogTW9kYWwgcmVsYXRlZFxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvblR5cGVzW1wibW9kYWxPcGVuXCJdID0gXCJtb2RhbE9wZW5cIjtcbiAgICBTdWJzY3JpcHRpb25UeXBlc1tcIm1vZGFsQ2xvc2VcIl0gPSBcIm1vZGFsQ2xvc2VcIjtcbiAgICBTdWJzY3JpcHRpb25UeXBlc1tcIm1vZGFsVXBkYXRlXCJdID0gXCJtb2RhbFVwZGF0ZVwiO1xufSkoU3Vic2NyaXB0aW9uVHlwZXMgfHwgKFN1YnNjcmlwdGlvblR5cGVzID0ge30pKTtcblxudmFyIFBvcHVwQ29tbXVuaWNhdGlvblR5cGVzO1xuKGZ1bmN0aW9uIChQb3B1cENvbW11bmljYXRpb25UeXBlcykge1xuICAgIFBvcHVwQ29tbXVuaWNhdGlvblR5cGVzW1wiYXV0aFN0YXJ0XCJdID0gXCJhdXRoU3RhcnRcIjtcbiAgICBQb3B1cENvbW11bmljYXRpb25UeXBlc1tcInJwY1JlcXVlc3RcIl0gPSBcInJwY1JlcXVlc3RcIjtcbn0pKFBvcHVwQ29tbXVuaWNhdGlvblR5cGVzIHx8IChQb3B1cENvbW11bmljYXRpb25UeXBlcyA9IHt9KSk7XG5cbmNsYXNzIFN0YXRlIHtcbiAgICBzdGF0aWMgc2V0RXhlY3V0b3JXaW5kb3cgPSAoX3dpbmRvdykgPT4ge1xuICAgICAgICB3aW5kb3cuX19fX2ZhX3dyYXBwZXIgPSB7XG4gICAgICAgICAgICB3aW5kb3c6IF93aW5kb3csXG4gICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5fX19fZmFfd3JhcHBlcj8ub3JpZ2luLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgc3RhdGljIGdldEV4ZWN1dG9yV2luZG93ID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXdpbmRvdy5fX19fZmFfd3JhcHBlcj8ud2luZG93KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGNhbGwgYGNvbm5lY3RgIHRvIHN0YXJ0IHVwIHRoZSBzZGstd2ViLWVsZW1lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5fX19fZmFfd3JhcHBlci53aW5kb3c7XG4gICAgfTtcbiAgICBzdGF0aWMgc2V0RXhlY3V0b3JPcmlnaW4gPSAob3JpZ2luKSA9PiB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gd2luZG93Ll9fX19mYV93cmFwcGVyO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuX19fX2ZhX3dyYXBwZXIgPSB7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICB3aW5kb3c6IHdpbmRvdy5fX19fZmFfd3JhcHBlcj8ud2luZG93LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgc3RhdGljIGdldEV4ZWN1dG9yT3JpZ2luID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXdpbmRvdy5fX19fZmFfd3JhcHBlcj8ub3JpZ2luKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGNhbGwgYGNvbm5lY3RgIHRvIHN0YXJ0IHVwIHRoZSBzZGstd2ViLWVsZW1lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5fX19fZmFfd3JhcHBlci5vcmlnaW47XG4gICAgfTtcbn1cblxubGV0IHBvc3RSb2JvdCA9IG51bGw7XG4vKipcbiAqIFdlIGRvIG5vdCBpbXBvcnQgYHBvc3Qtcm9ib3RgIHJpZ2h0IGF3YXkgYXMgaXQgd291bGQgY2F1c2UgU1NSIGlzc3VlcyBnaXZlbiBgcG9zdC1yb2JvdGAgcmVxdWlyZXMgYWNjZXNzIHRvIGB3aW5kb3dgIHJpZ2h0IGF3YXlcbiAqL1xuY29uc3QgaW5pdFBvc3RSb2JvdCA9IGFzeW5jICgpID0+IHtcbiAgICBwb3N0Um9ib3QgPSBhd2FpdCBpbXBvcnQoJy4vaW5kZXgtRERfa25kRHMuanMnKS50aGVuKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLmk7IH0pO1xufTtcbmNvbnN0IGdldFBvc3RSb2JvdCA9ICgpID0+IHtcbiAgICBpbnZhcmlhbnQocG9zdFJvYm90LCAnWW91IG5lZWQgdG8gaW5pdCBwb3N0IHJvYm90IGZpcnN0Jyk7XG4gICAgcmV0dXJuIHBvc3RSb2JvdDtcbn07XG5cbmNvbnN0IERFRkFVTFRfUFJPWFlfVElNRU9VVCQxID0gbWludXRlc1RvTXMoMSk7XG5jb25zdCBwcm94eSA9IGFzeW5jIChyZXF1ZXN0LCBjb25maWcpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcHJveHkgaW4gYSBub24gYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9ICdkYXRhJyBpbiByZXF1ZXN0ID8gcmVxdWVzdC5kYXRhIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGV2ZW50ID0gYXdhaXQgZ2V0UG9zdFJvYm90KCkuc2VuZChTdGF0ZS5nZXRFeGVjdXRvcldpbmRvdygpLCByZXF1ZXN0LnR5cGUsIGRhdGEsIHtcbiAgICAgICAgdGltZW91dDogY29uZmlnPy50aW1lb3V0ID8/IERFRkFVTFRfUFJPWFlfVElNRU9VVCQxLFxuICAgIH0pO1xuICAgIHJldHVybiBldmVudC5kYXRhO1xufTtcbmNvbnN0IGxpc3RlbmVycyA9IG5ldyBNYXAoKTtcbi8qKlxuICogU3Vic2NyaWJlIHRvIGEgc3BlY2lmaWMgZXZlbnRcbiAqIFN1cHBvcnRzIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNhbWUgZXZlbnRcbiAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20va3Jha2VuanMvcG9zdC1yb2JvdC9pc3N1ZXMvNDhcbiAqL1xuY29uc3Qgc3Vic2NyaWJlID0gKHR5cGUsIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN1YnNjcmliZSBpbiBhIG5vbiBicm93c2VyIGVudmlyb25tZW50XCIpO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXJzLmhhcyh0eXBlKSkge1xuICAgICAgICBsaXN0ZW5lcnMuZ2V0KHR5cGUpPy5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGdldFBvc3RSb2JvdCgpLm9uKHR5cGUsIHsgd2luZG93OiBTdGF0ZS5nZXRFeGVjdXRvcldpbmRvdygpIH0sIChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmdldCh0eXBlKT8uY2FsbGJhY2tzLmZvckVhY2goKGMpID0+IGMoZXZlbnQuZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdGVuZXJzLnNldCh0eXBlLCB7IGxpc3RlbmVyLCBjYWxsYmFja3M6IFtjYWxsYmFja10gfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVySW5mbyA9IGxpc3RlbmVycy5nZXQodHlwZSk7XG4gICAgICAgIGlmICghbGlzdGVuZXJJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q2FsbGJhY2tzID0gbGlzdGVuZXJJbmZvLmNhbGxiYWNrcy5maWx0ZXIoKGMpID0+IGMgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKG5ld0NhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxpc3RlbmVySW5mby5saXN0ZW5lci5jYW5jZWwoKTtcbiAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lckluZm8uY2FsbGJhY2tzID0gbmV3Q2FsbGJhY2tzO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmNvbnN0IGdldE1hc3RlcklmcmFtZVVybCA9ICgpID0+IHtcbiAgICByZXR1cm4gU3RhdGUuZ2V0RXhlY3V0b3JPcmlnaW4oKSArICcvaW5qZWN0ZWQvbWFzdGVyJztcbn07XG5cbmNsYXNzIEludGVncmF0ZWRDbGllbnRNb2RhbENvbnRyb2xsZXIge1xuICAgIHVuc3Vic2NyaWJlO1xuICAgIGF1dG9IZWlnaHQgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIGlmcmFtZSkge1xuICAgICAgICBjb25zdCBtb2RhbE9wZW5VbnN1YnNjcmliZSA9IHN1YnNjcmliZShTdWJzY3JpcHRpb25UeXBlcy5tb2RhbE9wZW4sICh7IGhlaWdodCB9KSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnNldFByb3BlcnR5KCdvdmVyZmxvdycsICdoaWRkZW4nLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgICAvLyBhdm9pZCBzY3JvbGxiYXIganVtcGluZyB3aGVuIGhpZGRlbiBpcyBhcHBsaWVkXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnNldFByb3BlcnR5KCdwYWRkaW5nLXJpZ2h0JywgJzE1cHgnLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnZmxleCcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0hlaWdodClcbiAgICAgICAgICAgICAgICBpZnJhbWUuc3R5bGUuc2V0UHJvcGVydHkoJ2hlaWdodCcsIGhlaWdodC50b1N0cmluZygpICsgJ3B4Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtb2RhbENsb3NlVW5zdWJzY3JpYmUgPSBzdWJzY3JpYmUoU3Vic2NyaXB0aW9uVHlwZXMubW9kYWxDbG9zZSwgKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtb2RhbFVwZGF0ZVVuc3Vic2NyaWJlID0gc3Vic2NyaWJlKFN1YnNjcmlwdGlvblR5cGVzLm1vZGFsVXBkYXRlLCAoeyBoZWlnaHQgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0hlaWdodClcbiAgICAgICAgICAgICAgICBpZnJhbWUuc3R5bGUuc2V0UHJvcGVydHkoJ2hlaWdodCcsIGhlaWdodC50b1N0cmluZygpICsgJ3B4Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICAgICAgbW9kYWxPcGVuVW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIG1vZGFsQ2xvc2VVbnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgbW9kYWxVcGRhdGVVbnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufVxuXG5jb25zdCBJRlJBTUVfSUQgPSAnZmFtaWx5LWFjY291bnRzLW1hc3Rlci1pZnJhbWUnO1xuY29uc3QgQ09OTkVDVElPTl9USU1FT1VUJDEgPSAyMDAwMDtcbmxldCBtb2RhbENvbnRyb2xsZXIgPSBudWxsO1xuY29uc3QgY3JlYXRlRWxlbWVudHMgPSAoeyBmdWxsc2NyZWVuIH0gPSB7fSkgPT4ge1xuICAgIGlmIChmdWxsc2NyZWVuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmluc2V0ID0gJzAnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuekluZGV4ID0gJzIxNDc0ODM2NDcnO1xuICAgICAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgaWZyYW1lLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgaWZyYW1lLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgICAgIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgICBpZnJhbWUuaWQgPSBJRlJBTUVfSUQ7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBnZXRNYXN0ZXJJZnJhbWVVcmwoKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIHJldHVybiB7IGNvbnRhaW5lciwgaWZyYW1lIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdjZW50ZXInO1xuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS56SW5kZXggPSAnMjE0NzQ4MzY0Nyc7XG4gICAgICAgIGNvbnN0IGJhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJhY2tkcm9wLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgYmFja2Ryb3Auc3R5bGUuaW5zZXQgPSAnMCc7XG4gICAgICAgIGJhY2tkcm9wLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDAuNSknO1xuICAgICAgICBiYWNrZHJvcC5zdHlsZS56SW5kZXggPSAnLTEnO1xuICAgICAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgaWZyYW1lLnN0eWxlLmJvcmRlclJhZGl1cyA9ICcxMHB4JztcbiAgICAgICAgaWZyYW1lLnN0eWxlLmJveFNoYWRvdyA9ICcwIDAgMTBweCAwIHJnYmEoMCwwLDAsMC41KSc7XG4gICAgICAgIGlmcmFtZS5pZCA9IElGUkFNRV9JRDtcbiAgICAgICAgaWZyYW1lLnNyYyA9IGdldE1hc3RlcklmcmFtZVVybCgpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYmFja2Ryb3ApO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgcmV0dXJuIHsgY29udGFpbmVyLCBpZnJhbWUgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBJbmplY3RzIHRoZSBzZGstd2ViLWV4ZWN1dG9yIHNvIHRoZSBzZGstd2ViLWVsZW1lbnRzIGNhbiBjYWxsIHRoZSB3ZWItZWxlbWVudHNcbiAqL1xuY29uc3QgY29ubmVjdCA9ICh7IGVudmlyb25tZW50IH0pID0+IHtcbiAgICBjb25zdCBjb25uZWN0ZWQgPSBpc0Nvbm5lY3RlZCgpO1xuICAgIC8vIGRvIG5vdGhpbmcgaWYgYWxyZWFkeSBjb25uZWN0ZWRcbiAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgZnVsZmlsbGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGlmIGl0IHRha2VzIGxvbmdlciB0aGVuIENPTk5FQ1RJT05fVElNRU9VVCBzZWNvbmRzIGVycm9yIVxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBmdWxmaWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVqZWN0KGBUaGUgc2RrLXdlYi1lbGVtZW50cyBmYWlsZWQgdG8gY29ubmVjdCB3aXRoaW4gJHttc1RvU2Vjb25kcyhDT05ORUNUSU9OX1RJTUVPVVQkMSl9IHNlY29uZHMsIHBsZWFzZSBjb250YWN0IHN1cHBvcnQuYCk7XG4gICAgICAgIH0sIENPTk5FQ1RJT05fVElNRU9VVCQxKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gZW52aXJvbm1lbnQud2ViRWxlbWVudHNBcHBVcmw7XG4gICAgICAgIFN0YXRlLnNldEV4ZWN1dG9yT3JpZ2luKG9yaWdpbik7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyLCBpZnJhbWUgfSA9IGNyZWF0ZUVsZW1lbnRzKHtcbiAgICAgICAgICAgIGZ1bGxzY3JlZW46IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bGZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgU3RhdGUuc2V0RXhlY3V0b3JXaW5kb3coaWZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgICAgICAgbW9kYWxDb250cm9sbGVyID0gbmV3IEludGVncmF0ZWRDbGllbnRNb2RhbENvbnRyb2xsZXIoY29udGFpbmVyLCBpZnJhbWUpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGluaXQgcG9zdC1yb2JvdCBiZWZvcmUgYXBwZW5kaW5nIGlmcmFtZVxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgbGlzdGVuZXJzIGFyZSBwcm9wZXJseSBzZXR1cFxuICAgICAgICB2b2lkIGluaXRQb3N0Um9ib3QoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuY29uc3QgaXNDb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgY29uc3QgY29ubmVjdG9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoSUZSQU1FX0lEKTtcbiAgICByZXR1cm4gISFjb25uZWN0b3IgJiYgISFtb2RhbENvbnRyb2xsZXI7XG59O1xuLyoqXG4gKiBSZW1vdmVzIHRoZSBpbmplY3RlZCBzZGstd2ViLWV4ZWN1dG9yXG4gKi9cbmNvbnN0IGRpc2Nvbm5lY3QgPSAoKSA9PiB7XG4gICAgY29uc3QgY29ubmVjdGVkID0gaXNDb25uZWN0ZWQoKTtcbiAgICAvLyBkbyBub3RoaW5nIGlmIG5vdCBjb25uZWN0ZWRcbiAgICBpZiAoIWNvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3RvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKElGUkFNRV9JRCk7XG4gICAgaW52YXJpYW50KGNvbm5lY3RvciwgJ1RoZSBjb25uZWN0b3IgaXMgbm90IGRlZmluZWQnKTtcbiAgICBpbnZhcmlhbnQobW9kYWxDb250cm9sbGVyLCAnVGhlIG1vZGFsIGNvbnRyb2xsZXIgaXMgbm90IGRlZmluZWQnKTtcbiAgICBtb2RhbENvbnRyb2xsZXIuZGlzY29ubmVjdCgpO1xuICAgIGNvbm5lY3Rvci5yZW1vdmUoKTtcbn07XG5cbmNvbnN0IERFVklDRV9MT0NBTF9TVE9SQUdFX0tFWSA9ICdmYW1pbHlfYWNjb3VudHNfX2RldmljZV9pZCc7XG5jb25zdCBnZXREZXZpY2VJZCA9ICgpID0+IGxvY2FsU3RvcmFnZS5nZXRJdGVtKERFVklDRV9MT0NBTF9TVE9SQUdFX0tFWSk7XG5jb25zdCBzZXREZXZpY2VJZCA9IChkZXZpY2VJZCkgPT4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oREVWSUNFX0xPQ0FMX1NUT1JBR0VfS0VZLCBkZXZpY2VJZCk7XG5jb25zdCBTRVNTSU9OX0tFWV9MT0NBTF9TVE9SQUdFX0tFWSA9ICdmYW1pbHlfYWNjb3VudHNfX3Nlc3Npb25fa2V5JztcbmNvbnN0IGdldFNlc3Npb25LZXkgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNFU1NJT05fS0VZX0xPQ0FMX1NUT1JBR0VfS0VZKTtcbn07XG5jb25zdCBzZXRTZXNzaW9uS2V5ID0gKHNlc3Npb25LZXkpID0+IHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oU0VTU0lPTl9LRVlfTE9DQUxfU1RPUkFHRV9LRVksIHNlc3Npb25LZXkpO1xufTtcbmNvbnN0IHJlbW92ZVNlc3Npb25LZXkgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNFU1NJT05fS0VZX0xPQ0FMX1NUT1JBR0VfS0VZKTtcbn07XG5cbmNvbnN0IHByb2R1Y3Rpb24gPSB7XG4gICAgbmFtZTogJ3Byb2R1Y3Rpb24nLFxuICAgIHdlYkVsZW1lbnRzQXBwVXJsOiAnaHR0cHM6Ly9hcHAuZmFtaWx5LmNvJyxcbn07XG5cbmNvbnN0IERFRkFVTFRfUFJPWFlfVElNRU9VVCA9IG1pbnV0ZXNUb01zKDEpO1xuY29uc3QgY2FsY3VsYXRlUG9wdXBQb3NpdGlvbiA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IHdpbmRvdy5zY3JlZW5YICsgKHdpbmRvdy5vdXRlcldpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICBjb25zdCB0b3AgPSB3aW5kb3cuc2NyZWVuWSArICh3aW5kb3cub3V0ZXJIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3AsXG4gICAgfTtcbn07XG5jb25zdCBnZXRQb3B1cFNpemUgPSAoc2l6ZSkgPT4ge1xuICAgIHN3aXRjaCAoc2l6ZSkge1xuICAgICAgICBjYXNlIFBvcHVwU2l6ZS5NRURJVU06XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA0NDQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1ODYsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFBvcHVwU2l6ZS5JTkhFUklURUQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cub3V0ZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5vdXRlckhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgfVxufTtcbnZhciBQb3B1cFNpemU7XG4oZnVuY3Rpb24gKFBvcHVwU2l6ZSkge1xuICAgIFBvcHVwU2l6ZVtcIk1FRElVTVwiXSA9IFwiTUVESVVNXCI7XG4gICAgUG9wdXBTaXplW1wiSU5IRVJJVEVEXCJdID0gXCJJTkhFUklURURcIjtcbn0pKFBvcHVwU2l6ZSB8fCAoUG9wdXBTaXplID0ge30pKTtcbmNvbnN0IG9wZW5Qb3B1cCA9ICh1cmwsIG5hbWUsIHNpemUgPSBQb3B1cFNpemUuTUVESVVNKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBnZXRQb3B1cFNpemUoc2l6ZSk7XG4gICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IGNhbGN1bGF0ZVBvcHVwUG9zaXRpb24od2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGB3aWR0aD0ke3dpZHRofSxoZWlnaHQ9JHtoZWlnaHR9LGxlZnQ9JHtsZWZ0fSx0b3A9JHt0b3B9LG1lbnViYXI9bm8sdG9vbGJhcj1ubyxsb2NhdGlvbj1ubyxzdGF0dXM9bm9gO1xuICAgIHJldHVybiB3aW5kb3cub3Blbih1cmwsIG5hbWUsIG9wdGlvbnMpO1xufTtcbmNvbnN0IHByb3h5UG9wdXAgPSBhc3luYyAocG9wdXAsIHJlcXVlc3QsIGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSAnZGF0YScgaW4gcmVxdWVzdCA/IHJlcXVlc3QuZGF0YSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBldmVudCA9IGF3YWl0IGdldFBvc3RSb2JvdCgpLnNlbmQocG9wdXAsIHJlcXVlc3QudHlwZSwgZGF0YSwge1xuICAgICAgICB0aW1lb3V0OiBjb25maWc/LnRpbWVvdXQgPz8gREVGQVVMVF9QUk9YWV9USU1FT1VULFxuICAgIH0pO1xuICAgIHJldHVybiBldmVudC5kYXRhO1xufTtcblxubGV0IGNvbm5lY3Rpb25DaGFuZ2VMaXN0ZW5lcnMgPSBbXTtcbnZhciBTZGtTdGF0dXM7XG4oZnVuY3Rpb24gKFNka1N0YXR1cykge1xuICAgIFNka1N0YXR1c1tTZGtTdGF0dXNbXCJESVNDT05ORUNURURcIl0gPSAwXSA9IFwiRElTQ09OTkVDVEVEXCI7XG4gICAgU2RrU3RhdHVzW1Nka1N0YXR1c1tcIkNPTk5FQ1RJTkdcIl0gPSAxXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIFNka1N0YXR1c1tTZGtTdGF0dXNbXCJDT05ORUNURURcIl0gPSAyXSA9IFwiQ09OTkVDVEVEXCI7XG59KShTZGtTdGF0dXMgfHwgKFNka1N0YXR1cyA9IHt9KSk7XG5sZXQgc2RrU3RhdHVzID0gU2RrU3RhdHVzLkRJU0NPTk5FQ1RFRDtcbmNvbnN0IHJlcXVpcmVDb25uZWN0ZWRTZGsgPSAoKSA9PiB7XG4gICAgaWYgKHNka1N0YXR1cyAhPT0gU2RrU3RhdHVzLkNPTk5FQ1RFRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbWlseSBBY2NvdW50cyBpcyBub3QgY29ubmVjdGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBGYW1pbHlBY2NvdW50c1Nkay5jb25uZWN0KCkgZmlyc3QuJyk7XG4gICAgfVxufTtcbnZhciBTZXNzaW9uQ3JlYXRlUmVzdWx0O1xuKGZ1bmN0aW9uIChTZXNzaW9uQ3JlYXRlUmVzdWx0KSB7XG4gICAgLyoqXG4gICAgICogVXNlciBzdWNjZXNzZnVsbHkgYXV0aGVudGljYXRlZFxuICAgICAqL1xuICAgIFNlc3Npb25DcmVhdGVSZXN1bHRbXCJTVUNDRVNTXCJdID0gXCJTVUNDRVNTXCI7XG4gICAgLyoqXG4gICAgICogVXNlciBjYW5jZWxsZWQgcG9wdXAgYnkgY2xvc2luZyBpdCBvciBieSB0aW1lb3V0XG4gICAgICovXG4gICAgU2Vzc2lvbkNyZWF0ZVJlc3VsdFtcIlVTRVJfQ0FOQ0VMTEVEXCJdID0gXCJVU0VSX0NBTkNFTExFRFwiO1xuICAgIC8qKlxuICAgICAqIFBvcHVwIHdhcyBibG9ja2VkIGJ5IHRoZSBicm93c2VyXG4gICAgICovXG4gICAgU2Vzc2lvbkNyZWF0ZVJlc3VsdFtcIkJST1dTRVJfQkxPQ0tFRFwiXSA9IFwiQlJPV1NFUl9CTE9DS0VEXCI7XG59KShTZXNzaW9uQ3JlYXRlUmVzdWx0IHx8IChTZXNzaW9uQ3JlYXRlUmVzdWx0ID0ge30pKTtcbmNvbnN0IEZhbWlseUFjY291bnRzU2RrID0ge1xuICAgIGFzeW5jIGNvbm5lY3QoY29uZmlnID0geyBlbnZpcm9ubWVudDogcHJvZHVjdGlvbiB9KSB7XG4gICAgICAgIGlmIChzZGtTdGF0dXMgPT09IFNka1N0YXR1cy5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFtaWx5IEFjY291bnRzIGlzIGFscmVhZHkgY29ubmVjdGVkLiBEbyBub3QgY2FsbCBGYW1pbHlBY2NvdW50c1Nkay5jb25uZWN0KCkgbW9yZSB0aGFuIG9uY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNka1N0YXR1cyA9PT0gU2RrU3RhdHVzLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFtaWx5IEFjY291bnRzIGlzIGFscmVhZHkgY29ubmVjdGluZy4gRG8gbm90IGNhbGwgRmFtaWx5QWNjb3VudHNTZGsuY29ubmVjdCgpIG1vcmUgdGhhbiBvbmNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHNka1N0YXR1cyA9IFNka1N0YXR1cy5DT05ORUNUSU5HO1xuICAgICAgICBhd2FpdCBjb25uZWN0KGNvbmZpZyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi5pbml0KCk7XG4gICAgICAgIHNka1N0YXR1cyA9IFNka1N0YXR1cy5DT05ORUNURUQ7XG4gICAgICAgIGNvbm5lY3Rpb25DaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHRydWUpKTtcbiAgICB9LFxuICAgIGlzQ29ubmVjdGVkOiAoKSA9PiBzZGtTdGF0dXMgPT09IFNka1N0YXR1cy5DT05ORUNURUQsXG4gICAgaXNDb25uZWN0aW5nOiAoKSA9PiBzZGtTdGF0dXMgPT09IFNka1N0YXR1cy5DT05ORUNUSU5HLFxuICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmIChzZGtTdGF0dXMgIT09IFNka1N0YXR1cy5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFtaWx5IGFjY291bnRzIGlzIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5nZXRDdXJyZW50KCk7XG4gICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbi5zdGF0dXMgPT09IFNlc3Npb25TdGF0dXMuQVVUSEVOVElDQVRFRCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXNzaW9uLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdCgpO1xuICAgICAgICBzZGtTdGF0dXMgPSBTZGtTdGF0dXMuRElTQ09OTkVDVEVEO1xuICAgICAgICBjb25uZWN0aW9uQ2hhbmdlTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihmYWxzZSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSxcbiAgICBvbkNvbm5lY3Rpb25DaGFuZ2U6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25uZWN0aW9uQ2hhbmdlTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29ubmVjdGlvbkNoYW5nZUxpc3RlbmVycyA9IGNvbm5lY3Rpb25DaGFuZ2VMaXN0ZW5lcnMuZmlsdGVyKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNlc3Npb246IHtcbiAgICAgICAgY3JlYXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXF1aXJlQ29ubmVjdGVkU2RrKCk7XG4gICAgICAgICAgICBjb25zdCBwb3B1cCA9IG9wZW5Qb3B1cChgJHtTdGF0ZS5nZXRFeGVjdXRvck9yaWdpbigpfS9wb3B1cC9hdXRoYCwgJ0ZhbWlseUFjY291bnRzQXV0aGVudGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghcG9wdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFNlc3Npb25DcmVhdGVSZXN1bHQuQlJPV1NFUl9CTE9DS0VELFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJveHlQb3B1cChwb3B1cCwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBQb3B1cENvbW11bmljYXRpb25UeXBlcy5hdXRoU3RhcnQsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiBwb3B1cCBoYXMgb3duIHRpbWVvdXQsIHRoaXMgaXMgcHVyZWx5IHRvIGtlZXAgdGhlIGV2ZW50IGFsaXZlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG1pbnV0ZXNUb01zKDEwKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXRTZXNzaW9uS2V5KHJlc3BvbnNlLmNsaWVudFNlc3Npb25LZXkpO1xuICAgICAgICAgICAgICAgIHNldERldmljZUlkKHJlc3BvbnNlLmRldmljZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFNlc3Npb25DcmVhdGVSZXN1bHQuU1VDQ0VTUyxcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHJlc3BvbnNlLmRldmljZUlkLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRTZXNzaW9uS2V5OiByZXNwb25zZS5jbGllbnRTZXNzaW9uS2V5LFxuICAgICAgICAgICAgICAgICAgICBpZFRva2VuOiByZXNwb25zZS5pZFRva2VuLFxuICAgICAgICAgICAgICAgICAgICB3YWxsZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlc3BvbnNlLndhbGxldC5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgLy8gcXVpdGUgbGlrZWx5IGEgdGltZW91dCwgd2luZG93IHdhcyBjbG9zZWQgb3IgdXNlciByZWplY3RlZCBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBTZXNzaW9uQ3JlYXRlUmVzdWx0LlVTRVJfQ0FOQ0VMTEVELFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBgaW5pdGAgZnJvbSB0aGUgcHVibGljIEFQSVxuICAgICAgICBpbml0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IGdldERldmljZUlkKCk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRTZXNzaW9uS2V5ID0gZ2V0U2Vzc2lvbktleSgpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3h5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDb21tdW5pY2F0aW9uVHlwZXMuc2Vzc2lvbkluaXQsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50U2Vzc2lvbktleSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEN1cnJlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVpcmVDb25uZWN0ZWRTZGsoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm94eSh7XG4gICAgICAgICAgICAgICAgdHlwZTogQ29tbXVuaWNhdGlvblR5cGVzLnNlc3Npb25HZXRDdXJyZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlOiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHJlcXVpcmVDb25uZWN0ZWRTZGsoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmUoU3Vic2NyaXB0aW9uVHlwZXMuc2Vzc2lvbkNoYW5nZWQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6ICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVpcmVDb25uZWN0ZWRTZGsoKTtcbiAgICAgICAgICAgIHJlbW92ZVNlc3Npb25LZXkoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm94eSh7XG4gICAgICAgICAgICAgICAgdHlwZTogQ29tbXVuaWNhdGlvblR5cGVzLnNlc3Npb25DbGVhcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgZXRoZXJldW06IHtcbiAgICAgICAgb25OZXR3b3JrQ2hhbmdlOiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHJlcXVpcmVDb25uZWN0ZWRTZGsoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmUoU3Vic2NyaXB0aW9uVHlwZXMuZXRoZXJldW1OZXR3b3JrQ2hhbmdlZCwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG5jb25zdCBpc0ludGVyc2VjdGlvbk9ic2VydmVyVjJTdXBwb3J0ZWQgPSAoKSA9PiAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeScgaW4gd2luZG93ICYmICdpc1Zpc2libGUnIGluIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkucHJvdG90eXBlO1xuXG4vLyBBIGxpc3Qgb2YgbWV0aG9kcyB0aGF0IHBvdGVudGlhbGx5IHJlcXVpcmUgdXNlciBhcHByb3ZhbFxuLy8gSWYgaXQncyBhIHdlbGwga25vd24gbWV0aG9kIHdlIGNhbiBoYW5kbGUgd2l0aG91dCB1c2VyIGFwcHJvdmFsXG4vLyBCdXQgdG8gbWVldCBTYWZhcmkgcmVxdWlyZW1lbnRzIHdlIG5lZWQgdG8gZ2V0IHRoZSBmaXJzdCBkZWNpc2lvbiBwb2ludCBpbiBhIG5vbi1ibG9ja2luZyB3YXlcbi8vIE1ha2Ugc3VyZSBpdCdzIGluIHN5bmMgd2l0aCBgQVBQUk9WQUxfUkVRVUlSRURfTUVUSE9EU2AgZnJvbSBgSnNvblJwY1NlcnZpY2VgXG5jb25zdCBQT1RFTlRJQUxMWV9BUFBST1ZBTF9SRVFVSVJFRF9NRVRIT0RTID0gW1xuICAgICdwZXJzb25hbF9zaWduJyxcbiAgICAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAgJ2V0aF9zaWduVHlwZWREYXRhX3Y0JyxcbiAgICAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICdmYW1pbHlfc3dpdGNoQWNjb3VudHMnLFxuXTtcbmNsYXNzIFJwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvZGU7XG4gICAgbWVzc2FnZTtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBzdGF0aWMgdXNlclJlamVjdGVkUmVxdWVzdChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnBjRXJyb3IoNDAwMSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXRpYyB1bmF1dGhvcml6ZWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJwY0Vycm9yKDQxMDAsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNsYXNzIExvY2FsUnBjSGFuZGxlciB7XG4gICAgYXJncztcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFyZ3MubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlICdldGhfcmVxdWVzdEFjY291bnRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXF1ZXN0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBuZXZlcignVW5zdXBwb3J0ZWQgbWV0aG9kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmVxdWVzdEFjY291bnRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IEZhbWlseUFjY291bnRzU2RrLnNlc3Npb24uZ2V0Q3VycmVudCgpO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBTZXNzaW9uU3RhdHVzLkFVVEhFTlRJQ0FURUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3Nlc3Npb24ud2FsbGV0LmFkZHJlc3NdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3JlYXRlZFNlc3Npb24gPSBhd2FpdCBGYW1pbHlBY2NvdW50c1Nkay5zZXNzaW9uLmNyZWF0ZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChjcmVhdGVkU2Vzc2lvbi5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNlc3Npb25DcmVhdGVSZXN1bHQuU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVkU2Vzc2lvbi53YWxsZXQuYWRkcmVzc107XG4gICAgICAgICAgICAgICAgY2FzZSBTZXNzaW9uQ3JlYXRlUmVzdWx0LkJST1dTRVJfQkxPQ0tFRDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUnBjRXJyb3IudXNlclJlamVjdGVkUmVxdWVzdCgnQnJvd3NlciBibG9ja2VkIEZhbWlseSBBY2NvdW50cyBhdXRoZW50aWNhdGlvbiBwb3B1cCcpO1xuICAgICAgICAgICAgICAgIGNhc2UgU2Vzc2lvbkNyZWF0ZVJlc3VsdC5VU0VSX0NBTkNFTExFRDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUnBjRXJyb3IudXNlclJlamVjdGVkUmVxdWVzdCgnVXNlciBjYW5jZWxsZWQgYXV0aGVudGljYXRpb24gcmVxdWVzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGVycm9yIGFscmVhZHkgbG9va3MgbGlrZSBhIHJwYyBlcnJvciB0aGVuIHRocm93IGl0XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAnY29kZScgaW4gZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1vc3QgbGlrZWx5IGNhbid0IGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgUnBjRXJyb3IudXNlclJlamVjdGVkUmVxdWVzdCgnVW5rbm93biByZWFzb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIE1hc3RlcklmcmFtZVJwY0hhbmRsZXIge1xuICAgIGFyZ3M7XG4gICAgLy8gVGhlIGRlZmF1bHQgcG9zdCBtZXNzYWdlIHRpbWVvdXQgaXMgMTAgc2Vjb25kc1xuICAgIERFRkFVTFRfUlBDX0NBTExfVElNRU9VVCA9IHNlY29uZHNUb01zKDEwKTtcbiAgICBERUZBVUxUX1JQQ19TSUdOX1RJTUVPVVQgPSBtaW51dGVzVG9NcygxMCk7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBQT1RFTlRJQUxMWV9BUFBST1ZBTF9SRVFVSVJFRF9NRVRIT0RTLmluY2x1ZGVzKHRoaXMuYXJncy5tZXRob2QpXG4gICAgICAgICAgICA/IC8vIGlmIGl0cyBzZW5kaW5nIGEgdHJhbnNhY3Rpb24gbWFrZSB0aGUgdGltZW91dCB2ZXJ5XG4gICAgICAgICAgICAgICAgLy8gbG9uZyBhcyB0aGV5IG1heSBnZXQgYSBhcHByb3ZhbCBtb2RhbCBkaXNwbGF5ZWRcbiAgICAgICAgICAgICAgICAvLyBhbmQgaWYgc28gaGF2ZSBhIGBmb3JldmVyYCB0aW1lIHRvIGFwcHJvdmFsIGl0XG4gICAgICAgICAgICAgICAgdGhpcy5ERUZBVUxUX1JQQ19TSUdOX1RJTUVPVVRcbiAgICAgICAgICAgIDogdGhpcy5ERUZBVUxUX1JQQ19DQUxMX1RJTUVPVVQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm94eSh7XG4gICAgICAgICAgICAgICAgdHlwZTogQ29tbXVuaWNhdGlvblR5cGVzLmV0aGVyZXVtSnNvblJwY1JlcXVlc3QsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5hcmdzLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGludmFyaWFudChyZXN1bHQgIT09IHVuZGVmaW5lZCwgJ1RoZSBKU09OIFJQQyByZXN1bHQgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZXJyb3IgYWxyZWFkeSBsb29rcyBsaWtlIGEgcnBjIGVycm9yIHRoZW4gdGhyb3cgaXRcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgY2FuJ3QgaGFwcGVuXG4gICAgICAgICAgICB0aHJvdyBScGNFcnJvci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCdVbmtub3duIHJlYXNvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGhhbmRsZXIgZm9yIHJwYyByZXF1ZXN0IGluIGNhc2UgaW50ZXJzZWN0aW9uIG9ic2VydmVyIGlzIG5vdCBzdXBwb3J0ZWRcbiAqIE5vdGU6IEl0J3MgYnVpbGQgaW4gYSB3YXkgdG8gd29yayB3aXRoIHNhZmFyaSBwb3B1cCBibG9ja2VyIGluIG1pbmQgd2hlcmUgcG9wdXBzIGFyZSBibG9ja2VkIGlmIHRoZXkgYXJlIGhhcHBlbiBpbiBhIFByb21pc2VcbiAqL1xuY2xhc3MgUG9wdXBNb2RhbFJwY0hhbmRsZXIge1xuICAgIGFyZ3M7XG4gICAgLy8gaWYgaXQgdGFrZXMgbG9uZ2VyIHRvIGRldGVjdCBpZiBhcHByb3ZhbCBpcyByZXF1aXJlZCAoZS5nLiBzaW11bGF0aW9uIHRpbWUgaW50ZW5zaXZlKVxuICAgIC8vIHdlIHdvdWxkIHRoZW4gdHJlYXQgaXQgYXMgYXBwcm92YWwgcmVxdWlyZWQgdG8gbm90IGJsb2NrIHRoZSBVSVxuICAgIEFQUFJPVkFMX1JFUVVJUkVEX1RJTUVPVVQgPSAzMDA7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBoYW5kbGUoKSB7XG4gICAgICAgIGxldCByZXF1ZXN0UmVxdWlyZXNBcHByb3ZhbCA9IG51bGw7XG4gICAgICAgIC8vIG5vdGU6IGNhbid0IHVzZSBhc3luYy9hd2FpdCBoZXJlIGFzIHdpbGwgYmxvY2sgcG9wdXAgbW9kYWwgb24gU2FmYXJpXG4gICAgICAgIHZvaWQgcmVxdWlyZXNVc2VyQXBwcm92YWwodGhpcy5hcmdzKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3RSZXF1aXJlc0FwcHJvdmFsID0gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgLy8gbm90ZTogc2V0IHRpbWVvdXQgaXMgYWxsb3dlZCBieSBTYWZhcmkgdG8gb3BlbiBwb3B1cHNcbiAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyB1c2VyIGFwcHJvdmFsIGlzIG5vdCByZXF1aXJlZCBzbyB3ZSBjYW4gaGFuZGxlIGl0IGluIHRoZSBtYXN0ZXIgaWZyYW1lXG4gICAgICAgICAgICBpZiAocmVxdWVzdFJlcXVpcmVzQXBwcm92YWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbmV3IE1hc3RlcklmcmFtZVJwY0hhbmRsZXIodGhpcy5hcmdzKS5oYW5kbGUoKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9wdXAgPSBvcGVuUG9wdXAoYCR7U3RhdGUuZ2V0RXhlY3V0b3JPcmlnaW4oKX0vcG9wdXAvcnBjYCwgJ0ZhbWlseUFjY291bnRzUnBjJywgUG9wdXBTaXplLklOSEVSSVRFRCk7XG4gICAgICAgICAgICBpZiAoIXBvcHVwKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KFJwY0Vycm9yLnVzZXJSZWplY3RlZFJlcXVlc3QoJ1BvcHVwIGJsb2NrZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xpZW50U2Vzc2lvbktleSA9IGdldFNlc3Npb25LZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGRldmljZUlkID0gZ2V0RGV2aWNlSWQoKTtcbiAgICAgICAgICAgIGlmICghY2xpZW50U2Vzc2lvbktleSB8fCAhZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoUnBjRXJyb3IudW5hdXRob3JpemVkKCdVc2VyIG5vdCBhdXRob3JpemVkJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJveHlQb3B1cChwb3B1cCwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBQb3B1cENvbW11bmljYXRpb25UeXBlcy5ycGNSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRTZXNzaW9uS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiBwb3B1cCBoYXMgb3duIHRpbWVvdXQsIHRoaXMgaXMgcHVyZWx5IHRvIGtlZXAgdGhlIGV2ZW50IGFsaXZlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG1pbnV0ZXNUb01zKDEwKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVycm9yIGFscmVhZHkgbG9va3MgbGlrZSBhIHJwYyBlcnJvciB0aGVuIHRocm93IGl0XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcXVpdGUgbGlrZWx5IGEgdGltZW91dCwgd2luZG93IHdhcyBjbG9zZWQgb3IgdXNlciByZWplY3RlZCBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KFJwY0Vycm9yLnVzZXJSZWplY3RlZFJlcXVlc3QoJ1BvcHVwIHdhcyBjbG9zZWQgYnkgdGhlIHVzZXInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuQVBQUk9WQUxfUkVRVUlSRURfVElNRU9VVCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbn1cbmNvbnN0IHJlcXVpcmVzVXNlckFwcHJvdmFsID0gYXN5bmMgKGFyZ3MpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJveHkoe1xuICAgICAgICAgICAgdHlwZTogQ29tbXVuaWNhdGlvblR5cGVzLmV0aGVyZXVtSnNvblJwY1JlcXVpcmVzQXBwcm92YWwsXG4gICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIGlmIHRoZSBlcnJvciBhbHJlYWR5IGxvb2tzIGxpa2UgYSBycGMgZXJyb3IgdGhlbiB0aHJvdyBpdFxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAnY29kZScgaW4gZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vc3QgbGlrZWx5IGNhbid0IGhhcHBlblxuICAgICAgICB0aHJvdyBScGNFcnJvci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCdVbmtub3duIHJlYXNvbicpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRScGNSZXF1ZXN0SGFuZGxlcihhcmdzKSB7XG4gICAgaWYgKGFyZ3MubWV0aG9kID09PSAnZXRoX3JlcXVlc3RBY2NvdW50cycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbFJwY0hhbmRsZXIoYXJncyk7XG4gICAgfVxuICAgIGlmIChpc0ludGVyc2VjdGlvbk9ic2VydmVyVjJTdXBwb3J0ZWQoKSkge1xuICAgICAgICAvLyBub3RlOiBtYXN0ZXIgaWZyYW1lIHdpbGwgcmVqZWN0IHJlcXVlc3RzIGlmIGludGVyc2VjdGlvbiBvYnNlcnZlciBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybiBuZXcgTWFzdGVySWZyYW1lUnBjSGFuZGxlcihhcmdzKTtcbiAgICB9XG4gICAgaWYgKCFQT1RFTlRJQUxMWV9BUFBST1ZBTF9SRVFVSVJFRF9NRVRIT0RTLmluY2x1ZGVzKGFyZ3MubWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gbmV3IE1hc3RlcklmcmFtZVJwY0hhbmRsZXIoYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9wdXBNb2RhbFJwY0hhbmRsZXIoYXJncyk7XG59XG5cbmNvbnN0IENPTk5FQ1RJT05fVElNRU9VVCA9IHNlY29uZHNUb01zKDUpO1xuY2xhc3MgRXRoZXJldW1Qcm92aWRlckNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdFSVAxMTkzIHByb3ZpZGVyIGNvbm5lY3Rpb24gdGltZW91dC4gTWFrZSBzdXJlIHRvIGNhbGwgYEZhbWlseUFjY291bnRzU2RrLmNvbm5lY3QoKWAgYmVmb3JlIHVzaW5nIHRoZSBwcm92aWRlci4nKTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgZm9sbG93cyB0aGUgRUlQIC0gaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkzXG4gKi9cbmNsYXNzIEV0aGVyZXVtUHJvdmlkZXIge1xuICAgIF9ldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgX2FjY291bnRzQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuICAgIF9uZXR3b3JrQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuICAgIF9jb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IG51bGw7XG4gICAgX2Rpc2Nvbm5lY3RVbnN1YnNjcmlwdGlvbkNhbGxiYWNrID0gbnVsbDtcbiAgICBfY29uZmlnO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gb3B0aW9ucztcbiAgICB9XG4gICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZz8uZGVidWcpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlciBpcyBjb25uZWN0ZWQgYW5kIHJlYWR5IHRvIHByb2Nlc3MgcmVxdWVzdHNcbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIEZhbWlseUFjY291bnRzU2RrLmlzQ29ubmVjdGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpTT05SUEMgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBhcmdzIFRoZSByZXF1ZXN0IGFyZ3VtZW50c1xuICAgICAqL1xuICAgIC8vIHJldHVybiB0eXBlIGlzIGxvb3NlIGFzIHdlIGRvbid0IHdhbnQgdG8gdHlwZSBhbGwgdGhlIHBvc3NpYmxlIHJldHVybiB0eXBlcyBnaXZlbiBpdCdzIGEgcHJveHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIHJlcXVlc3QoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JDb25uZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVyID0gZ2V0UnBjUmVxdWVzdEhhbmRsZXIoe1xuICAgICAgICAgICAgbWV0aG9kOiBhcmdzLm1ldGhvZCxcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBwYXJhbXMgdG8gYmUgYW4gYXJyYXlcbiAgICAgICAgICAgIHBhcmFtczogQXJyYXkuaXNBcnJheShhcmdzLnBhcmFtcykgPyBhcmdzLnBhcmFtcyA6IFthcmdzLnBhcmFtc10sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVxdWVzdEhhbmRsZXIuaGFuZGxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpTT05SUEMgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIHJlcXVlc3QganNvbnJwYyBtZXRob2RcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGByZXF1ZXN0YCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7IG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGlzdGVuZXIpIHtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBgbWVzc2FnZWAgZXZlbnRcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZygnb24nLCBldmVudE5hbWUpO1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSA9PT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhY2NvdW50c0NoYW5nZWQnOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc3Vic2NyaWJlVG9BY2NvdW50Q2hhbmdlRXZlbnQoKS5jYXRjaCgoLi4uYXJncykgPT4gdGhpcy5sb2coJ2FjY291bnRzQ2hhbmdlZCcsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hhaW5DaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLnN1YnNjcmliZVRvTmV0d29ya0NoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc3Vic2NyaWJlVG9Db25uZWN0RXZlbnQoKS5jYXRjaCgoLi4uYXJncykgPT4gdGhpcy5sb2coJ2Nvbm5lY3QnLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc3Vic2NyaWJlVG9EaXNjb25uZWN0RXZlbnQoKS5jYXRjaCgoLi4uYXJncykgPT4gdGhpcy5sb2coJ2Rpc2Nvbm5lY3QnLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgcHJvdmlkZXIgZXZlbnQgZW1pdHRlcnNcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBsaXN0ZW5lcikge1xuICAgICAgICAvLyB3ZSBkb24ndCBzdXBwb3J0IGBtZXNzYWdlYCBldmVudFxuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnbWVzc2FnZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkgPT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWNjb3VudHNDaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLnVuc3Vic2NyaWJlRnJvbUFjY291bnRDaGFuZ2VFdmVudCgpLmNhdGNoKCguLi5hcmdzKSA9PiB0aGlzLmxvZygnYWNjb3VudHNDaGFuZ2VkJywgYXJncykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjaGFpbkNoYW5nZWQnOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMudW5zdWJzY3JpYmVGcm9tTmV0d29ya0NoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMudW5zdWJzY3JpYmVGcm9tQ29ubmVjdEV2ZW50KCkuY2F0Y2goKC4uLmFyZ3MpID0+IHRoaXMubG9nKCdjb25uZWN0JywgYXJncykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLnVuc3Vic2NyaWJlRnJvbURpc2Nvbm5lY3RFdmVudCgpLmNhdGNoKCguLi5hcmdzKSA9PiB0aGlzLmxvZygnZGlzY29ubmVjdCcsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvTmV0d29ya0NoYW5nZUV2ZW50KCkge1xuICAgICAgICBpbnZhcmlhbnQoIXRoaXMuX25ldHdvcmtDaGFuZ2VkVW5zdWJzY3JpcHRpb25DYWxsYmFjaywgJ0FscmVhZHkgc3Vic2NyaWJlZCB0byBuZXR3b3JrIGNoYW5nZSBldmVudCcpO1xuICAgICAgICB0aGlzLl9uZXR3b3JrQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2sgPSBGYW1pbHlBY2NvdW50c1Nkay5ldGhlcmV1bS5vbk5ldHdvcmtDaGFuZ2UoKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZW1pdCgnY2hhaW5DaGFuZ2VkJywgbmV3VmFsdWUuY2hhaW5JZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZUZyb21OZXR3b3JrQ2hhbmdlRXZlbnQoKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLl9uZXR3b3JrQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2ssICdOb3Qgc3Vic2NyaWJlZCB0byBuZXR3b3JrIGNoYW5nZSBldmVudCcpO1xuICAgICAgICB0aGlzLl9uZXR3b3JrQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5fbmV0d29ya0NoYW5nZWRVbnN1YnNjcmlwdGlvbkNhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgc3Vic2NyaWJlVG9BY2NvdW50Q2hhbmdlRXZlbnQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2FpdEZvckNvbm5lY3Rpb24oKTtcbiAgICAgICAgaW52YXJpYW50KCF0aGlzLl9hY2NvdW50c0NoYW5nZWRVbnN1YnNjcmlwdGlvbkNhbGxiYWNrLCAnQWxyZWFkeSBzdWJzY3JpYmVkIHRvIGFjY291bnQgY2hhbmdlIGV2ZW50Jyk7XG4gICAgICAgIGxldCBwcmV2Q29ubmVjdGVkQWNjb3VudCA9IG51bGw7XG4gICAgICAgIC8vIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uIGlzc3VlcyB3aXRoIGltbWVkaWF0ZSB1bnN1YnNjcmliaW5nIHdlIHNob3VsZCBub3Qgd2FpdCBmb3Igc2Vzc2lvbiBwcm9taXNlIGFuZCBpbW1lZGlhdGVseSBhdHRhY2ggbGlzdGVuZXJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZXJlIGlzIGEgc2hvcnQgYW1vdW50IG9mIHRpbWUgd2hlbiBgdGhpcy5fYWNjb3VudHNDaGFuZ2VkVW5zdWJzY3JpcHRpb25DYWxsYmFja2AgaXMgbm90IGFzc2lnbmVkIGJ1dCBgdW5zdWJzY3JpYmVGcm9tQWNjb3VudENoYW5nZUV2ZW50YCBjYWxsZWRcbiAgICAgICAgdm9pZCBGYW1pbHlBY2NvdW50c1Nkay5zZXNzaW9uLmdldEN1cnJlbnQoKS50aGVuKChjdXJyZW50U2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgcHJldkNvbm5lY3RlZEFjY291bnQgPVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnN0YXR1cyA9PT0gU2Vzc2lvblN0YXR1cy5BVVRIRU5USUNBVEVEXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudFNlc3Npb24ud2FsbGV0LmFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYWNjb3VudHNDaGFuZ2VkVW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IEZhbWlseUFjY291bnRzU2RrLnNlc3Npb24ub25DaGFuZ2UoKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb25uZWN0ZWRBY2NvdW50ID0gbmV3VmFsdWUuc3RhdHVzID09PSBTZXNzaW9uU3RhdHVzLkFVVEhFTlRJQ0FURUQgPyBuZXdWYWx1ZS53YWxsZXQuYWRkcmVzcyA6IG51bGw7XG4gICAgICAgICAgICAvLyBzZXNzaW9uIGNoYW5nZSBhZmZlY3RzIG1vcmUgdGhhbiBqdXN0IHRoZSBhY2NvdW50XG4gICAgICAgICAgICAvLyBPTkxZIGVtaXQgdGhlIGV2ZW50IGlmIHRoZSBhY2NvdW50IGNoYW5nZXNcbiAgICAgICAgICAgIGlmIChwcmV2Q29ubmVjdGVkQWNjb3VudCAhPT0gbmV3Q29ubmVjdGVkQWNjb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5lbWl0KCdhY2NvdW50c0NoYW5nZWQnLCBuZXdDb25uZWN0ZWRBY2NvdW50ID09PSBudWxsID8gW10gOiBbbmV3Q29ubmVjdGVkQWNjb3VudF0pO1xuICAgICAgICAgICAgICAgIHByZXZDb25uZWN0ZWRBY2NvdW50ID0gbmV3Q29ubmVjdGVkQWNjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVuc3Vic2NyaWJlRnJvbUFjY291bnRDaGFuZ2VFdmVudCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yQ29ubmVjdGlvbigpO1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5fYWNjb3VudHNDaGFuZ2VkVW5zdWJzY3JpcHRpb25DYWxsYmFjaywgJ05vdCBzdWJzY3JpYmVkIHRvIGFjY291bnQgY2hhbmdlIGV2ZW50Jyk7XG4gICAgICAgIHRoaXMuX2FjY291bnRzQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5fYWNjb3VudHNDaGFuZ2VkVW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZVRvQ29ubmVjdEV2ZW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JDb25uZWN0aW9uKCk7XG4gICAgICAgIGludmFyaWFudCghdGhpcy5fY29ubmVjdFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2ssICdBbHJlYWR5IHN1YnNjcmliZWQgdG8gY29ubmVjdCBldmVudCcpO1xuICAgICAgICB0aGlzLl9jb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IEZhbWlseUFjY291bnRzU2RrLm9uQ29ubmVjdGlvbkNoYW5nZShhc3luYyAoaXNDb25uZWN0ZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2NoYWluSWQnIH0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcoY2hhaW5JZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW52YWxpZCBjaGFpbklkXG4gICAgICAgICAgICAgICAgaW52YXJpYW50KGlzU3RyaW5nKGNoYWluSWQpLCAnSW52YWxpZCBjaGFpbklkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmVtaXQoJ2Nvbm5lY3QnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1bnN1YnNjcmliZUZyb21Db25uZWN0RXZlbnQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2FpdEZvckNvbm5lY3Rpb24oKTtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuX2Nvbm5lY3RVbnN1YnNjcmlwdGlvbkNhbGxiYWNrLCAnTm90IHN1YnNjcmliZWQgdG8gY29ubmVjdCBldmVudCcpO1xuICAgICAgICB0aGlzLl9jb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjaygpO1xuICAgICAgICB0aGlzLl9jb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZVRvRGlzY29ubmVjdEV2ZW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JDb25uZWN0aW9uKCk7XG4gICAgICAgIGludmFyaWFudCghdGhpcy5fZGlzY29ubmVjdFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2ssICdBbHJlYWR5IHN1YnNjcmliZWQgdG8gZGlzY29ubmVjdCBldmVudCcpO1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IEZhbWlseUFjY291bnRzU2RrLm9uQ29ubmVjdGlvbkNoYW5nZSgoaXNDb25uZWN0ZWQpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZW1pdCgnZGlzY29ubmVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmVGcm9tRGlzY29ubmVjdEV2ZW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JDb25uZWN0aW9uKCk7XG4gICAgICAgIGludmFyaWFudCh0aGlzLl9kaXNjb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjaywgJ05vdCBzdWJzY3JpYmVkIHRvIGFjY291bnQgZGlzY29ubmVjdCBldmVudCcpO1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjaygpO1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXQgZm9yIHRoZSBwcm92aWRlciB0byBiZSBjb25uZWN0ZWRcbiAgICAgKiBUaGlzIGlzIGRvbmUgdG8gbWFrZSBwcm92aWRlciBjb21wYXRpYmxlIHdpdGggYHdhZ21pYCBgaW5qZWN0ZWRgIGNvbm5lY3RvciB0aGF0IHRyaWVzIHRvIGF0dGFjaCBldmVudHMgYmVmb3JlIHRoZSBwcm92aWRlciBpcyBjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKEZhbWlseUFjY291bnRzU2RrLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZGsgaXMgY29ubmVjdGluZywgd2FpdCBmb3IgaXQgdG8gZmluaXNoXG4gICAgICAgIGlmIChGYW1pbHlBY2NvdW50c1Nkay5pc0Nvbm5lY3RpbmcoKSkge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gRmFtaWx5QWNjb3VudHNTZGsub25Db25uZWN0aW9uQ2hhbmdlKChpc0Nvbm5lY3RlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHRpbWVvdXQgfSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZS50aGVuKCgpID0+ICh7IHRpbWVvdXQ6IGZhbHNlIH0pKSxcbiAgICAgICAgICAgICAgICBkZWxheShDT05ORUNUSU9OX1RJTUVPVVQpLnRoZW4oKCkgPT4gKHsgdGltZW91dDogdHJ1ZSB9KSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdGhlcmV1bVByb3ZpZGVyQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCB9ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIEZhbWlseUFjY291bnRzU2RrLmNvbm5lY3QodGhpcy5fY29uZmlnPy5vcHRpb25zKS50aGVuKCgpID0+ICh7IHRpbWVvdXQ6IGZhbHNlIH0pKSxcbiAgICAgICAgICAgIGRlbGF5KENPTk5FQ1RJT05fVElNRU9VVCkudGhlbigoKSA9PiAoeyB0aW1lb3V0OiB0cnVlIH0pKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXRoZXJldW1Qcm92aWRlckNvbm5lY3Rpb25UaW1lb3V0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgZmFtaWx5QWNjb3VudHNDdXN0b21BY3Rpb25zID0gKGNsaWVudCkgPT4gKHtcbiAgICBnZXRJZFRva2VuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZXNzaW9uID0gYXdhaXQgRmFtaWx5QWNjb3VudHNTZGsuc2Vzc2lvbi5nZXRDdXJyZW50KCk7XG4gICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbi5zdGF0dXMgIT09IFNlc3Npb25TdGF0dXMuQVVUSEVOVElDQVRFRCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTZXNzaW9uLmlkVG9rZW47XG4gICAgfSxcbiAgICBzd2l0Y2hBY2NvdW50czogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7IG1ldGhvZDogJ2ZhbWlseV9zd2l0Y2hBY2NvdW50cycsIHBhcmFtczogW10gfSwgeyByZXRyeUNvdW50OiAwIH0pO1xuICAgICAgICByZXR1cm4gYWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gZ2V0QWRkcmVzcyhhZGRyZXNzKSk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9yZXZva2VQZXJtaXNzaW9ucycsXG4gICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGV0aF9hY2NvdW50czoge30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sIHsgcmV0cnlDb3VudDogMCB9KTtcbiAgICB9LFxufSk7XG5jb25zdCBjcmVhdGVGYW1pbHlBY2NvdW50c0NsaWVudCA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGF3YWl0IEZhbWlseUFjY291bnRzU2RrLnNlc3Npb24uZ2V0Q3VycmVudCgpO1xuICAgIGludmFyaWFudChjdXJyZW50U2Vzc2lvbi5zdGF0dXMgPT09IFNlc3Npb25TdGF0dXMuQVVUSEVOVElDQVRFRCwgJ0FjY291bnQgbXVzdCBiZSBjb25uZWN0ZWQgdG8gY3JlYXRlIGEgRmFtaWx5IEFjY291bnRzIGNsaWVudC4nKTtcbiAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVXYWxsZXRDbGllbnQoe1xuICAgICAgICBhY2NvdW50OiBjdXJyZW50U2Vzc2lvbi53YWxsZXQuYWRkcmVzcyxcbiAgICAgICAgdHJhbnNwb3J0OiBjdXN0b20obmV3IEV0aGVyZXVtUHJvdmlkZXIoKSksXG4gICAgfSlcbiAgICAgICAgLmV4dGVuZChwdWJsaWNBY3Rpb25zKVxuICAgICAgICAuZXh0ZW5kKGZhbWlseUFjY291bnRzQ3VzdG9tQWN0aW9ucyk7XG4gICAgcmV0dXJuIGNsaWVudDtcbn07XG5cbmNvbnN0IHZlcnNpb24kMSA9ICcyLjE2LjUnO1xuXG5jb25zdCBnZXRWZXJzaW9uID0gKCkgPT4gYEB3YWdtaS9jb3JlQCR7dmVyc2lvbiQxfWA7XG5cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQmFzZUVycm9yX2luc3RhbmNlcywgX0Jhc2VFcnJvcl93YWxrO1xuY2xhc3MgQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGdldCBkb2NzQmFzZVVybCgpIHtcbiAgICAgICAgcmV0dXJuICdodHRwczovL3dhZ21pLnNoL2NvcmUnO1xuICAgIH1cbiAgICBnZXQgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFZlcnNpb24oKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2hvcnRNZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgX0Jhc2VFcnJvcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXRhaWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NQYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFNZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG9ydE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1dhZ21pQ29yZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3JcbiAgICAgICAgICAgID8gb3B0aW9ucy5jYXVzZS5kZXRhaWxzXG4gICAgICAgICAgICA6IG9wdGlvbnMuY2F1c2U/Lm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuY2F1c2UubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5kZXRhaWxzO1xuICAgICAgICBjb25zdCBkb2NzUGF0aCA9IG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3JcbiAgICAgICAgICAgID8gb3B0aW9ucy5jYXVzZS5kb2NzUGF0aCB8fCBvcHRpb25zLmRvY3NQYXRoXG4gICAgICAgICAgICA6IG9wdGlvbnMuZG9jc1BhdGg7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IFtcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQuJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubWV0YU1lc3NhZ2VzID8gWy4uLm9wdGlvbnMubWV0YU1lc3NhZ2VzLCAnJ10gOiBbXSksXG4gICAgICAgICAgICAuLi4oZG9jc1BhdGhcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgYERvY3M6ICR7dGhpcy5kb2NzQmFzZVVybH0ke2RvY3NQYXRofS5odG1sJHtvcHRpb25zLmRvY3NTbHVnID8gYCMke29wdGlvbnMuZG9jc1NsdWd9YCA6ICcnfWAsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgLi4uKGRldGFpbHMgPyBbYERldGFpbHM6ICR7ZGV0YWlsc31gXSA6IFtdKSxcbiAgICAgICAgICAgIGBWZXJzaW9uOiAke3RoaXMudmVyc2lvbn1gLFxuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSlcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zLmNhdXNlO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg7XG4gICAgICAgIHRoaXMubWV0YU1lc3NhZ2VzID0gb3B0aW9ucy5tZXRhTWVzc2FnZXM7XG4gICAgICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICAgIH1cbiAgICB3YWxrKGZuKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlRXJyb3JfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VFcnJvcl93YWxrKS5jYWxsKHRoaXMsIHRoaXMsIGZuKTtcbiAgICB9XG59XG5fQmFzZUVycm9yX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9CYXNlRXJyb3Jfd2FsayA9IGZ1bmN0aW9uIF9CYXNlRXJyb3Jfd2FsayhlcnIsIGZuKSB7XG4gICAgaWYgKGZuPy4oZXJyKSlcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICBpZiAoZXJyLmNhdXNlKVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZUVycm9yX2luc3RhbmNlcywgXCJtXCIsIF9CYXNlRXJyb3Jfd2FsaykuY2FsbCh0aGlzLCBlcnIuY2F1c2UsIGZuKTtcbiAgICByZXR1cm4gZXJyO1xufTtcblxuY2xhc3MgQ2hhaW5Ob3RDb25maWd1cmVkRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQ2hhaW4gbm90IGNvbmZpZ3VyZWQuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDaGFpbk5vdENvbmZpZ3VyZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBQcm92aWRlck5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignUHJvdmlkZXIgbm90IGZvdW5kLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHJvdmlkZXJOb3RGb3VuZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3RvcihjcmVhdGVDb25uZWN0b3JGbikge1xuICAgIHJldHVybiBjcmVhdGVDb25uZWN0b3JGbjtcbn1cblxuaW5qZWN0ZWQudHlwZSA9ICdpbmplY3RlZCc7XG5mdW5jdGlvbiBpbmplY3RlZChwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBjb25zdCB7IHNoaW1EaXNjb25uZWN0ID0gdHJ1ZSwgdW5zdGFibGVfc2hpbUFzeW5jSW5qZWN0IH0gPSBwYXJhbWV0ZXJzO1xuICAgIGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcGFyYW1ldGVycy50YXJnZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLih0YXJnZXRNYXBbdGFyZ2V0XSA/PyB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke3RhcmdldFswXS50b1VwcGVyQ2FzZSgpfSR7dGFyZ2V0LnNsaWNlKDEpfWAsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBgaXMke3RhcmdldFswXS50b1VwcGVyQ2FzZSgpfSR7dGFyZ2V0LnNsaWNlKDEpfWAsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6ICdpbmplY3RlZCcsXG4gICAgICAgICAgICBuYW1lOiAnSW5qZWN0ZWQnLFxuICAgICAgICAgICAgcHJvdmlkZXIod2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdz8uZXRoZXJldW07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgYWNjb3VudHNDaGFuZ2VkO1xuICAgIGxldCBjaGFpbkNoYW5nZWQ7XG4gICAgbGV0IGNvbm5lY3Q7XG4gICAgbGV0IGRpc2Nvbm5lY3Q7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbm5lY3RvcigoY29uZmlnKSA9PiAoe1xuICAgICAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUYXJnZXQoKS5pY29uO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGFyZ2V0KCkuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBuYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRhcmdldCgpLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBnZXQgc3VwcG9ydHNTaW11bGF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IGluamVjdGVkLnR5cGUsXG4gICAgICAgIGFzeW5jIHNldHVwKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHN0YXJ0IGxpc3RlbmluZyBmb3IgZXZlbnRzIGlmIGB0YXJnZXRgIGlzIHNldCwgb3RoZXJ3aXNlIGBpbmplY3RlZCgpYCB3aWxsIGFsc28gcmVjZWl2ZSBldmVudHNcbiAgICAgICAgICAgIGlmIChwcm92aWRlcj8ub24gJiYgcGFyYW1ldGVycy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdCA9IHRoaXMub25Db25uZWN0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZG4ndCBuZWVkIHRvIGxpc3RlbiBmb3IgYCdhY2NvdW50c0NoYW5nZWQnYCBoZXJlIHNpbmNlIHRoZSBgJ2Nvbm5lY3QnYCBldmVudCBzaG91bGQgc3VmZmljZSAoYW5kIHdhbGxldCBzaG91bGRuJ3QgYmUgY29ubmVjdGVkIHlldCkuXG4gICAgICAgICAgICAgICAgLy8gU29tZSB3YWxsZXRzLCBsaWtlIE1ldGFNYXNrLCBkbyBub3QgaW1wbGVtZW50IHRoZSBgJ2Nvbm5lY3QnYCBldmVudCBhbmQgb3ZlcmxvYWQgYCdhY2NvdW50c0NoYW5nZWQnYCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHRoaXMub25BY2NvdW50c0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2FjY291bnRzQ2hhbmdlZCcsIGFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBjb25uZWN0KHsgY2hhaW5JZCwgaXNSZWNvbm5lY3RpbmcgfSA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyTm90Rm91bmRFcnJvcigpO1xuICAgICAgICAgICAgbGV0IGFjY291bnRzID0gW107XG4gICAgICAgICAgICBpZiAoaXNSZWNvbm5lY3RpbmcpXG4gICAgICAgICAgICAgICAgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzKCkuY2F0Y2goKCkgPT4gW10pO1xuICAgICAgICAgICAgZWxzZSBpZiAoc2hpbURpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHNob3cgYW5vdGhlciBwcm9tcHQgZm9yIHNlbGVjdGluZyBhY2NvdW50IGlmIGBzaGltRGlzY29ubmVjdGAgZmxhZyBpcyBlbmFibGVkXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBldGhfYWNjb3VudHM6IHt9IH1dLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHMgPSBwZXJtaXNzaW9uc1swXT8uY2F2ZWF0cz8uWzBdPy52YWx1ZT8ubWFwKCh4KSA9PiBnZXRBZGRyZXNzKHgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYCd3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zJ2AgY2FuIHJldHVybiBhIGRpZmZlcmVudCBvcmRlciBvZiBhY2NvdW50cyB0aGFuIGAnZXRoX2FjY291bnRzJ2BcbiAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIHRvIGAnZXRoX2FjY291bnRzJ2Agb3JkZXJpbmcgaWYgbW9yZSB0aGFuIG9uZSBhY2NvdW50IGlzIGNvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2V2bS93YWdtaS9pc3N1ZXMvNDE0MFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkQWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50cyA9IHNvcnRlZEFjY291bnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhbGwgaW5qZWN0ZWQgcHJvdmlkZXJzIHN1cHBvcnQgYHdhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnNgIChlLmcuIE1ldGFNYXNrIGlPUykuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYnViYmxlIHVwIGVycm9yIGlmIHVzZXIgcmVqZWN0cyByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBPciBwcm9tcHQgaXMgYWxyZWFkeSBvcGVuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBSZXNvdXJjZVVuYXZhaWxhYmxlUnBjRXJyb3IuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50cz8ubGVuZ3RoICYmICFpc1JlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRBY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50cyA9IHJlcXVlc3RlZEFjY291bnRzLm1hcCgoeCkgPT4gZ2V0QWRkcmVzcyh4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1hbmFnZSBFSVAtMTE5MyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTMjZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCBjb25uZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNDaGFuZ2VkID0gdGhpcy5vbkFjY291bnRzQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignYWNjb3VudHNDaGFuZ2VkJywgYWNjb3VudHNDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5DaGFuZ2VkID0gdGhpcy5vbkNoYWluQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignZGlzY29ubmVjdCcsIGRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTd2l0Y2ggdG8gY2hhaW4gaWYgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudENoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCAmJiBjdXJyZW50Q2hhaW5JZCAhPT0gY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFpbiA9IGF3YWl0IHRoaXMuc3dpdGNoQ2hhaW4oeyBjaGFpbklkIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvci5jb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IGN1cnJlbnRDaGFpbklkIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhaW5JZCA9IGNoYWluPy5pZCA/PyBjdXJyZW50Q2hhaW5JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGRpc2Nvbm5lY3RlZCBzaGltIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChzaGltRGlzY29ubmVjdClcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29uZmlnLnN0b3JhZ2U/LnJlbW92ZUl0ZW0oYCR7dGhpcy5pZH0uZGlzY29ubmVjdGVkYCk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGNvbm5lY3RlZCBzaGltIGlmIG5vIHRhcmdldCBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtZXRlcnMudGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb25maWcuc3RvcmFnZT8uc2V0SXRlbSgnaW5qZWN0ZWQuY29ubmVjdGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgYWNjb3VudHMsIGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvci5jb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gUmVzb3VyY2VVbmF2YWlsYWJsZVJwY0Vycm9yLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXNvdXJjZVVuYXZhaWxhYmxlUnBjRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgICAgIC8vIE1hbmFnZSBFSVAtMTE5MyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBjaGFpbkNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QgPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHBlcmltZW50YWwgc3VwcG9ydCBmb3IgTWV0YU1hc2sgZGlzY29ubmVjdFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWltcHJvdmVtZW50LXByb3Bvc2Fscy9ibG9iL21haW4vTUlQcy9taXAtMi5tZFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdGltZW91dCBhcyBub3QgYWxsIHdhbGxldHMgc3VwcG9ydCB0aGlzIG1ldGhvZCBhbmQgY2FuIGhhbmdcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2V2bS93YWdtaS9pc3N1ZXMvNDA2NFxuICAgICAgICAgICAgICAgIGF3YWl0IHdpdGhUaW1lb3V0KCgpID0+IFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBleHBsaWNpdCB0eXBlIGZvciB2aWVtQDNcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYCd3YWxsZXRfcmV2b2tlUGVybWlzc2lvbnMnYCBhZGRlZCBpbiBgdmllbUAyLjEwLjNgXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9yZXZva2VQZXJtaXNzaW9ucycsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW3sgZXRoX2FjY291bnRzOiB7fSB9XSxcbiAgICAgICAgICAgICAgICB9KSwgeyB0aW1lb3V0OiAxMDAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7IH1cbiAgICAgICAgICAgIC8vIEFkZCBzaGltIHNpZ25hbGxpbmcgY29ubmVjdG9yIGlzIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgaWYgKHNoaW1EaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29uZmlnLnN0b3JhZ2U/LnNldEl0ZW0oYCR7dGhpcy5pZH0uZGlzY29ubmVjdGVkYCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmFtZXRlcnMudGFyZ2V0KVxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbmZpZy5zdG9yYWdlPy5yZW1vdmVJdGVtKCdpbmplY3RlZC5jb25uZWN0ZWQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyTm90Rm91bmRFcnJvcigpO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2FjY291bnRzJyB9KTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IGhleENoYWluSWQgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2NoYWluSWQnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihoZXhDaGFpbklkKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0UHJvdmlkZXIoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQucHJvdmlkZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB0YXJnZXQucHJvdmlkZXIod2luZG93KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQucHJvdmlkZXIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gZmluZFByb3ZpZGVyKHdpbmRvdywgdGFyZ2V0LnByb3ZpZGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IHRhcmdldC5wcm92aWRlcjtcbiAgICAgICAgICAgIC8vIFNvbWUgd2FsbGV0cyBkbyBub3QgY29uZm9ybSB0byBFSVAtMTE5MyAoZS5nLiBUcnVzdCBXYWxsZXQpXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2V2bS93YWdtaS9pc3N1ZXMvMzUyNiNpc3N1ZWNvbW1lbnQtMTkxMjY4MzAwMlxuICAgICAgICAgICAgaWYgKHByb3ZpZGVyICYmICFwcm92aWRlci5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB1c2luZyBgb2ZmYCBoYW5kbGVyIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIG5vb3BcbiAgICAgICAgICAgICAgICBpZiAoJ29mZicgaW4gcHJvdmlkZXIgJiYgdHlwZW9mIHByb3ZpZGVyLm9mZiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub2ZmO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiB7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGlzQXV0aG9yaXplZCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEaXNjb25uZWN0ZWQgPSBzaGltRGlzY29ubmVjdCAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzaGltIGV4aXN0cyBpbiBzdG9yYWdlLCBjb25uZWN0b3IgaXMgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIChhd2FpdCBjb25maWcuc3RvcmFnZT8uZ2V0SXRlbShgJHt0aGlzLmlkfS5kaXNjb25uZWN0ZWRgKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGlzY29ubmVjdGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgaW5qZWN0ZWQgY29ubmVjdG9yIHRvIGNvbm5lY3QgaWYgbm8gdGFyZ2V0IGlzIHNldCBhbmQgaXQgaGFzbid0IGFscmVhZHkgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgLy8gKGUuZy4gZmxhZyBpbiBzdG9yYWdlIGlzIG5vdCBzZXQpLiBUaGlzIHByZXZlbnRzIGEgdGFyZ2V0bGVzcyBpbmplY3RlZCBjb25uZWN0b3IgZnJvbSBjb25uZWN0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSB3aGVuZXZlciB0aGVyZSBpcyBhIHRhcmdldGVkIGNvbm5lY3RvciBjb25maWd1cmVkLlxuICAgICAgICAgICAgICAgIGlmICghcGFyYW1ldGVycy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGVkID0gYXdhaXQgY29uZmlnLnN0b3JhZ2U/LmdldEl0ZW0oJ2luamVjdGVkLmNvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3RlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5zdGFibGVfc2hpbUFzeW5jSW5qZWN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NoaW1Bc3luY0luamVjdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIHByb3ZpZGVyIGlzIGZvdW5kLCBjaGVjayBmb3IgYXN5bmMgaW5qZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2V2bS9yZWZlcmVuY2VzL2lzc3Vlcy8xNjdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9kZXRlY3QtcHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUV0aGVyZXVtID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2V0aGVyZXVtI2luaXRpYWxpemVkJywgaGFuZGxlRXRoZXJldW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0eXBlb2YgdW5zdGFibGVfc2hpbUFzeW5jSW5qZWN0ID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdW5zdGFibGVfc2hpbUFzeW5jSW5qZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxXzAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdldGhlcmV1bSNpbml0aWFsaXplZCcsICgpID0+IHJlc29sdmUoaGFuZGxlRXRoZXJldW0oKSksIHsgb25jZTogdHJ1ZSB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShoYW5kbGVFdGhlcmV1bSgpKSwgdGltZW91dCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXNlIHJldHJ5IHN0cmF0ZWd5IGFzIHNvbWUgaW5qZWN0ZWQgd2FsbGV0cyAoZS5nLiBNZXRhTWFzaykgZmFpbCB0b1xuICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmUgSlNPTi1SUEMgcmVxdWVzdHMgb24gcGFnZSBsb2FkLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgd2l0aFJldHJ5KCgpID0+IHRoaXMuZ2V0QWNjb3VudHMoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhYWNjb3VudHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgc3dpdGNoQ2hhaW4oeyBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLCBjaGFpbklkIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUHJvdmlkZXJOb3RGb3VuZEVycm9yKCk7XG4gICAgICAgICAgICBjb25zdCBjaGFpbiA9IGNvbmZpZy5jaGFpbnMuZmluZCgoeCkgPT4geC5pZCA9PT0gY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIWNoYWluKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKG5ldyBDaGFpbk5vdENvbmZpZ3VyZWRFcnJvcigpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnY2hhaW5JZCcgaW4gZGF0YSAmJiBkYXRhLmNoYWluSWQgPT09IGNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLm9mZignY2hhbmdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIub24oJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IG51bWJlclRvSGV4KGNoYWluSWQpIH1dLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRHVyaW5nIGAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nYCwgTWV0YU1hc2sgbWFrZXMgYSBgJ25ldF92ZXJzaW9uJ2AgUlBDIGNhbGwgdG8gdGhlIHRhcmdldCBjaGFpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgcmVxdWVzdCBmYWlscywgTWV0YU1hc2sgZG9lcyBub3QgZW1pdCB0aGUgYCdjaGFpbkNoYW5nZWQnYCBldmVudCwgYnV0IHdpbGwgc3RpbGwgc3dpdGNoIHRoZSBjaGFpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGNvdW50ZXIgdGhpcyBiZWhhdmlvciwgd2UgcmVxdWVzdCBhbmQgZW1pdCB0aGUgY3VycmVudCBjaGFpbiBJRCB0byBjb25maXJtIHRoZSBjaGFpbiBzd2l0Y2ggZWl0aGVyIHZpYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjYWxsYmFjayBvciBhbiBleHRlcm5hbGx5IGVtaXR0ZWQgYCdjaGFpbkNoYW5nZWQnYCBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1leHRlbnNpb24vaXNzdWVzLzI0MjQ3XG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFpbklkID09PSBjaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHsgY2hhaW5JZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIC8vIEluZGljYXRlcyBjaGFpbiBpcyBub3QgYWRkZWQgdG8gcHJvdmlkZXJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gNDkwMiB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBVbndyYXBwaW5nIGZvciBNZXRhTWFzayBNb2JpbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLW1vYmlsZS9pc3N1ZXMvMjk0NCNpc3N1ZWNvbW1lbnQtOTc2OTg4NzE5XG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/LmRhdGE/Lm9yaWdpbmFsRXJyb3I/LmNvZGUgPT09IDQ5MDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVmYXVsdDogYmxvY2tFeHBsb3JlciwgLi4uYmxvY2tFeHBsb3JlcnMgfSA9IGNoYWluLmJsb2NrRXhwbG9yZXJzID8/IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrRXhwbG9yZXJVcmxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXI/LmJsb2NrRXhwbG9yZXJVcmxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzID0gYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlci5ibG9ja0V4cGxvcmVyVXJscztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrRXhwbG9yZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tFeHBsb3JlclVybHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXIudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5PYmplY3QudmFsdWVzKGJsb2NrRXhwbG9yZXJzKS5tYXAoKHgpID0+IHgudXJsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJwY1VybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8ucnBjVXJscz8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHMgPSBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLnJwY1VybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyA9IFtjaGFpbi5ycGNVcmxzLmRlZmF1bHQ/Lmh0dHBbMF0gPz8gJyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkRXRoZXJldW1DaGFpbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBudW1iZXJUb0hleChjaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbk5hbWU6IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXI/LmNoYWluTmFtZSA/PyBjaGFpbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25VcmxzOiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5pY29uVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8ubmF0aXZlQ3VycmVuY3kgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4ubmF0aXZlQ3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2FkZEV0aGVyZXVtQ2hhaW5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFpbklkID09PSBjaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgeyBjaGFpbklkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKG5ldyBFcnJvcignVXNlciByZWplY3RlZCBzd2l0Y2ggYWZ0ZXIgYWRkaW5nIG5ldHdvcmsuJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN3aXRjaENoYWluRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBvbkFjY291bnRzQ2hhbmdlZChhY2NvdW50cykge1xuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCBpZiB0aGVyZSBhcmUgbm8gYWNjb3VudHNcbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgaWYgZW1pdHRlciBpcyBsaXN0ZW5pbmcgZm9yIGNvbm5lY3QgZXZlbnQgKGUuZy4gaXMgZGlzY29ubmVjdGVkIGFuZCBjb25uZWN0cyB0aHJvdWdoIHdhbGxldCBpbnRlcmZhY2UpXG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuZW1pdHRlci5saXN0ZW5lckNvdW50KCdjb25uZWN0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gKGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0KHsgY2hhaW5JZCB9KTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZGlzY29ubmVjdGVkIHNoaW0gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHNoaW1EaXNjb25uZWN0KVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb25maWcuc3RvcmFnZT8ucmVtb3ZlSXRlbShgJHt0aGlzLmlkfS5kaXNjb25uZWN0ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHMubWFwKCh4KSA9PiBnZXRBZGRyZXNzKHgpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFpbkNoYW5nZWQoY2hhaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBOdW1iZXIoY2hhaW4pO1xuICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgeyBjaGFpbklkIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBvbkNvbm5lY3QoY29ubmVjdEluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gTnVtYmVyKGNvbm5lY3RJbmZvLmNoYWluSWQpO1xuICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY29ubmVjdCcsIHsgYWNjb3VudHMsIGNoYWluSWQgfSk7XG4gICAgICAgICAgICAvLyBNYW5hZ2UgRUlQLTExOTMgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHRoaXMub25BY2NvdW50c0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2FjY291bnRzQ2hhbmdlZCcsIGFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluQ2hhbmdlZCA9IHRoaXMub25DaGFpbkNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2NoYWluQ2hhbmdlZCcsIGNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG9uRGlzY29ubmVjdChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAvLyBJZiBNZXRhTWFzayBlbWl0cyBhIGBjb2RlOiAxMDEzYCBlcnJvciwgd2FpdCBmb3IgcmVjb25uZWN0aW9uIGJlZm9yZSBkaXNjb25uZWN0aW5nXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svcHJvdmlkZXJzL3B1bGwvMTIwXG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gMTAxMykge1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlciAmJiAhIShhd2FpdCB0aGlzLmdldEFjY291bnRzKCkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZW1vdmUgYCR7dGhpcy5pZH0uZGlzY29ubmVjdGVkYCBmcm9tIHN0b3JhZ2UgYmVjYXVzZSBgb25EaXNjb25uZWN0YCBpcyB0eXBpY2FsbHlcbiAgICAgICAgICAgIC8vIG9ubHkgY2FsbGVkIHdoZW4gdGhlIHdhbGxldCBpcyBkaXNjb25uZWN0ZWQgdGhyb3VnaCB0aGUgd2FsbGV0J3MgaW50ZXJmYWNlLCBtZWFuaW5nIHRoZSB3YWxsZXRcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGRpc2Nvbm5lY3RlZCBhbmQgd2UgZG9uJ3QgbmVlZCB0byBzaW11bGF0ZSBpdC5cbiAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgICAgIC8vIE1hbmFnZSBFSVAtMTE5MyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2NoYWluQ2hhbmdlZCcsIGNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QgPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY29ubmVjdCcsIGNvbm5lY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG5jb25zdCB0YXJnZXRNYXAgPSB7XG4gICAgY29pbmJhc2VXYWxsZXQ6IHtcbiAgICAgICAgaWQ6ICdjb2luYmFzZVdhbGxldCcsXG4gICAgICAgIG5hbWU6ICdDb2luYmFzZSBXYWxsZXQnLFxuICAgICAgICBwcm92aWRlcih3aW5kb3cpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3c/LmNvaW5iYXNlV2FsbGV0RXh0ZW5zaW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuY29pbmJhc2VXYWxsZXRFeHRlbnNpb247XG4gICAgICAgICAgICByZXR1cm4gZmluZFByb3ZpZGVyKHdpbmRvdywgJ2lzQ29pbmJhc2VXYWxsZXQnKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG1ldGFNYXNrOiB7XG4gICAgICAgIGlkOiAnbWV0YU1hc2snLFxuICAgICAgICBuYW1lOiAnTWV0YU1hc2snLFxuICAgICAgICBwcm92aWRlcih3aW5kb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kUHJvdmlkZXIod2luZG93LCAocHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3ZpZGVyLmlzTWV0YU1hc2spXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBCcmF2ZSB0cmllcyB0byBtYWtlIGl0c2VsZiBsb29rIGxpa2UgTWV0YU1hc2tcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBhbHNvIHRyeSBSUEMgYHdlYjNfY2xpZW50VmVyc2lvbmAgaWYgZm9sbG93aW5nIGlzIHVucmVsaWFibGVcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIuaXNCcmF2ZVdhbGxldCAmJiAhcHJvdmlkZXIuX2V2ZW50cyAmJiAhcHJvdmlkZXIuX3N0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgd2FsbGV0cyB0aGF0IHRyeSB0byBsb29rIGxpa2UgTWV0YU1hc2tcbiAgICAgICAgICAgICAgICBjb25zdCBmbGFncyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2lzQXBleFdhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc0F2YWxhbmNoZScsXG4gICAgICAgICAgICAgICAgICAgICdpc0JpdEtlZXAnLFxuICAgICAgICAgICAgICAgICAgICAnaXNCbG9ja1dhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc0t1Q29pbldhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc01hdGhXYWxsZXQnLFxuICAgICAgICAgICAgICAgICAgICAnaXNPa3hXYWxsZXQnLFxuICAgICAgICAgICAgICAgICAgICAnaXNPS0V4V2FsbGV0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzT25lSW5jaElPU1dhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc09uZUluY2hBbmRyb2lkV2FsbGV0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzT3BlcmEnLFxuICAgICAgICAgICAgICAgICAgICAnaXNQaGFudG9tJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzUG9ydGFsJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzUmFiYnknLFxuICAgICAgICAgICAgICAgICAgICAnaXNUb2tlblBvY2tldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc1Rva2VuYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzVW5pc3dhcFdhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc1plcmlvbicsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZsYWcgb2YgZmxhZ3MpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlcltmbGFnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgcGhhbnRvbToge1xuICAgICAgICBpZDogJ3BoYW50b20nLFxuICAgICAgICBuYW1lOiAnUGhhbnRvbScsXG4gICAgICAgIHByb3ZpZGVyKHdpbmRvdykge1xuICAgICAgICAgICAgaWYgKHdpbmRvdz8ucGhhbnRvbT8uZXRoZXJldW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5waGFudG9tPy5ldGhlcmV1bTtcbiAgICAgICAgICAgIHJldHVybiBmaW5kUHJvdmlkZXIod2luZG93LCAnaXNQaGFudG9tJyk7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5mdW5jdGlvbiBmaW5kUHJvdmlkZXIod2luZG93LCBzZWxlY3QpIHtcbiAgICBmdW5jdGlvbiBpc1Byb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdChwcm92aWRlcik7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlcltzZWxlY3RdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZXRoZXJldW0gPSB3aW5kb3cuZXRoZXJldW07XG4gICAgaWYgKGV0aGVyZXVtPy5wcm92aWRlcnMpXG4gICAgICAgIHJldHVybiBldGhlcmV1bS5wcm92aWRlcnMuZmluZCgocHJvdmlkZXIpID0+IGlzUHJvdmlkZXIocHJvdmlkZXIpKTtcbiAgICBpZiAoZXRoZXJldW0gJiYgaXNQcm92aWRlcihldGhlcmV1bSkpXG4gICAgICAgIHJldHVybiBldGhlcmV1bTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5jb25zdCBMb2dvID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTFFBQUFDMENBWUFBQUE5elFZeUFBQUJRR2xEUTFCelVETkRBQUI0bkdOZ1lIeVFrNXhiektMQXdKQ2JWMUlVNU82a0VCRVpwY0QraUlHWlFZU0JrNEdQUVRZeHViakFOOWd0aEFFSWloUExpNU5MaW5JWVVNQzNhd3lNSVBxeWJrWmlYb3BjK3h6M3B2T3pENHJsV3lhc2N5MlZZOEFQdUZKU2k1T0I5QjhnVmtrdUtDcGhZR0FFdW9aQnFieWtBTVIyQWJKRmtqTVNVNERzQ0NCYnB3am9RQ0M3QlNTZURtSFBBTEdUSU93MUlIWlJTSkF6a0gwQXlGWklSMkluSWJGemMwcVRvVzRBdVo0bk5TODBHRWh6QUxFTVF6RkRBSU14Z3pNT05XeGdOYzVBYU1DZ0NBb3Y5SEFvVGpNMmd1amljV0pnWUwzMy8vOW5WUVlHOXNrTURIOG4vUC8vZStILy8vLzhHQmlZWnpFd0hCQkI2RysrejhCZ3V4L0VRb2g1QWZrYnpZSEJ0QlVocG1IQndDREl4Y0J3b3FJZ3NTZ1JMTVFNeEV4cG1Rd01uNVl6TVBCR01qQUlYd0RxaVFZQU9RWmNMc0VDbGI0QUFHbWZTVVJCVkhnQjFiMEoxRzNIVlI2NDk3bjMvOThvNlEwYW51YkJsdWRKZUFpVGJZd2QyZ0dDNlVBQ0JGWlk3Z1ZOQjNDYUpFQjNWaGJRaE5XOU90RFFrQVlTSU9rRUdoSkNHSnJFQkd6SmtyRXNUN0preTVKc3pYclNleHFmM3F3My92ODkxVFhzdld2dmZlcmNlLzhueWFicnZmUGZjK3JVcWRxMTY2dTlkKzA2cHdyUCsvQ0hBM0FJOFJRUm1xRnhieVJsaVZkcGNTUTlqajI3SUFTd2RBVkhWeGk3bDY1aGNaQW42TmxGZE9PY2U0dkNnQjVGYzVpWGRpTjFhYlNGUDEvMlByUm9VdGlZUi9PeTlDOVRyN0V3TlZjNHB3b2pUREZ4QzBDTUkybkg4aHdsaFg0RDVaT3ZXd3p5OWNIbFM4Rmx6aGZ3Wk5seUROMnBQbFNYd1QwVkF0ZDd5VEw4K1NEdUhPdkN6ektkeU9CdXRJZXVqNkhmcFRYdHU4RXczV0Q2TnBqbkFMbkZ1STFJUEI5R0swbjVaaUNNOUg0R3lUSmhMcUFYMUdIWk1vSks3MEV0cDB0SzRubGhMcUJmUUYwOENGbkFnUHJOOFNITXowTjFZbWpsdVlHd05LRG5TZVY1REVPbnR0SG5wWjdmS0JEeXVXSldVSG5LcVdMVXNneWFKNFdialQybkR2NTZUQ1dMNmdhdzB2a2xyQXYvdnBEMm1OY1dyVHBBSTAwK0g5RzBHNVhXVS8xZ3M4ZkJTQ00xZ01xL1kvZDlCekQzV2lxVXBTNHpRYWt5QmtEUTZrN0hRNXVaaTRDZ1FlcHBoSkU2NkRpdUM5UE01N2xjcHNVMWF1QTZVbDFRMVMzOTlvNm1GMXFYRkRxNU5ieUhxaTdRb0JtWjV3cDh3ZG4rM0c2bzZxaWZSVjB2UTNRdGJ4R3dQVWJUK1JTWGVFai9OaVV5cVF3UDVCYUlPdzhHbDk0SEF3VEtTMHZpWGtrMWZlamVydTAyazIranJOYjFnRTdkNEdBN1l3dEVZWUV0SHloTjBIV2g2L1E3QVFWNGJtaWRQd3pEYUYwMHJicGRHbkhRcUkrdmgyNkxvUGpOZFFDaTNYZUFsTDd6Y2FBNmc1UFlDREJxTXVwNzB4YWh2cEsyRGtNQUNtalZ2YzQ5MDRFRkFwTDA4ZEpnQUF4VlVYM09URUlsRmNZWWlnb29QaTlmWjBuUHRDajZmS1ByKzJNU0QrZlVBUnpOREJDSjB5QlI5WlQ2cWpLQzhqUkltY3hmdnVmNGI4NHBMWEJkc0cxYkc5NHBMU0wwMGkwdGFIcGRQNHJ2Nlhub09pdXQxYURTYUN5WUkzQVY3YU0yOUtBeWMxUXdOcVN5WjVnSGRFY003a2J5YUFYZm1PWWc1dmFGMk1yUXhDekZHRlozT2o5ZEg5OHhQYzI2M3QwWVFLQWRQQ0EwQ0h4bjFDRG8rWjR5c1NRdnJvdlRQamtrc0hDZG9MWUR0T3BDYVkzQUFaZ3ZZQmpBQkZTaFdkR2ZqczdWS2NlcHVnU2lTM2RLLzZ2dDgwSEhVblZmYWxBNGIyQ0hEUk9DRzF1RG1NODdkZDRDZ3k1SGlHMUkyT0I2dXdFQzlWaE9oeG9zeXRaclNTQWcyblU5ZFoyd1JUK01hQittWHdkdGQ3cEQ2cUpBM0VOdFFDT3hBWVoyZDZNK1kzdzJkUUVMOXJudFFYWFNBR09hTzJmK3pjQUNHWlZ3TVJKWjVRdFVMeEUrL092S0hBdlRGaE1zN2JaeDVYeU9WTlpnN2tBeFQwbmtUa21OVk5GdW5vUno2clpYS2k0eHh2UjJZaG9EbTVudEpSeHhyb0poQk1RdElIZSt2ajZlOG11QlRNd0tKZ0ZxZy9lVVYwLzhhTlduV1Jmbi9RQlYvZ0RVcmgydzBVbjlQWk12MDYzYXhFdGZYeGVobi9KaGdkTnpIUm9EUU0yZldpVTEySGIzT015VjBLM0tlREFiYWRVQThBUXNJRHFWUnFTMVZuZE9Pb0N1V0NCbUlhdmdkRTBNSS9EMkpDbDYxZUFpN1JTWVdWV08xUmRkcDlRTjdldlFBbms1dEp5UlVnZW1rblE2cmdNZnlvenlvTkhxZlREbzFQV0F0a1FXdWh0dHh2ZUI2bERxcFd0UXo3WEcwSFRxdzhmTkZGM21PV1UrNWVLY1JOWVNHNkFONnFrMndOSFpLV0pQa2dxUUhzdFNGWnhVcHZPSlpoVGxOYUhyeVFpZzgyOEF3QkZ6b0ZRME1ROHppRE9ZTVRHaEo2YWtocStnbmpHb1lXakQ4WUJFUUswR0ZicmpBWXlEMkFBaGQ2S1NGUU5aUUJDY09NRGFUajF3ZmFoamdqVTVwQjdVMkIxVWJjUHFmQ0RKdUM2cXpZeFdUUEdSM3hQVEJxbTlkRDFSNmdMQUhkTzJTU0RhVTZNSlgvdStDQTNYTVdkRVMwZWRrNlV6VXIxNG5ORHhzL1FyZm5QbEFOQlNubWtLQ3NOVFE2Z0drK3IxQTN1UjQ3eWtnZ3JtaWJyV2NSYlFMT0dHRXJFVnFrUlQ2amptMnF0RzUvTUpBWHdHd2FqQXB1bmhCMFFPREZyVHRFQ2QwM1ZXd21rKzFRcUVvYm5CRWpyVFhrRE9ramtCWVVJZ1NIR21reUlhU1Qvd0N1Q1FuazRFVFcyVEJPU0JTZWkxVWtNRGNKbEZrQkJQdTBtaG53QTZJM0JPMG5sTXM1NzRTcnlkb1J0N1FlMEEyVlJSWURiaktJVlJJNmtwdnBnY2FKV2pya0NuQzhXaDUwSTNya2hoZFQxUlFKNUFaYUlCTmpaVWRxT0hEdFN1YjJ4RUIrNVlUcFNRTTJBcFVrMFBhQTB3RUYzRHUvcUJCY0JFMVZuYm4xd1hBS3R4dU56ZzZxQ0JyVHRscDBGTzVabDBZTUhNZGVCZkRVb3RlU2UrZnR4aFZWb3YzVFdQUU5PdjI0YmJJWjMzU2FPVTgxbVU0aDFwbUJrZFBFQkU2cmc2eUxnSVFBYjFmdkFiUEYwVU41aFkwYjNHeEkrQVdZT1h3VHpSWUNZZ2xITjdUelBRZ0RvVU0wUVRVQ1VyU3pFbDRiQ2FHVE9vZGhvRFBFdnI5R3dvNWtwK3RzT0I3MVpMcFBwYjZEWU43K3FMeUJwSmFSd1lEcWlDcm91dWd4OEh4THF6Tko1QkJibnV0TVlUNGlVb0NZTmtCaFdUQ0pybW9CVTBoZWFKL09yMkJsVWJNaldBZ2R3dzlhQ0FXT29RVW51a01nalk4VmdIRUJNM2c1cXZDY0F6NnZ4c1pnMEVrQklPbXNmVzVPQ0VLcEdXMlBNa00vZndkRDUxZ0o0T0FBNzFHZlJtUzJvQWE5TU9KeHBJTWtPcGVKWml1ZkdLcVZGVU5XU21pUzJIS09iS2hKaXV4dzhBVU10bmVyRFM1VTJuT2g2Z2RNRDFZTDVoRlpZQ2hmcGJ4d0RhL3NjTUJMWW5SZjFDNmFDZGdGNTVDQWhNcG1XeDJ2Qm00QWQyTE1OQW5yVGExTFcvUmtWUXZ6MFNxRW1iekxEU095T0FJNEU0Q3lxbFRHWUFZdXN6OXRpRzd1aFgyOC9lZlFzTm9Gc0o3YVRWSWpORHdBa1YyQ3NVeHlDZXBnRUluOU16VThWSUk2bUJUWnh1ME1tNEx4WmdGazlISDloT0xveWRFVU5uR2VDSmpwQWxReG80enJCNkMvVHNsa2hvZExZbVdNMVI2MHFnUmpBZHNrcTVDdWl1WWtCMHBBWnpvUVZJcWlIVkFYUGRab0U3YXhCZzhBQXJhRkRUTDQxQVRWc3lMUk1QYUFKejRrK0hPSkRVUlpyNyt0aUtzSlpoTTdBbndUSWp6Wk4rMTRudnFkejE5QnNIamV0cHJCSDZpcTBrcldPOEVTNU9Vb3V6QXV0N01ReHM3OHFiYWdhQUlWN2hTUjIrRnd1RFNCSlBpVEhUenNhbGdxWTB1czczRlNnSzA3dkNRRzBPS3NJRGVRdXlUME0xZkM4MmNsRmpFd1oxYXBoUTh1OWozbXlLR0ZDcitnRkpCUmlSVnRWMEFpUGhKdFRvRFBUS0p3dnU1S0dSdXBCVXl4MFQyRVlPMVZTQ2FtdW1EamtEWlVxeGxBN1ZHMUFIdUVQdHFyMFlSaUtISW5TcWhxMGR0UTdXTStWTzQyRHRsQ3lsQ2Rnem9UK1FpZEZsNGRMRm1Hdy8welEzQnZxTlFNNjRpL0hyRE5xZ1hzckNPa2NSOUdBNHVQYzdGS2lINzNKUVp0cTNETkJRWFFyTUdzZ0d4SkhRQk9RVkQvUlNjSlZ3V0NVZ1dFRWpoQllHQmxIQjFiNWlqMFlxbSt3MXNUZUJ3SURrNGJBTjRBZFRuWk5xYkZNeWNMV1pOQVV3RWsxQVFMRE5UNVBOTDFQdFNIK29TUGJvelVnRHlZQXFKbGlQZnpVNDFza3NZY25Oa2xHbSs1MDlXUUZOTmpTb2VrRHh5a3dSbExTbTlLRkFsbDE4YklZQnRidVJOc2pqR0RWdWNRSWwvL1pkSGlDdWdSV1dlWnpVQjRsYzEyMk96TW5xajBlbFZWRUJIeFJkMVliR3hzd1NXbmVPUHJSa25qZ0p6UUJlU1FYRVhscmlDNGp6Z1dBR2kyeGY4VUJqVTZ6b2hhdXJjUG5telhEaHBrMndmVHJONlZKWWl3dzR1cllHejU0NUhZOHo4RlE4bmw5ZkozVlRHbWFkNkVsZ1RubFAyRk9BSUlDQlVBRUZhQUZRelEwdzlyNGUzSXJYZ3lWWUtFcDRjNko5MDJhNFlzc1cyQlhyY0lHaWZUMG1PYkoyRmc2ZVBRdlBwdVAwYVRnMTYzTWpCQ3FuRjdvN0drd0ZNZzBZTEtUYU1aQ0VaNSs4RlV3TVlneEJCbmlUR0RQcGFwMFN6L1BBa2JyNmFxUjlUK1QzWlludmtmWWRLNnV3UW9QenRTaE5qNnl2d2NISTcwT1Ivd2ZpNzFvb2NuS1NOVkRSbUtrbHNwdXVMelJuVjEySDFMNEkxUDBLM21LZXNab1FMUkF4d1FDZ3ZsMEl0bDQ5Q09LTklCTGhCTTV0SisyTGJiK3o5elVYU2NVZ0pSQkhCcXhnalZ0QnlFY0JlS3hzVndCZkdGbUJzRHN5N3kwN2RzRHJMamdmcnRpNjFmaWlqWG9CRzFMYy9wT240TGFEQitFTFI0L0NFeEhvRTZoMmJ4NmtzSW5DZzh2MHIzTUFnRHFab0R1dHNaczdIaEJTSjh5OUlzRE8xUlY0Mjg1ZDhNWkkrMVdSZG1qUVBoWWVPM2tTUG52NE1OeDk3RGc4ZC9aTUFXL3VPQjNaMG9YMkRCSmtTVmh0N3A1TUZ4WUcwb2FCdEFSV0xjSjF3Y0QrNEJBNzNBcDg5YTZkOE5hZE8rRzZiZHVrOHkwS3FheEhuajhCZHg0NURQY2VQdzZISThpWjcxbkRUQXFQT25MZkZld0VLTG9zWkR2NkxDSUJ0bWZYandDYlFkMHBIZ3BsSkptRGFUOUt0K01qSHdrOEt6YVEwTkFZQVBKdk5pY1NnSzFrTGtlWHBmQ0tpcXUyTkt1M0l0bGVGcG40emdzdmhPdTNiNGN0a3dtOGtIQjZOb3ZnT0pMQi9jQ0pFMWs2Qkc1MFVETnhvUTVva01TejdyemFlNkh0em9rQXVhUzdMb0wzN1pIMlY1KzNIYlpPTi93MW13bG5vclM2NjhoUitFd0U5NFBQUDAvbVJQV0FySWRnQmwzRjJ4R01YejZIVUEyUGpxVTBxQUYzS0dCL1ZhVDVhM2Z0amtEZUFkc2k3UUhPUFNTK2Z6N1NmbnVrL2VISWR4Nmo1TWtVb2owZGEzVG9jeDIzM3ZPOVhzeEdHVXVFNm4vbit2bzNGTE9wdkRNQ1dydGw2bURBU1dNQTY3MWc0SFlLelBFK1MrZ1Zrc2dyblFJMFZLWW1jK0p2WHJvSFhoR0JQTzA2ZURGRHFtZ0N4NTg4K1NROGR1cFVVVXVJYWtER0RBQUJNMXVLcUVBc1BtZzJMV2cwdENOS3RlKzk2a3A0UlFSRnQ2UkVXemFrQnJ2ditQUHdCL3YzWjlPazBBN2kxZUJKb2pxckNLSjFTdDFCTkEyYlVFRFNPTVRFRjBWVDR1OWNjVG04TVdyRFRTOHkzNU8zNGd0SGo4RUhuMzRxMHI1V1hIb2htWUFnSUU2L1p4dUExcUJPZ0Y0blFLK0hPbGpXTTZVTWFEWkQrQnAzM1h4ejBDYUhuaG1jNTJOT1lOYlNlVldCZDhWZHl3Q1E3TGwzWFhRUnZPZmlpN0prYUlXTlNvc3hTQ1ZiKzJQUEhZUS9mdklKa3NRbzd3TUU5YUFmUTB4QVRVSkFzVEVUczFMODExKzRHNzU1ejU1UmJmSmkwdjZKU1B0SERod2dXNVZuUm9zWlVqMDJRVFNPSnlLcmEzTHpyY1puM3gzNS9rMlhYQUk3VmxmZ3BhVDl5Tm5FOStjaTdjL0ttQ1daU3dMb0JGcXdZRDRiTzBNYU5NNzZYdExNd0lHYUI4VHBuUkVxUzc5NW1UdnVybHR1Q2FKdVF6QnZ2bFc3eTg3d01XalQrYW95TXpLUXM2blJ4UUZHQmZPVXBOdjJDSUlrSGI0cTJtc3ZCa09YWmZEbmpoeUIzM3AwYjJaYTFqN0tmZzVndlRuRmk2RW5XYkorandEdTRHOWRmam04ZGRjdStITFNmbWVrL1QvdDJ4OEhqek9sYVFxb3hkTVI5RHNpeWsvYkZ6QW5nZk05VjE0Qjc0eUEvbkxSbnZMODlLRkQ4QjhqN1d0aytxVUI0em93Z0lza3p1Y0I1SHlOSkhPNnorYUtNVCtDTXJOQzQ4TUhBMml3Z3o4RDZLNFRHOWhJWmdFekNMZzNzWDBOTk9xTUJlNk9xdTZIcnJzV0xvK2ovNDBHUFNnY1krQlk0TFRQeEZINVA3L3ZmbmcrQW1OS2twb2xzNlREQXVLSlBGc0FjWDQwTVg3azVTK0RpNklId09jYlhrS2FPU1RUNDFjZmVpaDZTTmJGRjZ4ZnVkUTBWRGRuQWNONVVZajg0MWRjRDVjcHZudmF6b1htc2NHdWo5c1hUYjUvOGVCRGNDSjF5QTV6UjB5UytHd0M5cXpQUUQ0RFVDVjFxQ0ErMjF2VFEzenhMVkRUMFhrd3l5Z1ozYnNXUUM0ZUJPdUxKanVUL2JKVFNzdjJjcElTMjZZVCtCOGpJT2FCT2N3NUFDenp3eExwZmRxTEl4ai95YXRlQ1RzakxlekRMck9Xb1V6NnhDTjF3TlVjVHhNKzhjR2RFY3dmZVBuTERaaVhwV0VqTk05TG05eC9QM2p0dGRGMm4rYUlSSHYySHZGdjVqL1ZnL2hmYlAwcC9OajFMNGRMSTk5YnRMMFFtbUhKdU9TKy9QRlh2aUs2QUtjWkMwbElWQ0ZadkRsbTRnb0F6TnQvK2dEQ0tHSVRzeW1ZMlZrNXg2SGJMb09ZWnY4UTBjeVVzU3VMejZlQjNwYUtQV3dhSC95eENJamREaEFBNHlCOG9XRXN6K1RUL3RGSXk3WW90YkovRm9xZlhBOWljeDFLMTRldFVkUDh3SFhYUmRwWFI4djVjdENkUWdMbEQwUlFieVZiTVFzTkhuaEQwcFFkVFY0VjAzRlRiS3ZVRWE5d2JrUmQxb3NkeHZKTXd1U0hJaCszUkg1bVVDY3pLSkRRd3pwL0lKTllJUmlCYXJDb3ZFd2NQRTZyVkc0azRCbENmbWxIdTREOFN5L3NoOHhxaTFUZjkxMTFWWFRVYjVIV0N2cUFMKytSUW1yZzc0cjJKS1QzQi9vK0QvaEVZa0R4ajJmQXhPTTdvcjEvNlpiTjBsaGZycU1mb2YyeXJWdmd1NisrS3I4VEFRUU1rV3BRL0wxcGxpSUI1VHV2dUNMV2RjdVhuZllXM1NsY1JYelBjUXFVNWxWV3NPL1BkQXA3blpQTWd4bHVDblY0cEcxSmdJR0VUcmYxSzVSNjJyY1FSVXpOUEUxK3hCN2VlOG5GMGMrNVN6TFZGUXdOVG11d3Z4Z2hqRnkvT1E3czNoY0hlT2tMaXpSYjFaRzBUdThjWUY4MHk3c3V2aGplU0lQWFZqNHZFb21qWVl6MjExNXdBWHhEcEMzUldLYW1pZmFZZ0dsL1QvUmtmRzMwajQvbDgxTFM3dlBYNTIrTGZIOVhwQ3RoSXd1VEFGa2F5M1E4Vk44L3Y1WmJEbWhhREMxd2R3TWdxMEZoemREMkVIbkhGcURPeWdIYkwyVWd0WHRsSllPQ3k5SWp6NkIrNVJ5c0dta0JleU1ORVVhZTRldTNSZmZieFhHS092RldYbS9NWG9FZUxraTA3N2xrOFB5NWdPRmNhQjRyajgrL01mcnZ6NC8yY1Q4ckhiQzhPbERBdkN2T3VMN3o0b3NHK1cyRTloZENjeXRlbjM5THBQM1MxVTNsRFVFeW5YaHNWaitXQVBOdWpGZ0lqRVhLSzN1bURDYVIzemRCYUFFN2hRNlVrUjdVbTFkUTMrTFN0azVTaGNtWCtMZWp5a3ZBNEFveE9NTlloZEdDWHFRNkFidG42UTNMSGJBZ1B2bkEzM2ZsNVRDTG8rOUFoZkR2dDBYYTAzc05QaDlZc3V4bDZGZzJiYXY4Uk51M1JBMlRydkkzbFVSM210ajQ1c3N1Z3kxcTV1L0ZvdU5jK1F6dS9MeUlpZjgybW5LSjF1eWZDRXJhT2lCclNaekdiNEl4SlpIMWRRRzJLbFFqWHE3cHF2WU8vVXBoOFFUd2I1SjJhYVluemY2OUtjNUUrUm9HT2cvK2dKR2dnTTAwZWZ0N21lQVp5OWV2anVyNytqamIxMGRRSjJDdlI0bDM3YmJ0TWY3OFFWcWZ6NWNyakpYL2hsMDc0Y3BvbDg0aXpjbDBTcjlYYjlzR04remVKV20va3JUUEsrLzFrZS9wbFlkRU03L2Z6QzlLQ1pDMVYwT2VWQklackVibklJTkNiVHZiTisrR3RyUUJOaEZVWnFTaTM3Q2Z3VHVpQXorNVl6SlRjUW5Ha2dUbVk5RGp2ZlNtWnpZNnVIUkY1dVBOMGFZN0c4R2NmYUtSOXErTzZwcG5FMzNhci9RQjd2eXJJNStUUGJxMlBzdDErTnA0M1FMeVY1cFdINTllai9qcjBhUkxVcnI0MFFPOUM4OHZNaEcyMEw3MXlWaE1RZU5VQnpPWnJ4TjcvRWd2b2wrMm9YTWhHVlRsbGNIMHJzQ2JkOVhCMURLQUExZVdHUng2SktyRTZNeVNkbStoTkNQbEprbTNQYXJCOUhMUWptamJYUnNsTmtDN2NiNVNvUVdRRkY1Tkx4WWwydE5rMXVzMDMrRXJTL3VBMzhFZXJ6di9mTmdaK1o2MFM1YlNZU2c4Qld1VVp3dVQ0T0k2ajNDOWlxanBIZnlrOFFOVzhadSs4azNTK1lab2FtenVKcGFaRHFDdHdkNG91QUZHdlIrQkVqTWpGcVZ0U1k4MEEvcmFIVHZoOU5wYU5qVzJPdnRULzRMTHc5L3pZVUVmVzVpMlZhNCtraTM5bWd0MlJOclg0VTI3ZDJmSnQwZzZBbXljNWpBdnJRWXF6T2xNemdtUWJPbXZpVFJuS2QwSFNheS9qQ2x2V2xsdmh1RFZ1KzFrekRkeVEvLzFsQ0dwQjIxdXBKNldpSHQ3R21FemZhcWl3Z0JvOTFoOVQzOHE1Y09vYVlKRGNvTktwNnZnNmJraGVqd1NVMThmN1UvL091WThVTXdEenlJd0xwTVdSdExvK0srNktKbE02L0NHU1BzaThKNHJ6Zms2V043WFQ5bkFTcUFsQXVlYjNIanJOQWFRZGVzSUVDWmJ1c1dZUkJ3dnJKZ2NQQmhFaHdoMXFXMW9MVW9MY1Bwc2JxUjNPYTdadXMyK29ybE1NT0lZcUtjT29nd2RmSFBnczJaelJFVnBpZDJpNllydDIrREthR3BjRmdjcVBpeGRoNjlRdUNoTy9Gd2FlWjdxNE1NTHBkMElIR1htZWROZzlIbjM2OFBMSXM4M1Q4cVNEY25sbUlNMWtzdXBMZ1JkTXUyaFEyd3NZOENKV25sbkZjQ2Z2REN4eFhaT2c1TXI0L1JzTnVmblNFVTVINnNsTWFzUHJteW93UGIwdHRLYUhzR25yWWVoZkx6Ny9hOThCV3lhVEpxUzhLOUs4T1NuOCtTaSsrSFh2VVpvMS9MbW5HaFhIYjhsQ0pmT003UXZqUTBjQzBnZmR0eDE5QmdOeElPUlhnMGNtM1A1cmhCcXZRZnZjbUFqZ3pDSDJyS0VWY2d1bUVzMmJSNmtOd00yZlE1Ty9YRmQrZ3JRZkE5aFlCZXI3SVJXYlVNYkFwd284V1lJaDB1M0RUK2QrcXNFWmc3ZWJFamg0cTFiQnZjM1Nyc3gvUkFBOFJ5ZWRYbG91OW5QTWJCUTI3TjVjNTYzS0ZJNnFEcW90d2lEYmV0eVVnblVwRTQ1QTZ1aXc4aUtsdnk1ZVBrc1AzK3dHNEJlVmV6elN5Z2VwSXFtbHRDMDB0cWw1eE5EaVFOcnkrTFFlUTdVRlhlS0FZZUdRVXU4WlZUcnVhU0ZCZW5INkZnRTJJVjBORHI5V040QlJtNHcvOUhhdWo1L0xaVWxQUW1xSFhGd3VONlhHYzhjSjVLdnBBNjY4anFQME9aQU5UbUNSd0M2SHFKQlhwYlZLZ1BSNGt0TVpzZk82TEliWTBhQUJwQmhoT2t1azdKaVpUdWQxQlhiV1RTcXBlcTBpSkJtWHhzTjU1SjJvK21YU1F0ejBocWdJY3lsS2JReUdiRnB3bGhHTUpCQnRVMmd6TmptbGE3eTZ3ZHhjSWpzcVhFZndRYXdjeG9qS3FSK0E0WDYwNlFxRHl4WWFQbFh5cHpYODgwelZmSGdUOTZOZEc1d3RSSmxsbVZvZ2tydzUvSXg3NGdFSWRkS0V5WFdRcWcyZHRCVjlPbVhDQnRJK3BLbDNVaG9EWnh4VVZxdlFrYmFzNFgzVm53clRRckpienlqbDluU25icVZTQzJCMXpTRVVacHJhVk85WnBnUllucldBdlZxT1FScXFNdFF5Y0l1RFRVd2htdmQrNDJRTkJmampHbHBITlRQZW9tc3lteEphL2xkd2dUeGZXSHMyV1VhdDVVTndOREVPSmZnZVl3TlhyUUdTMElEUTJPSkNtaTU0bW13NW15TlNELzVTM2JDRGt0aHZZNDNZODBXaGdZQWVtWlgxdVh3UkpqdEQvZ2dpU3JyeXRGVUpTOU50ZGIzZzN6c2ljcWZhalNvN0FnbldqYWtVVjlPT2lNbzZZM09qZ3RPS3lpRWFrbnVBN3JHc0RjZDZhcGNId1pBZGRvRTVqeTdMTXE5amR4OEJOdHB1WUZhd3FpQmZ3Rm1xNmVIOFdMenZmVHVEK01uZjR6YzF3V0JBaldHNEMvVWJ3aDlFRUI3a01pdk5rRUFMTEFsVTZ4ZklNZnJRMmZPd3J5Z3dXS2tNY1ZCc0NDRTBLRE5TeG1WTjVGZDc0VjJBK2o3VXZ3ODI1b0JobzF5Z29yWHRHT2JKdE4vVkw3NlB1Q3dlQjFRbFRzZ3RRSGt3UUNZQ3VwN01KcU1YekJicEtYMFNRQVlkR2F1YzNCcE1BeXpQcjYrSnQ5RnpxUk9kVUdnMXJzOUdac2hHSHd5bjZaakJHdStsQVdvU3dIRjdLakwyYWFJUUlYdVAzbENBR0VjOHVBcTU0SHJDbWF3czFhUTRGb1gxWDJmRFV0SWtaYnFJUzJkZzZzOHF2T0E3bG13d0pkckJhNjVhVnMwaktRZnBOVzlZU1J0ME0rNHpxbzdhUlBnVVBudGFXTkJwTnRNOTE4dEJFeG5WY1cwdEcraThlRHBNL215ZU14QzlwN05OTmJRZFNMWGlYMlkybG9IVnd0K1VSVE03Sjlzb1FDZ3Rrd0w4UEN4WXpaM2xyclFJQ0xZaXFQOGFVZ2M1ckNUS01GM1VYQUExTS9xY25GNHYyVnFvRXFMd2Rhbk5YdFZpWGI1amtrOEZ5OXBjVHl0cEZFQWIzb3VOUGhDT3k4Qkg0N3czQUhJRC9TRGExOTFhM0J0T21YOWdYMG5uaWRNbFE4VmVBQ1k0MUFKUjZqeFk5dTdwVHluTEw3TkdyeVpXRFJpUDczU1Z3cW9hd0xuUmJpQjR4QWVUVXRZRVRlMGxPVzZoRll0Vlk4SEowbTFKTmVTa3h2SjhYeVl0NkxCZ0VwSkhBTlVMZGwwb3dlYmRsQWVqdjlpaThoR1BTVXR6RWtIVm5KTDNScDVTUlpoUEVzeGw5eDkweGFoL1N4SERQZ1BEVUhVQ0VXREI3anIwR0dwT08vWFVzWnBZQ1MwZnJmSHJPK2RDNng3N3BoM09YU0Zta2NJNXVXVStoSlJhZVdUNnpQNDB0R2psV0JWY1pNNU15T29IdGk2VnM5WU9tcWNnRjNIYVNrTDR4SlNEL0pFVFRjYUVqWFF3ZFdsQmRSQnk0L0VMVXFMamZMY3VRR3pUOXZvT0lZVmFOdkl0RUdqT0FOMFYyeHdZTkh0eEdqMDVEeDgvSGdjZDUyQm1pdzRYTG1YMEVLYnhScllIWVF4VHF1S2dqM013dUVBcEpiTGlrUzNQUDFVVzJMNllsQUJFUnhqVytVU3N6MXQ2UEkyMmw5Sk5YMTAxSDk5Zk92Rkc3bm0zd0QyM1YyKzlzL2pnclJqZWNOSU9XUDB3a2plaXNkOEg0aVBxUGpYN0J6K05yV0ZGZ0F0a09ublRNQktpdzRmM0wrL3JCRk5wcTNCV0FCNStWK1JhUHZwWUdZbzFIYzVCcjB4aENhSVpjWDVZRmUrTEV0c2RmQ25qejFlMW12MkVnT2x6TG9DYUYvaitEZTRIdTRsZHgrY05BQ3draHBVZ3hJZ09LMk9sM3ZRQUFvNG9JemR3MGJhTVBJY05zN0RBcUF2UTRkTHE0T1BGMFZzVU5FR1M0QVJnT3MyQ2hiVXJVT2VEV0RHWVFrakgzdjZhVUNxZ0RZdFpncklqRGNXbkI2YlBneFhTNVRCb0FPM0toQ2h1dXJxQ3Y4RjFNK2NPZzIzUFBrVWZPdFZWN0tXZzNwU09hTWxNbWdtNHpEZU1GZUJlSFJnRm04ZWlBUFVYL3V2TjhJdGQ5OExqeno5YkhtSm5BWWRRSFVDZlc1WTBHS1ZDNzVPWDRHQWpnR0k2cGRHbDN5ZXROTFZsMXdFMy95V3I0TDMvL1Yzd0o2ZE81cWc1bXBoY0tCczFGVS9ZOXBVeGZQR1Izb3NrVTQvOHNTVDBZbHdITFp1MlNRVEk3TGhLTlR0TFZvZFJNNjUvVlQ4MU5PcTI0bDNuTElUTE9VOURsNTRHNG14ZWZQeXRJZktwSU0vMi84NHZQdXlTMkhUcExHNktEYTR4eUJ0aUFTSFUwRDlTOC9wZGsybmR6eXlGMzc4My80ZVBQek1nYkwxd3VvcTFZZkJxbGJzREI3QXdYU2E1Y0tMaFd6Y2VDcXNNU3p0VUYzbjg2NmsySC80S1B6R2gyK0dtKzY2QjM3bTcvNHRlTWRyWG1VcFp5azZCK2lERU5yeG5rWXZxejc0K09NWksya2ZGaUQ4eUM2eUFBTjd1WG82bE0wRE5rMEt4bTNINm9tRXRBVXdzaThhUlVxWHRkZ3JxdktuNXQwRWJqdndMSHppMldmaEd5KzlyUG91ZGFsOEdoWXpoLzJpeGROaW1TUnBDUGdwN2ROSGpzQlAvczUvZ01maTZIblRsczNRVFRyZ3I5ZUZLVUVEdXIzWTRjYkRRTVl0a1I0YjU4dUhnbVZVMXlnUzBLd0JSK0l4ejhMRjJaUzlCdy9Cei96N1A0WS8rTWtQd0lYbm4yY29DaU9kT1lUbHU2MlpBOUJnSnRvKzl0UlRjTWZCZzlDdFRxME5qVHd3ckd0NTZ5OWpxbWxqY2FmNVlUWU5raVpCTmhYUVZMSUF1U3hBeTR0dHMwckoyd3VUaEo1RVVQL1NQWGZERGJ0MjV3OVBUZDZxc0FBTmxkYVEwdUx2YklsclZhZjA4enQvZVZ0c3NDT3dHc0U4WFpsR1FFL2lEVmtDUjlud1FXeXhjblBjTHZ1ckdneVVGUzlrS3dvQU1Nc0FwTy8zMG5JTmEydXdMMHJyZi9XaG0rR24vdmI3aG5WV1BBZG95cU1CRFVHWkUxNGlhMXYrdWRPbjRkZnYvU0wwWGZyNmU1SzFlc0RpL08xSjg5ZTljSndMRDZxUUxRSk1WWnFrOEhTZWJQQXlKRUFGY0piVU5LdVRwVFA5VGlLQUp0TUpQQjVuRFgvdjRZZmdSMS96V2pPeTFwMEdXdEtBSlFIZE4rbUduWExBMlE5OTRWNllibHFCbGMyYkloMHJtUjdlVDRWSHpXSWZrcVFtV1EzYTFQci9RL0RiYWVRNEd2bkpGaFJwdTd3Y24rb2QyMndXQit5NWs1K0ZXKzk3ME9RblBHQUI0dTYxUW1na1lzbXNhV1A2L3Q5SDk4SVhvMnQzOCtiVjNEYnNjZ29heElSUDNvZXhWdGpabHA0VzBDYUgyQmxoVUVHWmZxU0s5aVNsZGE4cE5raVhpVnhKNzdoR1NmRHZIbndRcnR5MkhiN3RxcXNOb2dObjdtZ3pRbHFCR0hVaWNOSkFwVS9rN3o5eURGWTJyV2E3ZVpwV2Jzb1NnRjVMNUlLZGsxekFyZW1ETnNNY0tYTkRlSW5TQ2hGT2w1UGxYUG1GdEY1Y1IxSTdEZUxUTmxocFE2SjQvdmpob3pVckpZYjFOZy82UkdOQTMyZTYvZWRQM3UzNGwzRWcrQ3YzM0FNcnF5c3dqZU9ycE0yaEt3TEgrSjhEZXphd21ob0lSdWhVUGxqTW1sRmJxOEZFTW9lcXp2STBKWlF0RXBBa1hzWnpVaDFSVkNkQ3AybTlpUFV6OE0vdXZBTnUyTDBicnRpMlhUSkhwZEtRS2lHTVVpMXJPcitYenE0WGlQYUpIYXBMcGtaYVMzbGF6QTFXVTl6cmk3TStpQVRRcWt5WDVYbkRIYWYxdmdOQW00ZTFPa1BJNm1MUXA5V0ZqS0JkNmh3cW9IbDVOcXpHZEg1Yzl1N3VpamFkUkZDdHI4OHNtTUdhRnl3NHZBYlZORE50ZWhaVkRnWG1KNTQvQVQvNTZVK1J3RXVBbmtSYUpsbWp5TjdsQU9LQTZEMHRNQVIwSzI0S0RaN2xjMnIwdWtzbm12cXdsT2JCR20rVmtCbVdpWTVYcXoyY09YTVd2dWZtbStEZnZ2TmRjUDM1RjlBbWtaWW82ZlRFaVdEZlFtMi8zTzJBekRTRDlQcGltK1hkbUVLZGdTcmJLQmQ3TFpVbGUzU0VZa2Jsdkx5TnBLU1NMbnMwWUNzTmJqeXRMOU5sZ1FFbE5RT25qSE93YkJRUGRRSHhrakRmaWJ3Sk5PWkI0MHZXUlFsUXdsalpOVnAyLzNYV0FTL1g5Y1NKay9DOU45MEVaMks2MWRpUlZuaHNrOXNJYUc5Ry9SNTBGVFM4RzVoOEZ1aTBnNlk1aGM3YzFJTWswbHU1UHRUVk9IUHZwemJyYUVRaWs2RS9uUmJUSTFYZ1dMVGIvdjdIYjRVSGp4NnBQVmNmanBPTkNhQUI0YjVDa205WjR6Y0RPbSt5UXd4anB1VjlzOVBDdVZpMkhTNGI4V0JOZy9XOHozc0ZkdVoralcvRmRZUDgybW54SE5JNk9tSWROSzI1TG5JZmNoM1QvYlE3YStuRU5XMVM4WGtnTnVtc0tlZmFRZUpZN2F0R0Q0NzVESDdwWEpUZ2djT0g0ZS9kOUpHOFdlZHFCSEk2a25UdUpwM2dTQmNaTkIzS3pOQ2YvOEVncm9ZcHFGR3dGMGIxUlIwVS9TTlRrWWhraHZCKzAwWENoZHo1eXpZRHNCSW9ud0RQbmowTjMzZkx6ZkJQYi9ncStKdFhYMlBWdWpORFJGcUhCb0NWYW10cFp0Mm94VC9PZS91aGJGekpFa0JMQWxNTytnN1RrSzdZa0tJNnJXSGtCdEtDcTVCUGp6cEx2YkJtYlQ5ZUxWYitrT1RndmJ0elczV2xBNEFycW1WZTZKY2NYYk9aS3FBN3YzSGZQdmk1ejM0V2pzZngxT1lvMkZianVDWko1ekpRNzRyZ2dlclZZSmR3MGZiMXF5aVJjb3hCM3drVmhxZk1TNmN4QUJyWHRRZFZZSFB2N2FVaUpiZml3cHZTdEc1QjV1bTFzL0N6ZDN3V25qNTVFcjdyNWRmRGVkR1cwaVpJQU1zNTQ4TldOS0JPcjg2Um1VRUhzSVFPeGN5b3p2c3VMMnlTcFRpWkYxckZOcVhQV01BTjNOdEkya2FjdmlRdVM0Zm1NYjBBSFJVL2dEczZ6UjFRUjJjVjdzSE1Kc2lnbzNzNnNKb2JZaS9INCtqWk0vRG5jZUxrZjcvanp1engya3hBVGhvN2dWa1BUR1d2Y3Vxc1VpN2pGMkFndFQxUE5HM05oV1lNMHdoWStWeWpQNVNsRE1vSXRQYWk2b0hBN1A3dHBoT1JHc2thT0xPMkRyOXk3OTN3eDQ4K0FqLytoaHZnWFhtZDQ4cWNBYWhZdUlWS1EzQTBHeW10R2hEWnJNaDdwUE8wS3Qzdk9xRzlOQ0M5UDBDQUNFMW1nSks2TUI0MGdXR0RhZWZscmRJaUVZTlFlYzAzaTJzVnFSTjM4dHlNVWljdTlMNk9WRGMyTFR5NFVTZERhMWJvTEQ3enpEUHdDNSs3RXg0NmRqU0NlS1ZJNXZnN21SYXZCc3JZcGp6QlpvTjBJcXoxR0pDM2lKZlFlSmREcDhmR1JWQ01xQjhubHRsRUZ2L2xIWSt5U0hYZWVXVlNWMmZuN2VHZU9uVUsvc0Z0SDRNM1gzZ1JmSGVVMXUrNExDMHlQakhkclNXQjVWcUJXRGMwcXl3ZzI3TXlpdmJIQm0xeXNKa1NpTzdDZ2FEejlDRHJHdmRBWGFPTGd6bHBmWnF4TUpKM0JYWDFiQlRod2E2MzRvUE9OalBVbVRoa2xVNlNta1ZnVUhRRUhRZnorMXBhVitOalR6NEJmL3J3dzNCcm5BVmNqVUpzUzVUS0NjanBTSklacDhXclVleDNFaUFkZTZDb0RFUVoyTElsVURSa1E4REFrSzBwTkQvQjRpL0JSYjJQcU1OU0tHV0phR2JlT0o4TTdPeklSN09CWjFwK2F5MzIyTHNPSDRRN1B2a3M3TnEwQ2I3bHFtdWl4TDRLcnQreEU3YndleUNLYWlFRmh4STdhTnBwOEFOWUpEWDdvWXNxcTErcjE2bFY4bE1qMnNwUitsYmR6ZSs4K0VWcEY4VkJsWXJsSEJXSmhTUHNuV0hQUXBYUUpSM1BGbVkzYStKYmo5VStjTlhybllUMmdRVkpBdkVqY1lMa3hzZjJ3czM3SDRmOTBTMlhnTHMxemdHc3hsODJNVmFTNjNTaXdVemc3SVk3K2xhYldaWG5HVEYyajhMaUhkZTcwcmloMlREVjd1R2VwQ2RvR0hDRm9SMWxSNXQycGozQms3ODZWbmF0VzROajYydndPdzk4Q1g3My9pL0JhM2J1aG45MHcxdmdEYnN2cWlOcnhVd1BiRlIwOFVpZVgvRUthTmNSb1crTDZRV3JvRG9HQ2tBc3MraUxIbEFkUnZjd0dBclBTaDg5cTB5S3VXa0JxaXhxZ1VwNUJXeWZJZHJKSHUwb0Y5R2dDTlZUUmF2MjlCMmFGMzE0UW9OcDRsOFdhdnBybms4KzlRVDg5cjMzd0wwSEQ4R1pmajBETjVzV1V3Wng4V1FrVHhlcXlaTXdVREdvT2lXb2hnekRTb1loTDh6a0JKMmJkem5jeUdJWWpMZWpsQ0lPZkNXcEFhcjNnUFBON3hiUVFqUnAwaU5KNlRXb1d5M3ZYdGtFYjkrekI5NTl4VlZ3K2JiellPdlU3a2V0Z2MyVk5VS1ZrWUVnSHBjaXNyQzZuR1FRUklOYXpaU2NCNnFCVWpEMTVpdjI4eklOb09KMWxOWVlBZXpOQUJiWXRtcnR2SnN0UWhKWDkyamRnVUhicDJ4ZVVIeWdqaCtnMHE1RGFFUnczRis3OURKNDQ0VVh3MzFSdTM3OHlTZmg5Z1BQd29FenAyRVRTZVRzbG92bnViM0pmVnFrY2pVbHRNWXg1eENrbmFCNXJocGQ0NVRPcDU1QnphQ1lZMFpsV2x3RXFDNDhvSmRsZ2dLTlBFNDdhbVV2Q01DcmR1MkN2eEh0NTdkR0JxMTIwL3JKVGJETU5MYWRpek5NUjZSQkJ3OUFGSGpwK1dLL3NlWUprbDBnYVZ3WXI5QTNLS1pWZUR2NVJ0TE9TMThsR0xpNkl6QzFKWnEwWnJydUN1RFp3aWdkUE5XOUxMblZYR2M1VlB6b2pxYWJQR21BcmRFMmZzdkZlK0N0bCt5QlkydG40SXVIRHNHSDl1K0hMeDQ3VXZhTHgvSUZrM1FpWlJvWi81N3Z3RnhSYit1S2hhQnhPT1JnYzFDSU1HU3AvLzV1VUpCSWFyQXRwVnBDcHBianZ3czNiNFlmdU81NitHdTdMOHIzK2MwcThJLzZpd2FJTFQxbDRvQkdTUVBudXdHRzBLdDhteG53Q0FvaG9LVTFVcWZSL2RrSUVoOEMybnVoTFJQcVBUUnBBWFU2MGczaXVBaWtQVmhTUzJ5RmVhZEp3V3JlWk41MGx0UmdBYXlCRGZxYWVNVXZxcDIvdWdtK2JzK2w4RFVSM0hjZU9nRC81b0VINGJrSWNwMjIzWG5STVFHYktWdXhIbXFjeHZpaDdSTW9YNEtqdEFDOUR4Q0txWUU0TEU1RzNpcWE3ZGZFc2JRbzMzZGZmUzE4eHhWWDUrMThqVVRXNTdYV1ZrVUgyN0hCVmFBMEVsS2prZk0rcUE3bFh0REd2TjFtTFN1SExwankwWEduSWRlcVVCa0p2dDA0TGM1SjY1V2dTY1BJNXRDMThpcXVWUVNlOFFWYVNDWVIwTmtKQ21KTjAvOGN3Q2h2WG8rUXZTa3lFSTBSYjR1YTlnMDdkOEVmUnovMEgrNTduRlpVcXNBTkhRZzJtblduZ3BET01WUlhLaWc4dHZpU3pvMGZ1aVdad1QzQVBieGNsMExRaTMrWFNhNVUvSE5lOUZ6ODVLdGZCVytKZzc2VWZCYkErRDM5d1NHNDMwRVJXcnFXalJYSkJZUmdqZXd1STBra01OaDY5STFNMnhnZGlvQTVXRzQrUGYrdUxkdldtN1VjS2hNQUJDWHljcjFrbzFxVlRvUFNYZ2JBSTRKRVlZbUFWdUxMdWl3d0NKdGpPMy9mdGRmQjFkdTN3YTgvOUNBY20vVzg0V1dkRVRiMkwvK3hxbzVCRFhwUUR2UDVKeVlIS29OYlo4VDNjQ1FickJsQVZZekNrL0loUUJ4YTc0bCt5Wjk3emV2ZzJxM2JxMnNvZ0pIUTVoZHFKdHpKVzBIVXBMUmJKMzVvc2FlTm5sZXR6VklKUUVrcjF6a1ZIY2E4R3IwSFRnOHVFTjFHMUN4b0xxNG82dCtndUY3S3FudjFvZERHZytMOFlsSlAycXRoamdYTkUxQVNXbDNMeTBoaEtHUjZkZkgyaXk2Qks3WnVnNStPSHBFRFo4L21XV1EyYzdSZzVOUDBzcFZ3UU44RGFKc2M0a1dpc1ErMDNIWmEyckxOeFNZR1FFT0txL2NKbEUwVW1OWHgyVXVpYi9KL2ZmVWI0T3F0V3dYTS9RaVk1VjNjTUdTMHgxTUxRMEgyMXNVOHdtYTNveDR0bzNKWEZjYjFvZ3ZaelJiQWxhRkI2d0U4TDh6cmpjMzB1REJ2M2RTSXhVbUhaRDRoTVVya1MxZmJNR3V0YkM5MHhRNUhyUHhYZ3NUNG9ZUGpmMldqbE1QUDhjSkRvTzZualV4Ly9nMXZoSDk0MStmaFVIVE41bzI5bGFtRXJZcWhoN0FkaDRqSllkeGM1Ym1wajVCZlkwSlk2WWFnZHBObFZRY3NqT29MODhucGVYNWszdi81dWpmbDdTcUNBN1BzNXFXWUtjd1ludGJyVU0rSG4yV2hTQ2RXYmFoc09OTWlITTh2T29vZ3gwV3k4cTlFUVA0ckFHQnhFMnJIRU1GZFV2TnNYSzV6TjcvbmlJOGVsSFJXOXlRZEhSMUxkL3BsTWk3ZHZBVitJWUw2QTUvL0hEeWZIT0ZzQ21xTEFFQndsYWxEbW5GVzVVdWJhUGV5RXI0cHpIMlhneE0ybDhCcVBVZUFCUUp6R2dEK1dKelczaFBCM0RzZ2E2a01ZTldiem04ZWNhSDF5N05SV2tKRHhiS1dMRWtxQjZ4QXlBNit2a3FBK1h5Qk51Skg5ZU5JL0VieUNQYXlhaHQxTTN0VndsREZTR1U2NGcwMEt5aHRFbHl4YUNWMTVrOFEyWkdEMk5SS2cvS0E4Y290VytHSHIzc1ovTUpERDJRVGxOL0hibFc5T0ZweFh2Vkg0NDNKWWZkVnJnL28zMkdvQXhFa1JDYnBuRFlSZXYrVlY4Rzc0cWgzUnZ5Vmp4NkRWVzBNNUVXZ2JvR01uNUZCRUJLUWxhUm0rclZHNFltWE9tYXN6bit2NGtZRExoR3ZpY1p6ek1QRm9ja2JRY3hCSlltTEFHcU1mWkJNRHV5YWJqdmRFVFM0ZlpQb1RrcGtpQ0ZoTm4yQzJqYmZGTjE2WHpwK0RQNzQ2YWZ5aEJyb0JRTzVoNWhDUU1admRXSXNHSGI0eWJIcFVqekdzWHZpRUNLaTZQT21XUmtFZnNzbGw4cmR3WWFOQVl5N2JPQTZXeko0N1BDQWtPM284b0VzeXpPYTlKRnJrUE5pYXdjWTJHVi9CVU1GTk8rSGJVM0E2Z2xSVHdoZ3FLUHp4NmxLVzBxMk1Kd1RHSVRnekJCcVE3SHVsUG1oeGVoL2Q4MjFjTXR6QitCdzN4ZmVzN1lJdW5iQm5jSGdldXplWUZzM1lSUzBUQXJiT3dZVlRQWnpQNHZNNk9FZnZleDYyQjBkN3Q3VUdBQWJ5a3lXSDFtYlF6RVBZSGh1QXpVVVNTRnRTL00xSDJWTmlJNGt1anM2ZCtqbng5SzM3cDF6V2x5Y2RrQS9BNlE4aTRabTd1ejEwelRXVUY0b2NPZ2Q3K2UxajFsMklLaHovUnVQN1pNVitKK3ZmeFgwZVFmWldSbHJrVm9XTTRxYVVWTldoM2ZZYW5INW5YcmpYSjRVU1ZXbnNldWcwS2s5SUxkSmt0RFJ2bmp6K1JmQVczZnN0QlVNYlhORHNoZ2lzeG1raC9ydXlULzgwZzM3cnJDdFU4b0ZXWGpLTEJITjVndE9OaCtvUGoza2F5MkxQQXRCTzI4M25GWTNabjE1QjNYN2dEU1Jla1l6UThreFBSV0tsUzhlc0FEdHBnaWpGOE4wck93a3d2SHp6WEhpNVRYYnQ4TTlKNTR2NzN1STZ3MHNyNXFtUWdBenNZSTR0S0ZSZVRjcWI5QmtJN09GUnRncjFSYkt5anpyc3htOE4vb2ZKelFMNkQ5UHA2U0dnV0J5YTdkL1VDVVgyNmt0MVFYRUxLMm9rWU1iclZSZ0Z5OEkyMktvTzNjajRBYk1rUmN6TGJiU3E5RStpcm5VMFc4Z3M0QzR4dW41ZldRMk84QUtGRDQzZy9VUkFIdVE2MVd1VW5IeU5ULzNYU2phT0VwUitQWkxMNGU3N3Y5aUVSU3FnNVZIRURTNlpmWXdPRE1EY1dDQzFJa1ZJY3k5NUljMVhvTTVBTWdnc0RDZ3orYkdaZEYyL29ZNEVCUXByQTV0Wm94SlozMXZETmo2WGt1U0FnTlVnNXBFbWJ6OHd4S00vTFBTNEF0dGFOVXhYdEtneTdGbDZyWmlRQWZWR1VWcnNxS2lObUtidVpveEV6Q1pxbldjQTZnNUFVMFd0aW5sVy80TGZjRUIxaW56Qk9xdjNyMGJMbHhaaFlOUkFPWVBRZVQ5R1g3anp0WTdTQUdxckVaYmRiQnNVR3E1VWt2Z1RxWUdTZWUzNzdvUXRxYVBJSVArTEIyTW0yNGVtRDB6bHIyV2pwRGFVK3hGcUlNT3VzWk8yZEhzMXRNTFJzdFg0MWp2ZGFwem1PZEhEblRuODlKajQ5clJobncrbGxiRm83cUhhdndRbExFczBobkIyTUVCcXViVGtoWDhOY0M0aGcxRHJjbjVhenhjc0xJQzN4eTlIck0wNXVwRE5ibkUxYUlMQzB1TGtNVXYrRU9WeG1pa2N3RFJESW5ZdEhsaU5QVC9tejE3YkNYQ0VNUXRaa0FqRG5XY0VxeW15dWdsaUd0b01UUFVyNXpTbTJxY3RuZHBQVEd0YzRDaHpEN1h0TzVhcDBWM0w1L3lDMG4wam9TaEhWVW01cnJVdFg3ZVZKT05mWlFNWVNnOFdqUzJRdThTNk9XWTMzSFJSZkJ2SHRzTE9PbExweDE4VjFkL2d6SUZ3NXp5N0taQnJpYmEzUERBQ3ZLYmF0dG5RRytOUkwzMnZBdnM1SWsyT1J4ajVrbG5WUlRSQjFWeitvUWFCQjNOR0tSR1MrOURkMG9KeWVDS1BrbUNNblVjbkEwSEc3QjlYZkh6UTloWTFyZ2dyL3JLWG5ucENybFJzSUtnWTNPRUhoRVRqTmZtOEhscVFhbWlGNUxpeUFvajBseVBuMTRkc1hKQjFPYkhJM1k2WmU0Rkpid0c1Yk5wT0JLbUpvRS94MFltNkNyTjNvMUkxRlZ4TmloSVBBelVtU2JPTXlIWXJFY0ZqQTRCR3BKZjFLbFN4WW9adVF6ajFjQXF5YnNSQ2IxSURQbTBzR1I2blhhWk1seER5L01kR21ia0FTOTFIbzM3OGt4WFBVSHM2WEJGRE1xY2QzK2NUUE1yT0xDa3d1dWlSK3kybzRkcEoxbDZFM0lzZUh6cVh3cGxZcVVsblJxMXJNQ3JpTTV4YVpuV0tINnYyTFJsa0ZheUNFTm1oSkZmZlc1NlBuZzZoczlsNnNoMmxLcW95cGVHeGtHdkwxNFAraHBQTlhUcEFHMDZUSnBhdlB5TXBaVnp0R1hrNXloaWtOYlJVWXVpaVNLUEE5YnJBOG1ndnQ2UkFTU296Z0FEYjlRWXFOSGRHaE02MnRvUmdVZVJhVXE4UDN3b0MwUjI0ZFZkcnRDcWFIRlY0cUJjdmg2OEQrMFREUnBHSWJNdUhsNGs5T1ZiTmtzbHVJQitSRHByNEM4YldrSnM4THdhRUxIWlVkSVJjOWpOaFVvYXNCcE9MM0tFS3FuSCtBS042MVpqNHB4clhQRDh2TFJ5SHFySmtadFlPWCtUMXlDOUtvcnlEVmE1RjdpbmQ1MEJPN2ZKQU13QW94TGNuN2ZhSndWMjQ1bUJKNTJud1dHZlBXUkJGdjBaOUdnWUNzY3h3U0ZiVWpDREVHcWVZOHhtS2MxTTZETXhQVnljM3FpakFvTm1EbGptaEVhK0xXQWpqRXZxVVFaaWZURkp2L09MeW42dUpnWS9VdGFIa0kvdkVJY0V0SzQ5c1FEajRtdFI1VGFTRmx4NitoQVk1WDRCaEpnYTdKcW1Sa1daZk9xYW9JUWw0bG9renJzWEdrY0s1MCtuV1JpbTkrWW5RWmZCNE1HQks5Q1U1ZXpwNXR0MjNyMlhnUlBxbDl3YXpHbjVsaXlobzRkamhRY1p5UGRjdmlQWFkyMFpZQWhrZno1NGhpVXpZbTA0aWcrNnAycDlUL0g1bzFwd2xRZG9pc3RpcDRaeDBacnk3bFJhaVZ3aTMwVnArVHJVMlYzVXFNbHgvTjVLQVFmUzhnMjUyc3lqRmhlNTdWcWRHUnB0UlR4c0M1ZWF4QytEd2FSTzB4cDdQVXZvT0V3UGs2cE5RR0VQc2ZxZEVjd1lRWWZoVjkrdWtVS3cwWEk3YU5XaFAzK2QzNnZEa0JlRDY2WUVwNXRqUUs1MUFDaWpmaUE3bWwxVW9ab2hRTktxcTJCbkNuTERJd2dVaG02SldnTTBYZ0pITmJxMHRlZkFJaDFsMC9LOUlSMHkxeW1EWFB2cUtQdHl6Rk9zb2JJbUF3R2pCbkdvaEdncnBrRnBPNEw2bXJrR2JXNm94NG9tRDdROGM1QWJnaUhVN1dNTEVZMGJLZ0YyajVWUUdoQ0RwZEIvNWxJV2xPbUZLSGFNbisySEt6eG9jSStCMmwrM3puWFA5aXJNbEpkbXZ6SVRPa0E5b1dEY2M3VGdqRWlOcnZDRnlLK0REdDBxV0hzVllLUGtGNUxXMTB5bjgyQXVjWG5oSGlHWU9oYVBBVkRseHk4cE0zbzZHblN4SjRpWXlMZjF1emF0eFdmOHVhZFVTZzQyWGc4SU5halg4OHRzQUx3OUNISU9pQTQ3d2ZHTXNCaHEyaFJHSmxhd2ltTk5wRHBuWWlzekFodzRjOFlrRUdLQ2FqTVZXc3h5VkxUdklhaUpoTXFrbkJldERUMXcyeW5KVkRKUWtoVHBwS1AzR05FRGlJanR0TjVFVzFFRVN4QjFwSktLSlhrRDJOeUtVbVpYeTBOVnZoYVg0cjdwMUhWUUMzQ29vcnJhWWJJWnhoTXJQREJjRkVZYjRkeUNsN1ZIenE0RGU4c0V6Z0ZrM1pRQ1pXdzhQY1JvQ25aUU9DOElLSVBLUzFhTHpvQks2NXVOVlVLREc3QXRod1pGYW13Rmx4aUg5Sm0yVjlQZGJDK2lYbzZLWFhVcGlReXFVaWJPNUZEcExTRUF5a2kyQklyYlR6Y1RRbE1rcUxTb09XSTZWV2pHaVZ5aXVwVGxGd0lZa3dQN0tzZ0oxSUhmaFI1cjlPQisvZm1pc0tETmRMR0h6cHhXdTF5UjEweFd1d3JWdFNodDI4aEVoZVpPc25yaW9kYW5mamRZcnRVOVN2K2xvMGRNVm5vZFp6SHRHcmdRNmEzdklRdzZwQ0VUeHFRM0R3UmJFbG1CQXQxNURwMjdibkZ0REFYWWlCbnJkU05wVGM5MlBkU25UelQyVG1Mbng2cjZLbnpIK2gyVXBNWDZialF6VWgxc0duQWVWWmlCVVZnR3FCcXdwREVsbXZ1akEzVTY5ajcvUE4xVTVRR0JHNW1rT3NBRnc2S2crRmZpcC9PYURzVEJiWG50NkNmTjJNR2pKMDdZZkNpaE1SUFZ2U3dWNlg2djJ4T0hOQVZkT0xUcHpVbFkrblRraStiR2s3ZnU2R2w5N1hzOWpvRVdZT0FDOGdUTWVkVGNIRXNyclliRER1NERXd3lvMEJCb1lSbGVTVDR6RjB6ZDlCcDNUU3FESlVlSzE2QkRtMmFzS3VaQWU1M0NIWWNPNWdVZERWaEh0TGpHb0tlUGFiU2JCaEdBc2ZHUURocmcrc3VIRTdOMXVPZklFWGoxQlR0RUN4dENBWXhUbkVFTi9wNzZOZTZlTUtURFMrcmdwSElZdkhsR1EvdE9aY3JKNmJ0Q1NVdTN0QXNMdGFvT3RhRVo1MmJHVDJoU2NXajdoQzVIcDlWbGk2WnI4QUQxTTRWQVplZ2tCdmJsRGJ3QU1rc0s0cWVISmhJTlB6MjRBZ3hORlZTMG9RSy9sM29vSk9iemV3NGZoc05uejhLbXJadUJOV3Q1ckJwZ0dpOEJ4Z01YMDF4OU5QL3dad2RZa3dmdS9SRGNyQ3Btb0tSbmJucnFDWGdOQVpySEtraU5JdG92RENuQkZzR2FjZk5xWTU1UkVsbXRjV2RFQkFEWjAxRHFnd2kyMytpUFp3MExKSTN2cWVLQ2Q1cUVTR3Ftblp0M0dENDdTS3NCQkxYcy9OdXBYc0NqY240M2xEdWxBbnJ2ZjBFSml3RFc1QWpneDJJVnpLRjJRdk1zQnpYcytDLzdIaU53ODZLYW5KWHFsTkp1bHFHaEQ0TTRsWDJscVY3WUlVMk5EaVk5cTNta3JaSC8wOTVINGVqYVdUMGU4MWdhL0RxYTdMMFc0K1lGNWVFUVd4b2EzK1B4ZC96Nis3M1dONFBkeURIMnphRC8xbS9lZDRNYnlYdHVXcXgxb0xvR1h5NjREeDhrZm40UUxVaEFiYkUvS05DS3BGWWRVb1Nia2kwbjE5ZmhwaWVmelB0S29waUhYdXNPRFl6QUJTcjZOSEM2ZVJYUkJYQ0dyREwxMWc5OEpGdG8vK21UY09zelQxV2hDQ1BBNWh1dVVGN3J3UmhHMEVnN1FpOXdCVmxLbzNyZk9mdWI2eWMvU0dEZ09KUTB1TEdqZXdGeEc4blRIVnkzdkdLUzFFWEZxMDZLZ2lpMG5YNmt6ZHVNQlN1ZGh3SlNOTEtBVnduUzNLMkloQTgvc1IvMm5uaWV0bW11cnlXSXBBNnMrUlhRQ1VEQmxhMURlMHNLSFlFQW93WWwxTStYTU85UFdEWWovOTJISDRMM1huWmxaaWc2TG9uUE9EZ0doaEVpbEpyVDl5V0pabTRBQStRVWlWMXRTTFovNi9kN1duem9Pby8zbmdGLzVvU1hLcTBPSWh6MHRXSmE4WWFnVkhYb0FScVJ1bUNCR3dLTWFrdFVKV296RThES0Z2NTRLRTF4LytsamU4dUdVb1FkbWZocWNNSllDc3I5MHZyY2E2bk42d2Nka2xXUFRDV2htQjJKeU5zUEhvQlBIM2cycnhmTTlyTklhRVVUekZGVm5oQ0RhV3lyUWpaL1JHTm9qc29CWU5VRTFNa0h3VGxhT2hTZnNjVXduNVpQZmRwUmhxcTByVitYMXVTbHovdldiV0krelJuSmpjNEMydkN6WXFaa3lkOGFOdXFpOTVmTWJGTTB5SnlXTzI1NzVobTQ3ZG1ub2R1OGlTUTB2YU5OaFJRUEZaZzZ0K1JhSzRqSllmZzFndkQ2Zm1vcHpYeDdsbXpvMU9PbVV3aVRLZnpFN1orRUUydHJ3M0VaRFBIVmJEZ1A3akdhZkx3VENid0NhVlpWdEY1RkdJQzhjWkFud0h6TFI2YkFlTnB1R04rNjV2Umo5eGFsYmVWdHhHQ05zNjhBS1BPTGhKQnJZQmgwUU5VdUdHeWN0QjMvaE5xK0hiVEpPbkRxSlB6czdaL0pHT21tSzFrQWFqcGFVbGVFazJubk5pUWtLMU5oZWdJOVVNQktTUlJnTTRQU2xyZlJjYkl5aFNkT240SmZ1ZmN1c1pzNkIySlUrVEFqaEllb0RvNFBsci9lUXRHVnI3T0JaRDhTRWJ4b0l4b1FkRWJ0b2JJLzY2OWR0RVhIRFkrV1BlN1RkeTlhV3ZZdTFXc0hYS3lUS0tDQXpmYW9CNG44amh5YWRZTTRIcjlpbFFVVGRhVHJQM3IwRWRoNzZnUjBhcjl2K1F3dUkwcG5WdkZsNVIyYWVqSm0wMS9qdHNNQmVPdUxTa0dpaSs3UzM0M2w0dktIbXBoNzNHUTJoWDVsRlg0djJ0SnZ1L0FTZU0vbFZ4cTF4aE5YS0JuVGoxSjE4MEpMNjBzK0lwbjFPdEdkNmtVTVpMQU1GQjJLaGdlZ3VGUG9iYVFkQkdLdzdmMEFUWm5pMDBKRnkyQVNwelpjSFhnUUhVR0xUUkR6QTVWTndPN1ZJRGJya05kR2NLaWJUUXNvVkhLUjZzQ1NtZjFJK3ZqUVk0L0JyMy94M2dqbTFiS3BVUFp3ZENKc1JLaEttU2lzcTZhcEl4cnJnQkxBZXprYURWU1hYMlVHUTJPbWlSaWRYWGVURE9yVUEwL0Y2Si80OUNmZzhSUEhXOXB3S0xGUjUyYVpHUm8zakpSR1ZRY3RJc1RlNlpSL3VoUHBYSmN0NktvWWFhbDRveis3a1lxOEdHbFYyWFBwb0xRVGRIWFJZcEswbGVkSHArSWF2T1NJbHNXSC9seTFINE41b29yZzg2ZFBQZzgvZGZ1bkl5WUNkS3ZUTWlDY1ZJOVQwQmtDbUVrZm5nNnBuOUxCYU9oY0hVWXVHRFJvYjZPS1ovRWZpVXhteDJRbDJrZnhPQnhtOEhkdS9BdDRNbFpJcXg3KzFXMEVYQiswakpNeWxRUVBZM1RxNFhTbmdRRTBjS1Y3V0hkcTRuaHhlYm1HeDVFREdnZHVJUDJ5YVhGZWVxUkJsSkVXWU5MWER0TTRXazN1ZUJvYWJPWjI2a0NLR3h4VCtuMzA2Qkg0cmc5L0NBNzE2eGtYazJRN0o5T1VKYlJrQ0NRd2Erc0hWUlkwNkJzMHY3czJOckxFTVpQU3VaOXc2UlFTc2RpaWlkQkpsTkNUMVVoOFZDOVBuVGtEMzNQVFg4QURSdzRiS2UzYndIVEF4WjFSNk9YUmVhR0hwVnBuMy92TjBTVmVKSmgweEc1d2pzNW5iUTFGMVlGUjI3cmRhRnBZS20zWFRBc0w2YkEwRHlkY2JCc0JTMjJhV0dIelFnUkdzS2FIUC9naHhwbHV2d21CaW44ZlBId0kzditSRytHSlU2Y3lGaWFycXhrYldVSnJEY1QwVWFNSHdocEFvME5oYlhzZk9oZ0JTVE5vQ1kxUXU0OUJvNWJTa2ZoTnF6RGR2QXFQeFFyOTNRanFHL2Z0TlNxSmUzaCtOTmp5dlN0SjNFanV2cjdXWUJZQTUzZzFLR0pwVEdxYnZSOUdiV3UxYkk1VzNGajZqYWJGSmRQNnZNbGtFb2FXWndJT1RaYjYraWpWM2ZGUkwvL0ZmR2Z2Um5EdG85c3RTMms2V0JOLy9Nbjk4TDBmL2d2WWYrWTBURFlYTEdUTm5TU3owQWExWFJBSHBzNEE3R0JwOEtFYmZiQ1JVUVVNcVFQNXBZOHRPeVdCYURmUnJHSlNyOXkwQ1o2YnJjUC84TEZiNE5lKzhIazRHOC9GQXdKT1VzT1FlU0tGZzEzRVJqTzZkTEJPSkZ6UW5jMUxiTHBuMXNERFpRNVlNbDFKaXh0SXUzeSs3V1BnbWxNZGVDaXBBUmFxUHhlVUFKVXN1TzIwa0VwdCt5OWpHLy9BelRmQ2tYNFdCZG9tbUNZTXJLNWtUR0F5TnpwbFAzdEJLUVY2YzhRUjNjQ285WElnZ25lQllhZ1AxQmRQeXVnN3U4TFZ0a2VCRTJXVEZZdGJoaEZIakY2UDVzYy92K3NPK0k4UDNnOC8rN2F2aGErNzdBcm9xR2RXVlVPZzFuV0RPWnBEaDg2dHk2SEI1Y0FNVUQ2OXlxM2dSczdOa1NuZmF4SENCQnBDVWYxZEltMnJrczIwZE4yUDAxRmVVSUs2dkZsSHo2ZTZ6cFFyYjBIQXhxL3hYaWdnSndSOGROOWo4SE9mK1ZSK0JXS3lHb0c4YVNVZW0vSjRhaUtlamZvV3BPU001YVc0WXNMV09RNVU5eXRHSEpDVk44aDg5UjBhRlpGekxETTVxS2ErcTFzbHFObnhPbUxOZzVLUVBCNmc3SzBDN01lam4vb0hQdnBoZU1lZXkrRjdybjgxM0hEUkh0Z2VHU0JWUkQyNnRjUU5BTkpxaGR6aG5CUmowS0JxWkU1am5zZDJucTN6VmhvczNKbExxVWVLeERlZVczcVRHMmpZQTFUdnZIbU15a2QzV3EwTmc5V0d1aDhQcWtUblo5Ylg0Uk5QUEE2L2YvK1g0UFk0QTdnZVRjNEU0bXh1a21ST0UyN0pBOFpDaGRzNTZHeFZHL0c3SnhuSGxENDBxbGVKSzJHNmtFZG9NeEd6UTE0dGhib1hBWVJxS3JENjYzamJzU2xvdGRySG5qbzd1d1kzUC8wazNCUjc5Y3ZQdXdEZWZlWFY4TzZyWGdZdjI3RUxOaVcxQk5ia2dBWG5PU2dwSEpSYWswRVFuMmRTT2p2QllFQXdZTU55R2tMUzE1ZHNGdlZBazNmQWRpTzAwdllxUWxxY3dNdkNJTlUxMldoWkN5VzdPUUJQSm1WdFpteTZlcXAvVFRYbzVNVFpzN0R2MkJINHlHT1B3STN4ZU9Ma2lUajdGOGRPRWJ3ckVjUmRkZ3FzRnFrY3ZScmkwVUQxM2pOcmZtVGd3aWl2UkVqQy9HQTNEWklUQlB2bWZia1oyTXh3YjNNSHJxbis0bGc1K3ZPQ2dkay9YUm82L2V1N0F2WStNbUVXengrT2JyMkg0c3ppYjMveGJyamh3b3ZoKzE5N0EzemQ1VmZEaGdNRHRrUFRnWGlXTURoSlhjMFNWVlZzczgzSExzSXFBaXh1QVoxV25jekxXK0xKWXJCOW9IelJYbjRMditzSDRnRzh2YzBkUVgrVnJVTm8wSGQzbE1MLzR2YmI0QXNIbm9YMURzc2tTUVR5bEZ5MXhXVTd6V0RPUUo2d1pHWnpJWUN4anpsZXR3Mm90bWt4WktTTmxscE9WMmNVNUJvSHRhOWZXMkMxYS9RWDBIbXdxT2hSN3FqTHo5c0UzM2pKNWZEZUs2K0JWKzY4RUZZaStvTXpNNHg2R3FXMVNtTGpWOWFtQnpPcVEvdWMvQ3lIUWh5TERITWVXRkxNNDBiU3BqOWlSNmFqcjVuMDJaQW1FelR4SmRTNkl3NjhIQUJLMElmQmNDQ0gxMTI4QjM3MXZlK0QrdzhkaUo2TWZmRG5VY01lbksxVklPZjNOSnlmR1N3UGVFMlFvZFN0TGJ3UmpjakI3TEV5L0F3QmJMeWNDM0tKb2tCYmxXQzluVnhDWmRNL010MEM4RmZYMkNPOWJ0ckQxMXh5S1h6YlpWZkNlL1pjQVNzUjdiTlFONXJ4MVZ3VWNwcE9nVmtEdWJNdkphRUd0M0NXNjluQlVEYjVFVVpvbk5NMXdzajkxajBZend0eGZscHQ2SExhUENEc2dQZTh5UnZrOXNTTHZEOGdWcDg4RFliRmRsYjI4d0RrUVZFWS95U1Q4SWFMTDRXM3hQYjd3SnZlREI5LzVpbjR3OGNmZ1R1UHhybUdTWG0vcEpQQkg0QTJOY29NWmVFNUdsU1hPa2c2YmlPOTFNUGdkUUFiUDF3NXFSVks5emJudkt3V3liWEtiL1RkT2tqYW5qaVZsT0UxMjg2RG4zajVxK0R0YVIvRHZnQlk5ak5VREIwRGR2QUhkeVFqa2J2cWp5WGFoKzQ4TXFNS3AzTnVwWXJvb0lnaU80TFVEZFRkU2xkSmc0b0RucTgxN3hlV2xtaEdlcmVHK1YyTkRSbno4RFlQZHJKbzZPVUlJNytvekJKam9zUmpKWnFUNzRuZXF2ZGVmZ1Y4L01BejhNc1AzUmZuSFU0VzVRQ1ZkMFFBUlRaKzBYMTZwWGdnbFBqbkpFbTVualp2Y2x3WWtZdmNUU0VNNUllY1pZRVhLcE1URS9KSzZEMzg0d2prYjQvZWpRdW1xNFBkWmYxT3M1bC9vVFlvVjAwa0NKRXB6QjY0NWtEWnlRVGdmRzFuMzBRaWtFRXEvVk1HRUlxWFV0ZFFDY0FLdElJZEZ6ZkNSc0taWnRzRzBpSm90TXVlTnlxUzZTaE5sanB6cUx6b2NDQWcrQndhVWhwSWU3S1hrL2RNNFNQdDlaMDJySC9McnQzd2gwOCtEcis1OXhFNGxSSk53Q2pDSVppNUhJYzN3M0FjeGpmQ1lMSEdFUWliM282TnBRM01qcDZ1UXhXQTlyQWoybFgvNUpXdmdXKzk1TEtzL1dZa2xjME9zNkhTTVNvdEduR21zb21VNWtRSlZJWXlkaldEVTJDN3VzNmxVNzdCY1VQOWVtbmlyd2NodUxTK1p2NjNrUllka3luZk1HaE4zVHRKQ3FJYUZGS3k0QSt3Z3FSWHhmQW5lRXl4Rk5NVlVHK041c2o3cjdvTzltemFBdjlibE5iSHM5ZGxvblNMcHhBQllCeWtMQnM4UjFwaDJrclFBbmdyczBEZ1ptbXVQNjBxcHdobGQ2d2VMcDZzd0srLy9rM3c2dTNuWnhORHdCeVV1YUhBTFlBT2xvNHgyaVNRZTY2K093d0NZdU9YNXR5UUdRcTJkVHFjd3hWWTR0NUcwdVB3WEZ3WDZsNG1yWkVXZ3BJbExLb3IrdXBpbGVYNVltM1VPcmJtWjNRSTZzU2JIVE9sSFdiQlB2TTNvbjM5cXZQUGd4KzkrL1B3UkhUenNXalg0R1RwaktyVERZVlVXNmdONklNNnRXQU9MNHNRWUtCdWE5cGFRL1NGSldhbXJTbzJiWWJmdWVHdEF6RHJvMitCMlJFY1dvZVc2TUdXYlNrRmh4dHFoY3pOQUdiUmxubFlOSnhaTnB4RDJtWDZDT0x3Um5OaXhqOWN6LzByQmdPdER3cDhkRi96bm84a21WdnRldTJXN2ZDcnI3OEJMa29MbXllMVRGUExsaHJ1a0ZXR0x6bzhqWHcwNXo0SHZKeGpzeURYMHF1U1VOYjczUnpqZi9OMWI0SXJOMitwWU83TDBmY3d2bVd5Vm4zUUFMV1RCbUp6RXlEbEt3WnNkRWlTeWhLdmVnTzZmOE9ZOFRzdlZkcDVzUnIvdWk5V0J3NHFhMHZseGdOazAyWURQTXQxNzNpdk4xUmRkeUJlZDhlMVc3ZkJiMGRQeUJhZ3RhQjk0d0VxcXlsc3JQK0RxakR3eXd6KzBJbEVQeUI0VlcybFlGQ01LVnRVaE5rTWZqN2F6RmR1M3BvQnZNNWdkcEk1Z3h2cU43Y2F5UFBVb2Q5bU9mMTIxRkE0UUxFbUhXR0FCdTZhR013bllLRE9GeDB2VmRyUjlHRHJ4U2M4YmV6cnpRZmZUcnp5d3FTNWxUVWRKcjZoYVZQN3JvWGF6dXVVSnYxZXRta3IvUFQxcjh3Q1RvTjZnRjB2UE5FUjNzS25HbVMyMzA2Wkk1SHRiSWRsV3JsVnRraE9ZUDVBSEJpOGUvZkZVakVCdFR2MHh1Y01ZZ0U0d0dBSFdpKzV0ZFM0ZHNzMktIWVlHckZsZVJIVU9KRWxGcGxNZ2E2Vm9NQ1JBeFpjNHdhZVBhZThwVitHS29GZDI5a3hNWFZhU3AwMzdIRzhOcDJsMFlGeWV5QWQ2bGx0Y21USkRPVllVM0hmRXYzVzM1OCt4NXVWY1ZYR0NsSGtsYndaM05vcTFZbzF3dUxYclJvWkZkd1NCVUViQk1WRVNsc2t2eXFxbWUrTWc0SmUrWmhiUFY4a1FHK3ZQV0tEK3BVU2RUNUUwanQyN0M0M212eW9jQWlpZFNpZXBqbnJFclgrMlFZckZsekRCcDQ5cDd4RnloSDlwVWU2cCtqSlVDVTlSMzFURkRZaVNQUUJWVWlZTm9ES2QvRHRGNnlFWnhEM3dRcXg3NG1Bdm5yVHBnem9JSk1NV0RNVVRKMWJhQVBhWjRnMVBraU4xRzhvUFNyUUlMQ0xoUDVJbk1LK2NMcXBBbG5aelRQRmpMNTNJRlVNYXpLVHkxTWRRWGVPSDd6MFNyZ3UydXQxN2VwR1BRandRWU1YQjRsZVlOaG9vNXhMSXlwYTFYc2RobHVvNDB1ZEUyK3UyYndadnZ2aXk5cmpHQTlzYUpzZWNnOGFaa2l2ekE1bGVsd1F2VjMvOE5xWHcydzJLNFBFWG0wd0RnQ0dEOUtyWU5nc0k2QmZPQ2hFV0NDbEdPQlUyejVLNTlkdDJ3N3YybldSVkpRcnBFMExQYjNONm83cGJPQlo5NTNCb1J0aTEyUVZmdmFLbDBjcHNCbGt5em5KUXpNckVCODk4QU1NbmJMbmNzQkxuRDZBYm55cFI0QkJYWUpPRTVsMDFlcG0rUEhMcnhXQk13c0x2RXR0N0VCb3RRbURudG8xNXc5cXZCU1ByOW14Qzc1Mng4NGlwVU4xT2RiQzY5emlNa0ZqZEtvanN6a1JRck5TT2dibGlUck55djdtWkR0L1o1dzRTU0toTmRob1RXOTdCbzJGSUtXV0lQdEdoK29EVFJMN1RWdlBoLy83NmxmQmZ6ajhMTngwNGhqc1d6OWIzdTdMczJNQlpFYkZ1UVhxWUJFV0U4SXNXQ2FFbHpBdEFBRTVXQVF5NEduL20wazhyb29BL3ByenQ4UDdkMTBLTytMa3gzb1lkNWtPTURaR1FnRHhHM0RRcnl1a2U2bU1WS1g4QmtjOFg4VUpmT3RGZStBVGh3L241ZU93bzB5NFF4SU9CK01CcVBjOEc2UVpyL3pjNTRLaGJpd2w5eVJtbEpJVTZSMk5aT2ozYSt0dzlYUUZmditOYjRXdDNWVFVURlk3b0x3WldpaXBvcGJxbEdnSFJmcXJDZlA1ZkdmdnlTQ3FZUnN2d28rd2dYbk9lVlR6MUNVY1ZzVjN4ckZ5V2hkaElXR05mSUxWWVB5ckpTVzNqMGpTb0R4TlVDWHVvdUI1cWorcDQrOExrK1JjNmNwTVh2bzkwNi9EKys3NEZEd1hadW83dzVSSlo4YzIybU1sNWdjT0M2ZlEzdFp0TkRpWkdoVHo4dmJJTTNqSHpqMndYZlgrQkdSalpzQmlNR3NLc0VXQ0FrMnZIa2cvSFZlcXI5TzFNZ3NlS3JDTmxGVjVvcU5CYnJ0eEN6U0pzN1FNZ21PdkFUblhxZEVUbW5rcEFzZUVRUXZRUmxzcVUzQVdiSHVNZ1ZuelJlS1VsRVpWSm45YmtMVW9TK29FOEZDbXg3LzlrajN3bTAvdWkyT3VYalo2S2pQUEFJT0d5VkVJaTRUZStQdlF3VkxjWW5RVkE4VTI2Nk81OGI3bzJXQm04SytSeVAxaU1BZFhERXRrUlk2cEw0TTZ2L21icEE1SloxWnp2RGEyZEhwZmdLT2hpWGRzbHk4TnFZR0g4NlZxY0hVejVQVDFIc0M4aEdDY0EyRzhPQkVpK2xjRzUxQi9OZmg5eHdPWTN5NmpwZ2ZXTnBBeEZZSDZYZEhMOGh2NzlrS1lUZ2tZdE9tbStXS0Jya0UzNG5pWS80SS9qa1ZhU0JiRHZvZnQwUjU2UlJ3UTlyMlZCTWJQT1hpNmhubU4wb3JMTDNzcVVBZVNDdG56Z1VwQ3NIUm12c0FTUVFNMk9FQ3J6aVFyYmJGQkQzUHExZWk0U0JmVkMxSHljdkpFVEsxQlh2UEFIQ3l2amFUVzV3QURJZVR6SEdzRHFRTzBFd1RWQmpLdkVFcjd2SHI3ZWRHV244RHg3TUlqVzdxUjIrQ3J0RG1GamdPNnFVNkQrUTJrUTlsZGw5N1pTQi9SZWpETHlEZlVBWU5tOUZ3MVBhY09qQ0V0TFZoalpRWXFVd09VeVRGV1BhazZnMWdCVGZaSFlXSW9FMlBDaFhIcGxzL1JwalAxNC95RGVwNDZDcGVwQWIzTUFCcGNlZ1lUMDlnU01xWmRYQjRMZzJva0xYRDBobEI2TW1ZU21mZW04M2JBeDQ0ZklRbmQxUmZlY2w0TmFRSXd0L0dXK3dTTE0vRmlSemhUQUgxMW5PSTJ6QXBnWnY5YURHTUE5ckE0R0ZDSDJuTlIxVCtGanU3cmRhbkI5ZkpXWEt0QWIzN2thSU1zcFdvVjZKbFdrYnpCZFFhbVA5ZzAwaWs0YmJEMU5ubm9PTEQ1bWlqWDBYcjFuTytBWEdlZDkxd2VVY0NSYTIyZW1iS284S3UzeERtRG80Y2dLQ2VEQlRBdVR3Um9RT3ZlWUl4VXpsU0xFQkNxMk56SS9zMHRXdzJUbVBrdHV3d0FCbEprbWRBQ3RjUlJSak1HT3NXWlg5ZGFac0RNMGI1UnFRRGhTSERFQktzcFdDb05hTytINE9PajE5S2JlYWVhUU9jOTRKZU9ZSTBVaHZ3Tjd0eDNuakFuMjZXRGFpQ05Jb01MckZKNjE4cHFlVlVpcUsyUld3MWw3QTR2bmFwRUdGMU9ONURJNDVmNXBYcmVmcVNNRXFndlhsMDlKNlpzbEhFZTFQbkhpeFd3RE5VaVRwc2R4bXNCTUJSUHJWL3VSRW9HMUF4VjUyVTU0QjdYaExFblJrd3huVDZVVG1Ca1N5dG9IalFhd0pNL3FGSVl6LzZjUU8yZTU4Ty9zWmVPNUJITEFwRUpvY0R2MlF1ZFdOOFMxUFNhNW9yM3BqaEN4WHl6eGM3dUJQSnlyS3JGLzdRMG1GdmJjd3dlaDl5Sm1kWkJJd1psWnpmdVdaMCtMS3cxOE5aYjFRMXdwS1RVb0R5djZNQ2FYS0lSZWpWSjBVS2o3akRPYmh1cHh2QmVXS3F2ekExT2x3OUlEYTVUOWFxdHBqeFJRZ2RyVStadlM0T0tGbXBnZExFTkhkd1R2U2FiRHVwZDJIaFVLaExtTS9sY3dxQ1hzbFNrYzk4cFErTVpuSlB2V0p3SFJsK0xGbTFnMHJQa1pvbXU4MUJTSGRUekhOY2FXN1NVU0l2b01ITE9FV084MzJpYmVERGpnblRtbWhIdTdvN2xzU2kwQVkzelNRbXRrL2ovYkQ5cnBCNDIwanloODRJRGMzVE9XS0lGaUVXTkVGUytCZ3lxNHdpWTZhYjNhZ3dHZlQ1L2NCMWpoTEN4RGpkaWNReWZVWFRBU0Y2TGdpNVBhejd2aXhZSmplMjgxNUs1WVhvNE05UzNucnNlYWJERkVwb05kRzFqdERnWHc0SDAzUmljZSs4NjF6QUE3Z2hLcmIxVkcwTHVLWnU0OXkwVzZqTm15YXJRYURETnJnYXRldENrK2FqQkY4YnFCakMwK1ZXbjRuR0JMcjhmbzJNRDhZdlNocEViV3BqbGExZVpvMnRyZHFLTG5zcWJIY0hHUTNzWkErL3QwSHQxTlZxTFh4eC8vT1R6MEF4Qm5oeVpjWHpob2Rud1BsNEIwV05pRUhEZVRSQVR5c2dTVlJpemJ6QXBBREF3TDRMdUZPcG1jT21YZVhuZGVncGdZT0p3WFBOWmVIRkRacmNYS21oWmUvRE1hU3RaK0k1dlVOU041KzZyVnphNlFZbFMxRWhtWThUSE5QY2RQOXJPUVVta3BZNndnYlRxV0RSUndBMHBDM1FqeUF0TFQ1MDhYZ1lieFBCT1YxdVpNTkxvd1hhVWZNK2xMOHNLUS8yTXlqRUdOVjB1Znc4dURWSUdDaDk3angyU0Y3RGtSU3grYm42emdhck9TeHNVYjVudUZQYWVQQUdBT0s2RmRNVmI5K1c2WkxyeEwxWUcrYUxzOWJIMzVFa3pBNnpiRmx6Y2drelBPWGhBRERwK1VHQ0FBb0RUNjJ2d1U3ZmVDQ2ZYemd5M3laaFR6a0NkQWhnL2F3WnlCK0lyNzdHQ216OWg4cDJFZ2EzcndMUWJJRVBwZEdjajdiOTIrNjJ3bGhhUXg5b1JEYWpuMEIvZ2hZUFo4RUxGR2JyZE0zeDk1K0dEd010TDRBdG9lSDZ5OHhIK25LKzFOTUpCNGdMcTA3TVozSFg0a0gzRERVMnlISVFCWWRpZ294S1cxVExNbDhJQUkrcTFJY0g0dVAvd0FiajM4TFB3MkxHakF6QmppM2JYUW9ZT0JPdlNoQllUN1hPZVpnUUhDRlFOUnVmOFd1WWpSdzdDM1FlZmhZY2pNTXhXSDFqcnIvbW5KN244MFcvd0NITU9VT1ZLQlIxZjd6MTZHSTZ0cjZzTm15d1Ayc2JEZk5CM3ZpY2JadnE4SksxeWNndDZ1N3dBNDBlZmZkcUNZUVRVZkM3MEJZQjVIVlI3REZvRWVrbXNKenM4T0JuWTZaM3B2QmZJVS92eUI1MDM3M3ZFYkpGaHdJMk9mdnJ0QjRVcmdsb2dwamd2ZmZWdlVIWFFyN3d5YlhvbnNkdWVlQXpPaEJuYy9QaERlYU9lQ2RvM0RYR01QR3lUdkd6QUJmbjVjdm5kZFcwcS9kbVRUK1M5NGRIWklzVkVScE1QanVYcjdyVS93Wkw4MGM2Q05iemNzbHNUcmZmOG41L2NGM3ZkMllwenNLQUdhREJ6cENjTkpLMENBMHVaUVhxMHowckhBUVVLdFJmUGVnVERCeDkvT0s5ci9KRW5IOC83Z3pEUXRRb1htOXJUeldWakkxNlZHM0QwMFZKMXRJMHREWW0xb2ZTbVBHbEc3RVEwa1c2Tm5URXRLUDZYVHoyZTY2SzN6aHQ4M0FERGpxOTV0ZEV3VDhOd2gyU2EwVjJmaXBMNW84OCtXUmJFejR2aUU0NG9CNkhUanlMVktUWm9xb1BDVVZHTzRGQmQrdzZER1F1WTAxY0hhVytOVHgwOElOS3RwZUkxUjdUUDFraGhQdFZwZ2dXdEp0bllzM1Q0dnFocFlnbWRBSEhvN0ptOG52RXpaMDdCYlUvdkw0RG9odW9iZEIxUXNVYWZhM3RhSGJwcVpuYlA1Y3YzMGNXTDF1Z0szUW5ROXh4NkZ2YWRlRDdUZnVETUdmam9FM3VsTTJwUUcyM3VDWVBhRG1HZVBlZU8wTWpEWHh2dEFsYnozZkxNay9CWUhCQVdDZDNST3RLVklTaE1ybHhvMnRqR0JPQkJvUVkxNnRaeEQrcGZVemhtd2hLZzAzWnV2LzNvZzFGYTlIYWY1ODR4MkJYanB6bUZJZWdPeFNnTmZLUThBRzBkZlpuYzBGTnErRDk0NUFIYVQzRWxSazdnRHg1OUFOSWFIUU82dTZHMEt3WFU4b05saTZtTG9kUGZWNTJpVTNYV0hVb0R1V3dlRytCUEV1MHJ0Tk5ZUFA3cjQ0L2srMU5WUDk0dlVIOFc1VnNRRzgyOVRQRG1wRDQwci9RbmN1bVlSV3o4MGVON0MxNm1FNmg3bGNNQW9DQnFEc0NxZTBjMG5YZUxLV1p5ZGJ6S0hNQks2VWpnWnc4ZmhrOGNlTmJhb3lvNzZibnBZVFdBTUpJTFFRWlk1Z0E3QU9NZ2o5SkpMcmRUUUFiMWZSdjlmalJLNTg5R0tWZjJBeW5BK1B5aDUrRG1hSHJrTkowRnRlZGZSeDBNR3V1ajY3RkJhNVVqYndKNGE4NXJFazM3U2p3KzlmU1Q4SmtEejVUT21HbWZ3TzN4K3JaWXA2a0N2djdXVXVNQkhRSXpMNVZkRTl5OXNDQ05WaVd5bFUybmdLek9iMzNtcVlpUmcyV1YvN1JWQ2R2UmhoRU9jOUJvN0VZWVdUbHAvQUVEY0FYc0JPWkoycmgrV25ZSi9jVXYzUTFIa2lydmhwSUdQWE1CbXBMTGQwZ3RmWDE2VkNkTVlsNkRFV0d3L1ZoaTdzblpHdnpTM1orajdjWm91OTYwb0dDOCtmTjMzWmsvNHZTMmFCTWNtcE91SW9NMDZLN3BPVzBuQzVoQmdScHEyUW1zYTVHMm43L3I5a3hySjdTWEhWcC84UXQzd3JHenB3WDhHdGlpcmJwR2gvTDhiUEVjaCswREZnYlZ2RkM4enI5UTZEZ1VhZnMvdnZTRnJBMFRYc3BxLzkzOFJtMFY3S0owTTdoYVVIQnEwcUpRSXFYR2JBZmxqZXNqcU84L2NReCs2Nkg3VFE5dDJYVmp6TkpCQzc4NW5YTklJc0xBSzhESDd6OThQK3c5Y1R5cnZkUUo4MEhuVDBWYitsL2ZkNCtSNWdMbURvWm1FTUFBckVZQzZtdkZ0azVkZXhPcGMrVnFjUDcyL1YrQ0o2TFBQMjlzU2tKa1F0dFI3NHQyNlovc2ZValMra04zUmkvMC9DQmNhMDArYjc0T3kzVUFNQjRXejdlMFBldnZQL0lRN0R0MXFtdzBsUFppNlNaMUUwN0IwNUJBbk5mb0t0VGxkRWU3SHhMRFZlYW9ESFN5ZmRqTFVUZXVYNFYvRjIzcHY0aGVEODlRTTJpQkJqaGdTQW82c3Z3OW4wZm5tVWtkS24xQy8yZjdIb1YvZGQrOXRPOTAyZWdtZGNRSmIwVVdqOSs0LzR2UkpOa3ZkcXN4UWJCaFJ2RTVxVnloRlJ0cDZEcm9mRUtWbnBwZmJHTHc3MGVlZUJ4KzY3NjdZYkpwaFd6bktlM1lPeTNhSnBvZy85ZTlkOEVISDN1a0xCdkF0bmRYWFhyaWVYRDBNRytEOHgwSGpYWjBmQWN3R2lYenZxdVNlYXFPRDBVcy9Pc29TREsvZWIvdlNmRndhS25HNjZPZ3hwMkF2QjJZbG82WFZBMzBMcXJZd3dER3JnbDhuVzNDQ25JR053OE1KeE15UFNMQlNTWCs3QmZ1Z1B1UEh4RXB6Y0FZbUNLS3VkMHlBRmRwV0dvYU5ZMXFNSVdsUWRQeDhMRWo4TTgrOTFrNG5lSUpFSk04bUozSUlDWEZweStSLzZmUGZCSWVPSEo0S09YQWFwclczdVZlZW9zVVZ1Y2l6ZFN6dml6bVZ3THpRMGVQd00vZGNYdmU0ekdiU1N0VG9yc2pUVk5BanZIM0Z5TGZ2eFR0MUNrOUsveW5RMHRRR1RBQzJNRWp0b0ZyVENOMThHQ1V0Y05LVnp2am84ZVB3azkvN2pNWkU0bkc2WVJveDQ0R2hZd25JQ0hKaktvNDlIalRlR1dDTy9DUjBrVnJKdEpyT0szcVJicjFxdnV1N3ZGOXBPL2g3My9xWS9EVXFlZU5sT1BLRDREdFFPMXR1R1ljT0hCcHFhU2tVd0x6ZjMvYlIrRjRuQTZackd5U0JVNDYya3N2ZzJKU3BGM2FBVFZ0cGZCREgvOG9QQmlmMHcwMTdXd2p6Z096c1N2QlNtTnRWbWc3bVE4R1F6cWVQUGs4L0Vpay9YQzBuN3U4c1dXTDlrbVcwTk40SEl0dCtJR1lmdi96eHd5d1dsNFE3UW5oSnMzWHdRSzhDL1krUDVlV0pCQzZRYlV2blQ4ZGFYLy9yVGZEbVNUd1dDdE9hVEJvR2xya3ArQlBSRmhMT2pmaThKcTc3N1ptcVRlU3NNVEpKekxLdURJZk52STZaYlFjMlByYU9xeWZQUXV6ZUt5ZE9nMDdJL0gvejllL0cxNTIzZ1YxRVJxMWFvOWZ4WEtNRkV0OVphNlc3aHBzek9qOTBWNys3bHMrQklmaXhFbmF0bmRLRzBWT2FDODlwRExTQW9KOUpHeDk3V3lrZnkzdlRiNW5kVFA4KzI5OEQxeTZiYnNzbkNPTDZHQ2xtZC9oMERTSEVkcVpuWm4rSU5VUkFFMmhTdEVuamgrRHYzZkxUWEFnMGxSb1g0MjBrNFJUdENmZXovcFpvWnRvdjJMVEZ2ajFyM3NYWEhYZStXWnBXMWxrSmtCek5hc2dSRHFXVjl3MUI5emFQRXVkS0FtRGYvREpLTkRpWkZ2ZXhEN1N6enZOZG5rVGUxNmlyUTVPTXNpZExjMlNlOEJNQitySmpoLys0ZjhGNWdYVUR6SHJ1RHgxRGF4ZWlTaUFhaHZGY0RMT0RQM1Jvdy9CVmR1MndTc3V1QURxckJBTVRRZ1lTbDR0dGIxZlUyemt6cnJsc3JxTngzK0pOdk1QZnZ3V2VEN0ZwZjJuYVEvcVRqWlQ3NnFHRVczVFNXSEhZcWY4azBjZWhpdTJiNE5YN3R4UjZXYWVkNjVEVWFXRVh1ZlpZZld1VFppSnBobHJQVDZ5ZngvOHlNZi9FZzVIYlpHQnZLbEl1TW1BZGlLRUFBNEVpdVJwK3FNNGxubFpCUFQxNTE5Z2xLcXg3eFZmRVlibms4NmFjVnJic2haYzBiOHgvcVpvNy8vRVoyK0RneXhFRXFCWHFxbVU3V2ZYdUlYdkFqQmlYclVVS3RCVUk4d0Y5TmlEZ3pnRWgyZVRSTnM2RFA2MUtFRnVqSldjeGQvRTNHM0ozdE5NaFNHNE5YTTdCUTU5M2VtQmxESXpqc1hHL0swSHZnaS9HQWRKWjdBVElCZEFUQ29nbEM5TFFOMFJFMm12dzFOUjY5eTBiMS8rb1BPYTg4NkQ4MFpvOSthUU5rVU1RQnFBbmxKOCtqMFpKZG92M2ZVNStPVjc3NGFUS1Q3U3ZiS3BSWHNuVEt1MEU3Q0ppTFVvZnYvOHNVZHoyMXg3L3Ztd1BkRU9saTVQb3hFZzZ0b003cUU5ZUgwKzh2MWYzdmVGeVBmUHc2bVlNRzlrVDZaUWNaRlcybVVEVUdJY2VoZVlzNlBuZ1RsSERVeU9GRWJlQUEraWsvb3ErdnZ5eFhmMTY5QkMxb0VXY0V6bXgvcGFORDNXcy9uQlpzalZtN2ZBVDd6K3ErQ2RleTZQRE9rRzY2NHhHVTFLY0FoK2JZT2VpUkxodG1lZmpnT2pPMkZ2dE4rSzV5S1pHS3Q1QWlLN3VicUpNRTczZmw3Wk1uOWFIOVgzYkQzUlQrYlRXcXJIR2x3ZWFmK1pONzhGdnY3U3kvS0F6SzhJWk5RMjJEcGdZOWFROXl6cWNoNDlmUHFaWitDZmZ2cVRjU3IrdEtPOXVPazZuaW9lb1QwUk1pUGFaNW4ydGN6elJQc3JvcVQrNGRlOEhyN2gwaXR6NldackVHaTc2d3k5Q21zVC9xWHpOQVA0bVFOUHd5L2Y4emw0NFBuajBSTkRBbVMxZW1UeS90OUtJeHBUZzhFZFFJSGNTV2VEZzNtQTFqZjc5ckl2WmhsVC9yRFIyTklBdktRQnI0QmQxcnhiejR5ZHJhMW5waVp3OUJFY0ljYTliZmRGOEozWHZCemVmZG1Wc0dVNnRhODR3cEN4cU9waUpFazhQeEU3enMzUk5mU2Y0N1RxcmM4K2xTY2RwbmtXamNBZ2R1ZEVBREVhQXRBcTgzMWVuRHVET1kwTG9oM2JuMDIweitDckw3NFkzbmZ0dGZCTlYxMlZwZDVnU1ZxMHRPdUxUTCt5b1k5R2UvZldPUHYzK3c4K0NIY2VmQzZxNDdRaC9KUlVkT21JeFcvYktkcEhWS1RRWGtHZDZNL0FqblhvWW4xZXUyTW5mTWUxTDRmM1hINDFiSXQ4MHF0YzhhOE9udTlhMnh5UFBMazlBdmwzSDdvdjBuNmdERml6UkY2VmFmbUpUSE5QOGtORE1BT1lVVDhCR25YQjhyMWhJOUI5dlBhZWV5cnQvRUFJbFZYYUNCOE1EaXZhakpTbURoRm9oZlpBQTYwQzdKbEl1Z1JxWnZZMWNjRDFqWHV1Z0crLzVqcDRaV1IyS3JRbEpUU0RTOTBDM0hQNFVEWmwvbVR2SS9ETTZWTmxLcHQ4czh6UWp0UjBkZVJ6dmlpNEVKNEJyVVVTYUJGS0JzZGFBa2NCeFN3MllxcExIK20vYXVzMmVPZWxsOEw3WG5ZZHZDbDJVTm1QUlBqVzZKQlFBSDNYYzgvQmpmc2Voejk5OUZGNCt2UXBtaXlaaW45Y0JxNVRvbDFVTkVpRHEyYXIzQ0pROCtaTkJkaHIwakhUMHNlcFBhN2RlbDdlYi8xOTE3NE1YblhCVHVDbHhsdmFVV011Q2JHN0R6MEh0MFpmL1FlakFIbmk5SW5jQ1F2UGl3RHAyTVJJYnNXdWVHT0E1aXR5Zm1uLzlYVFNWZHM1bDU4TDZnU25BdUtncEFFVXlhMzVtcUhLZ0pZSWJvTWd6VzF1cExXZzdhcjlVSnBmSkhaR2NyNk9yQVFrU2QwckV5U0JPQUZoUmtkaWJtSjRrdGlwRWM2UERmcm1DeStHYTdhZkJ4ZEc5WDUrc2grSmdMV1l6L0ZvWHg2TW5wTzljVGJ5emdpSXcydG55anNCTkV2SkV3MVpLckI3aXlSYnAyeE9na1JGWGY2clVWanEwM09uVEVlaU4wdnNkYWxIbjRBZHdaSHFkMEVzNzgwWFhRVFhSRnQxOTViTmNFR2luY3BLdHV6UnFKME9uWTYwUjgvRjV5UHRCOCtjTlRPczJRK2VORXVrUDd2anBsVXFpNW1oR3pWM0hLd0xzN0RKcE14RDl0d2svczRHdEpmNkpOcDNSdHBmdCt2QzdJbmF2WGx6SENlczV2WG5Vb2dwOHVENHVkanBIb3ZteEYxUml4eUpuUnJGQjg2VEpWTTVUeTVRWkQ4NTFsRmxCbTFuQjRESmRnN0d4S2puRERjV1FseG5nS0dTellDR1ZoaXpvL21lQTNXR3RUSkR5QWRXMDVOYkx6TzJueFdKdmI0dVVydUFZcGFsU1U4YnN2UmtrNHZJTUhxdlU3T1RYUVgwWkNxREpsWng3TytVS1ZiZGMxSEx6R0RyenAwVjJLYjJ3RTZkY1ZiMkN5SGFXUnNGM2dYSjg1SlViV3JVVERjTjdqS1FKOU9xU1F6dFJMK2cyZFBlYmp1dFpSSTl6UHZBWmdocHpjVDd6SGZabmFvdjMwWHJzWklNeWdvdFFoZHBEbjZIcCtOT3lHMHk2U3B3MmRSQTYvYlJBRzRPQkZ0aDVONTA3Z01OUjdDVlo2eXVTL2RKZE1vSDRseUJRRnZ6cHNxbkRZVW1IYzAwOXFVaCs4UUladWlNVkNSdGJ4RjZKV21HNmdaSTRxSzh1dG9WaVVIcUxjZWpBckxvVFBWckVVS1ZxNEJHNnFCWmdtQTVXRnAyc3duMDB6aEpRMkJJQzc1bkxVUTdwZ2EvdnBmeStBanRrMDVldlVVQndSemFvZkZyUWdDMmVWZ2hzL1JMd09yN0pCMlRDUlA1bnJYS3RQQjlWanNyalBHZGFKZVg4aDN0eGE5TThaanVrWDBpTGprRTR4b0NCV2FwVHdQTVdnQ04xcnVFamEwK2FqTGt4a0tvaTl4cFVFdlhqcmY3QXVKVTJRUU9KSUQwWFdaaVZxV1JLYXphWlRNWjlxQUFHQ00wazlMVi9ieFJxV1FVa05NTFV3YkFsWEZvNnFVckY0b0VDVUd0QTEwNmR4N0VSVERrMXdRUzdkUkpRK3BNM0FGWmt0UG9WdlkvVWRLZzBLMjBoam1RN0h3RTgwcWxwMzIwVVF2UlRkb25wTm96ajB0NVlkSVgyalhmYVlKTStKNk9iZzd0SklVSG1sQWRBekNqbTUzV1VycFZKVGtmQjNNSzg3ZWs4TmNtS1Mvb1NBQVFCaENvWlJWd0VDQUgwQXd1d002MlZQbzB1aTl4eFV3SjR2ckx3SEtqS3YweVMvVzlGalVJWkk4Tm1DWFBjU2JZWnBqYVFBWFZhTXZRbnNzazJ2dFVaaG80VnJOS3o2QXVUVHY3d1Z1MEU3OHI3WXBvMDc1WXRhVkk2aGJ0U1VxSHpIZnVlTDNzcnhkcUhUaVBJdTZIdEpQLzNnZ1dKenc4c092em1uamJIcmdBdFBQQ2RJRDRSWmxwVHdqU0lDcjM0STdBWDZSUllRT2FmSkg5MUtvaVdWcVRmWngvSjUwQ0JWVEdVbnJKMzRBVXJZMnBRYnNJekQ1NGFaQ0w2L05DN2tIVnZlVFlaNmxYQml3aDg0RDNBYXkwZzZJZkxPMklEaVNjeEExY2NRSHRXdkFnT2w1cGttczY1SHdUblYyUWpoa0UxT0Q0RG9ZVzRidW1YVXRaSFNldkgrcG5vS2FGZW80RDNqZnFPaWNzYjNJTUNpSlFBM2RpUlExSjdqd1k2SU5kRVFnbldVMkQ4QlpGTWlDYkxaU0gyV0F1ZUpzRHJPbzFJS1o4aklSR1d3ZDVScFVwWkNxcHl2cVdPMXcyUlpqNHlRanRRZVVGQTF5Z3E4ZUFSbHllZHF4MmpPT1hUVCtnWFExWUJkeDByYnZmd0Z5YVI3dDBRQUFaK01sOVVKMVg1YUU2d1FzRmN3cFRqYlZtVUJXVnRId3lDdXBRSkZwS2xFMEt4ZXdRU0pxVFZPUEdSOHBVaEZvb0RHQkpnUjFVaWNQNTRSRFFBSUJPNVFWOVh6TzJQbUpQVlErc3AxUmVOalBTTmZuYU5ZOGcxQTFGU0wxTDV3YWlHWDJoMktBZFhOMFUwTTExYllweXFmaWxhV2ZOd2xxUzhoQ053M3dYY3dXRS93R0hnc1RTcnVqbWFyQkVWbWxxdlFDcXIvbkZCWE1LWnVOTnF4aHJ2ajUvYzg4d2lXem5USHhoRXRMZ1NocVhNRnlhVnpGWlNZS2dHYnNNSFU2Q01ZaWw4UVhFbFptMmZqcFhNcVc0b1Fna2dXMStCbWd5TDZoK3RTT2l2RHEzaU9aS3J1MlFmTTMxQ3FvRGFwa1JUSTRjRjFRK05UR2JiVEoyejBJR2xLU3U2WmFpR1N6Zm1jKzhLTG1oblVBcjVpa0RHWEd3NFpXMEc4TEF5R3lkdC9oc1RJNUJwOUMvb21hNWNDQXBDd0xLb09JTmdWb3FBSkpraGpwQmcxV0tvODZFSDJNYlcycUFoZ2xZaVRSU2dKbEhscXE2SnluMEl4SWJHQmNRTkFOTXZWbkRCS0tkMFJLVTFnSmRkOFZITFkxYXROZHpwRWxCSEtXZGZ3TFV6Z2RFT3lwZU1GU2xHWkUxaUdwWHFod2FMV2xwcitSWk1HdmFVZk85RVYvNEFuWUZXQlUvYUJQRUFaREJYZlB2dEpWb05LQWQrZnNHUUdKQ1lHNW5Td0hOTEtLdVlIQmJTeFVROGlydU9PeUdvM1M1RTdUTU13L1hubUIvVlRrQ3dsRGpVUkFraWJJMk1xek8vM1dkWUpCM20zYUZUQUk1ZW9ERENPMFdpeUJvZFB0VGlNUU9vYUxKUFN3UURVTXl4V3h4SkduYXpNY2dEaHRTanNxalZOY3hoZHZObGJjVVJtTjY2K1h3Uk90cmY0OHlLUGRVa1JyWTh1WVVXTjNBbUJCN1NXOXhRWWwwZTR3Q1FWMG9xU0VTUXovZkFyRFBTQy9zQWE3dXdSUEQwb2NrTXhmbTlpc2NGSU5RZVJrcXJlZ2IzblFBdEhWbzBXek9jUWphVWhGZ3lWbnBJTm9Od0dFSWFsTytvaE5nZnVkamZxcU9pekFIUzYzckZpYjlMOTJiYmpoVGJMU1dBVTh0aElXQ3JIT2xnY28ySEQyandRMUJEK1JhNHFJV2pJWTJkVXVCeGRJOVRLdmxnREVRZEoxUWd4cWdhaWdDSlB1djJZYWVSN3V5SzVlbnZVa3dLQU1HekZnZ0tCQXg3U0xSZzhxWGFDZUFCeVpnME13NExMRkZPMGUwT2lCV1NCdGgySUJVRTJlbVRCeW15eEw2WEFNRFY2NUJFVmg3aklDYUV5a2hvbFY2dVYwTktBMnlwclJvRTFWL1JoZzY5M0YvVHhmZDZwUk11eG9VVjZubE0yZ1YwQ2o5eTAxN1Rxc0VpODdwWFBoTytiUTZvQkUrblA5R3dMeEVPSGRBYzhIQjFib0JiTlIrV1pZYUd2Z2kvZVl4Y3NUK1FFZVB2NEh0cE1zeXpYaHd3TlB1QU1JaGVESmVHTzNuUXJjZTBNMmxYWk1IRzZBZFd2U1BnTmlrQVN2VUJubWVPNWhUZUdHQTFnUnNBTmc1V3RNdEVnU3kwaC91T2VpN01zSzRTb1RsZ1RBbUlYUzgwelpNcnBTUWNOR2huVmt6OUw4SXRHczZXalQ2ZUorK1FUdDdjMnBhUjdzWk0rajd1REhhY1VGSFdKVFdQUlpnZnBpV2R6S1UvNUV5MWU5RDEzcmowRmRKVWpvNGFUMlVEalp2VytueUU5UUZDNGVRQjVSb2xFR2xsVTNEbHFoUk5PdG4xTDNSSlc3Unl5VlVRQUJvbWxvWnB4MVJFWGo4cFgwSGptYksxOVJhaUFhZW1CblE3TW9kM0VORk0rZU5kV3lRMmNsdGl6VUg3bytvcExtbEdXMm5NR21wRFl4YkY0YzBXOUlWelRnZmR5NlBlV21uekRoOUF4MFQ2cXlYVFF0Z080R3ZWS0QwcUs4QnFRSmcwM0s1WUd1dWVBNGFtclZNVVBSNDhGSmEzVW13MGlWeGFxVGNwaGtrdDFKMm5iVlVwS29Hd0RiTkZHL0dNVERrZllub1ZMMUtKOWtRemFoeUQ1VUhtbmRneWxRMDU5bGNyTS9wZHVCaWRWcjBnL09DOUFEdStSYk5pSllPVlErTkJYUjhab3pLZmNwNzhISlNNeE5OcUF1RHdyV0t0dUxJTlloNkN0WHpYbnFid2xwVnRmYzRiMVhWUVhMZktYVzk1dExNWjQ1MnVSUENLRjB3WHFzQjdmWWUveXlnMldRM250YW9KY1VhUTN1cnZjZXEwYWxwYmozWXhBVTB5OHRzODdOdmhXWWF5dnVGMjlDanBlcmUybXJveGpQQjNSaUlyYkZud09xbnBiaXlHR0JOdXJtTUZnMkE0MmxnN0JsNGNXbVhQTStSOW5rODErclBQNzhNN1lqenIxK0U4UDhCMHN6dit0THJ4UndBQUFBQVNVVk9SSzVDWUlJPSc7XG5cbnZhciB2ZXJzaW9uID0gXCIwLjEuMFwiO1xuXG5jb25zdCBmYW1pbHlBY2NvdW50c0Nvbm5lY3RvciA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgRXRoZXJldW1Qcm92aWRlcihvcHRpb25zKTtcbiAgICByZXR1cm4gaW5qZWN0ZWQoe1xuICAgICAgICAvLyBub3RlOiB3ZSBkb24ndCBzdXBwb3J0IGB3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zYCBhdCB0aGlzIHBvaW50XG4gICAgICAgIHNoaW1EaXNjb25uZWN0OiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogJ2ZhbWlseUFjY291bnRzUHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdGYW1pbHkgQWNjb3VudHMnLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIGljb246IExvZ28sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0pO1xufTtcbmZhbWlseUFjY291bnRzQ29ubmVjdG9yLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG5leHBvcnQgeyBDb21tdW5pY2F0aW9uVHlwZXMgYXMgQywgRXRoZXJldW1Qcm92aWRlckNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgYXMgRSwgRmFtaWx5QWNjb3VudHNTZGsgYXMgRiwgU2Vzc2lvblN0YXR1cyBhcyBTLCBTZGtTdGF0dXMgYXMgYSwgU2Vzc2lvbkNyZWF0ZVJlc3VsdCBhcyBiLCBjcmVhdGVGYW1pbHlBY2NvdW50c0NsaWVudCBhcyBjLCBFdGhlcmV1bVByb3ZpZGVyIGFzIGQsIGZhbWlseUFjY291bnRzQ29ubmVjdG9yIGFzIGUsIGZhbWlseUFjY291bnRzQ3VzdG9tQWN0aW9ucyBhcyBmLCBpbnZhcmlhbnQgYXMgaSwgcHJvZHVjdGlvbiBhcyBwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/family/lib/family-accounts-connector-DNek4H7L.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/family/lib/index-DD_kndDs.js":
/*!***************************************************!*\
  !*** ./node_modules/family/lib/index-DD_kndDs.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ index$1)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n\tm.forEach(function (e) {\n\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\treturn Object.freeze(n);\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar postRobot$1 = {exports: {}};\n\nvar postRobot = {exports: {}};\n\n(function (module, exports) {\n\t!function(root, factory) {\n\t    module.exports = factory() ;\n\t}(\"undefined\" != typeof self ? self : commonjsGlobal, (function() {\n\t    return function(modules) {\n\t        var installedModules = {};\n\t        function __nested_webpack_require_1042__(moduleId) {\n\t            if (installedModules[moduleId]) return installedModules[moduleId].exports;\n\t            var module = installedModules[moduleId] = {\n\t                i: moduleId,\n\t                l: !1,\n\t                exports: {}\n\t            };\n\t            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1042__);\n\t            module.l = !0;\n\t            return module.exports;\n\t        }\n\t        __nested_webpack_require_1042__.m = modules;\n\t        __nested_webpack_require_1042__.c = installedModules;\n\t        __nested_webpack_require_1042__.d = function(exports, name, getter) {\n\t            __nested_webpack_require_1042__.o(exports, name) || Object.defineProperty(exports, name, {\n\t                enumerable: !0,\n\t                get: getter\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.r = function(exports) {\n\t            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n\t                value: \"Module\"\n\t            });\n\t            Object.defineProperty(exports, \"__esModule\", {\n\t                value: !0\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.t = function(value, mode) {\n\t            1 & mode && (value = __nested_webpack_require_1042__(value));\n\t            if (8 & mode) return value;\n\t            if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value;\n\t            var ns = Object.create(null);\n\t            __nested_webpack_require_1042__.r(ns);\n\t            Object.defineProperty(ns, \"default\", {\n\t                enumerable: !0,\n\t                value: value\n\t            });\n\t            if (2 & mode && \"string\" != typeof value) for (var key in value) __nested_webpack_require_1042__.d(ns, key, function(key) {\n\t                return value[key];\n\t            }.bind(null, key));\n\t            return ns;\n\t        };\n\t        __nested_webpack_require_1042__.n = function(module) {\n\t            var getter = module && module.__esModule ? function() {\n\t                return module.default;\n\t            } : function() {\n\t                return module;\n\t            };\n\t            __nested_webpack_require_1042__.d(getter, \"a\", getter);\n\t            return getter;\n\t        };\n\t        __nested_webpack_require_1042__.o = function(object, property) {\n\t            return {}.hasOwnProperty.call(object, property);\n\t        };\n\t        __nested_webpack_require_1042__.p = \"\";\n\t        return __nested_webpack_require_1042__(__nested_webpack_require_1042__.s = 0);\n\t    }([ function(module, __nested_webpack_exports__, __nested_webpack_require_3506__) {\n\t        __nested_webpack_require_3506__.r(__nested_webpack_exports__);\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"Promise\", (function() {\n\t            return promise_ZalgoPromise;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"TYPES\", (function() {\n\t            return src_types_TYPES_0;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"ProxyWindow\", (function() {\n\t            return window_ProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"setup\", (function() {\n\t            return setup;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"destroy\", (function() {\n\t            return destroy;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"serializeMessage\", (function() {\n\t            return setup_serializeMessage;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"deserializeMessage\", (function() {\n\t            return setup_deserializeMessage;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"createProxyWindow\", (function() {\n\t            return createProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"toProxyWindow\", (function() {\n\t            return setup_toProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"on\", (function() {\n\t            return on_on;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"once\", (function() {\n\t            return on_once;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"send\", (function() {\n\t            return send_send;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"markWindowKnown\", (function() {\n\t            return markWindowKnown;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"cleanUpWindow\", (function() {\n\t            return cleanUpWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"bridge\", (function() {}));\n\t        function isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        var IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\t        function getActualProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return win.location.protocol;\n\t        }\n\t        function getProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            if (win.mockDomain) {\n\t                var protocol = win.mockDomain.split(\"//\")[0];\n\t                if (protocol) return protocol;\n\t            }\n\t            return getActualProtocol(win);\n\t        }\n\t        function isAboutProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return \"about:\" === getProtocol(win);\n\t        }\n\t        function getParent(win) {\n\t            void 0 === win && (win = window);\n\t            if (win) try {\n\t                if (win.parent && win.parent !== win) return win.parent;\n\t            } catch (err) {}\n\t        }\n\t        function getOpener(win) {\n\t            void 0 === win && (win = window);\n\t            if (win && !getParent(win)) try {\n\t                return win.opener;\n\t            } catch (err) {}\n\t        }\n\t        function canReadFromWindow(win) {\n\t            try {\n\t                return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function getActualDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var location = win.location;\n\t            if (!location) throw new Error(\"Can not read window location\");\n\t            var protocol = getActualProtocol(win);\n\t            if (!protocol) throw new Error(\"Can not read window protocol\");\n\t            if (\"file:\" === protocol) return \"file://\";\n\t            if (\"about:\" === protocol) {\n\t                var parent = getParent(win);\n\t                return parent && canReadFromWindow() ? getActualDomain(parent) : \"about://\";\n\t            }\n\t            var host = location.host;\n\t            if (!host) throw new Error(\"Can not read window host\");\n\t            return protocol + \"//\" + host;\n\t        }\n\t        function getDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var domain = getActualDomain(win);\n\t            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(\"mock:\") ? win.mockDomain : domain;\n\t        }\n\t        function isSameDomain(win) {\n\t            if (!function(win) {\n\t                try {\n\t                    if (win === window) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    var desc = Object.getOwnPropertyDescriptor(win, \"location\");\n\t                    if (desc && !1 === desc.enumerable) return !1;\n\t                } catch (err) {}\n\t                try {\n\t                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (function(win) {\n\t                        void 0 === win && (win = window);\n\t                        return \"mock:\" === getProtocol(win);\n\t                    }(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (getActualDomain(win) === getActualDomain(window)) return !0;\n\t                } catch (err) {}\n\t                return !1;\n\t            }(win)) return !1;\n\t            try {\n\t                if (win === window) return !0;\n\t                if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                if (getDomain(window) === getDomain(win)) return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function assertSameDomain(win) {\n\t            if (!isSameDomain(win)) throw new Error(\"Expected window to be same domain\");\n\t            return win;\n\t        }\n\t        function isAncestorParent(parent, child) {\n\t            if (!parent || !child) return !1;\n\t            var childParent = getParent(child);\n\t            return childParent ? childParent === parent : -1 !== function(win) {\n\t                var result = [];\n\t                try {\n\t                    for (;win.parent !== win; ) {\n\t                        result.push(win.parent);\n\t                        win = win.parent;\n\t                    }\n\t                } catch (err) {}\n\t                return result;\n\t            }(child).indexOf(parent);\n\t        }\n\t        function getFrames(win) {\n\t            var result = [];\n\t            var frames;\n\t            try {\n\t                frames = win.frames;\n\t            } catch (err) {\n\t                frames = win;\n\t            }\n\t            var len;\n\t            try {\n\t                len = frames.length;\n\t            } catch (err) {}\n\t            if (0 === len) return result;\n\t            if (len) {\n\t                for (var i = 0; i < len; i++) {\n\t                    var frame = void 0;\n\t                    try {\n\t                        frame = frames[i];\n\t                    } catch (err) {\n\t                        continue;\n\t                    }\n\t                    result.push(frame);\n\t                }\n\t                return result;\n\t            }\n\t            for (var _i = 0; _i < 100; _i++) {\n\t                var _frame = void 0;\n\t                try {\n\t                    _frame = frames[_i];\n\t                } catch (err) {\n\t                    return result;\n\t                }\n\t                if (!_frame) return result;\n\t                result.push(_frame);\n\t            }\n\t            return result;\n\t        }\n\t        var iframeWindows = [];\n\t        var iframeFrames = [];\n\t        function isWindowClosed(win, allowMock) {\n\t            void 0 === allowMock && (allowMock = !0);\n\t            try {\n\t                if (win === window) return !1;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (!win) return !0;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (win.closed) return !0;\n\t            } catch (err) {\n\t                return !err || err.message !== IE_WIN_ACCESS_ERROR;\n\t            }\n\t            if (allowMock && isSameDomain(win)) try {\n\t                if (win.mockclosed) return !0;\n\t            } catch (err) {}\n\t            try {\n\t                if (!win.parent || !win.top) return !0;\n\t            } catch (err) {}\n\t            var iframeIndex = function(collection, item) {\n\t                for (var i = 0; i < collection.length; i++) try {\n\t                    if (collection[i] === item) return i;\n\t                } catch (err) {}\n\t                return -1;\n\t            }(iframeWindows, win);\n\t            if (-1 !== iframeIndex) {\n\t                var frame = iframeFrames[iframeIndex];\n\t                if (frame && function(frame) {\n\t                    if (!frame.contentWindow) return !0;\n\t                    if (!frame.parentNode) return !0;\n\t                    var doc = frame.ownerDocument;\n\t                    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n\t                        var parent = frame;\n\t                        for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;\n\t                        if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;\n\t                    }\n\t                    return !1;\n\t                }(frame)) return !0;\n\t            }\n\t            return !1;\n\t        }\n\t        function getAncestor(win) {\n\t            void 0 === win && (win = window);\n\t            return getOpener(win = win || window) || getParent(win) || void 0;\n\t        }\n\t        function matchDomain(pattern, origin) {\n\t            if (\"string\" == typeof pattern) {\n\t                if (\"string\" == typeof origin) return \"*\" === pattern || origin === pattern;\n\t                if (isRegex(origin)) return !1;\n\t                if (Array.isArray(origin)) return !1;\n\t            }\n\t            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {\n\t                return matchDomain(subpattern, origin);\n\t            })));\n\t        }\n\t        function isWindow(obj) {\n\t            try {\n\t                if (obj === window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (\"[object Window]\" === {}.toString.call(obj)) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (window.Window && obj instanceof window.Window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.self === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.parent === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.top === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && \"__unlikely_value__\" === obj.__cross_domain_utils_window_check__) return !1;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function getFrameForWindow(win) {\n\t            if (isSameDomain(win)) return assertSameDomain(win).frameElement;\n\t            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll(\"iframe\"); _i21 < _document$querySelect2.length; _i21++) {\n\t                var frame = _document$querySelect2[_i21];\n\t                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;\n\t            }\n\t        }\n\t        function closeWindow(win) {\n\t            if (function(win) {\n\t                void 0 === win && (win = window);\n\t                return Boolean(getParent(win));\n\t            }(win)) {\n\t                var frame = getFrameForWindow(win);\n\t                if (frame && frame.parentElement) {\n\t                    frame.parentElement.removeChild(frame);\n\t                    return;\n\t                }\n\t            }\n\t            try {\n\t                win.close();\n\t            } catch (err) {}\n\t        }\n\t        function utils_isPromise(item) {\n\t            try {\n\t                if (!item) return !1;\n\t                if (\"undefined\" != typeof Promise && item instanceof Promise) return !0;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.Window && item instanceof window.Window) return !1;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.constructor && item instanceof window.constructor) return !1;\n\t                var _toString = {}.toString;\n\t                if (_toString) {\n\t                    var name = _toString.call(item);\n\t                    if (\"[object Window]\" === name || \"[object global]\" === name || \"[object DOMWindow]\" === name) return !1;\n\t                }\n\t                if (\"function\" == typeof item.then) return !0;\n\t            } catch (err) {\n\t                return !1;\n\t            }\n\t            return !1;\n\t        }\n\t        var dispatchedErrors = [];\n\t        var possiblyUnhandledPromiseHandlers = [];\n\t        var activeCount = 0;\n\t        var flushPromise;\n\t        function flushActive() {\n\t            if (!activeCount && flushPromise) {\n\t                var promise = flushPromise;\n\t                flushPromise = null;\n\t                promise.resolve();\n\t            }\n\t        }\n\t        function startActive() {\n\t            activeCount += 1;\n\t        }\n\t        function endActive() {\n\t            activeCount -= 1;\n\t            flushActive();\n\t        }\n\t        var promise_ZalgoPromise = function() {\n\t            function ZalgoPromise(handler) {\n\t                var _this = this;\n\t                this.resolved = void 0;\n\t                this.rejected = void 0;\n\t                this.errorHandled = void 0;\n\t                this.value = void 0;\n\t                this.error = void 0;\n\t                this.handlers = void 0;\n\t                this.dispatching = void 0;\n\t                this.stack = void 0;\n\t                this.resolved = !1;\n\t                this.rejected = !1;\n\t                this.errorHandled = !1;\n\t                this.handlers = [];\n\t                if (handler) {\n\t                    var _result;\n\t                    var _error;\n\t                    var resolved = !1;\n\t                    var rejected = !1;\n\t                    var isAsync = !1;\n\t                    startActive();\n\t                    try {\n\t                        handler((function(res) {\n\t                            if (isAsync) _this.resolve(res); else {\n\t                                resolved = !0;\n\t                                _result = res;\n\t                            }\n\t                        }), (function(err) {\n\t                            if (isAsync) _this.reject(err); else {\n\t                                rejected = !0;\n\t                                _error = err;\n\t                            }\n\t                        }));\n\t                    } catch (err) {\n\t                        endActive();\n\t                        this.reject(err);\n\t                        return;\n\t                    }\n\t                    endActive();\n\t                    isAsync = !0;\n\t                    resolved ? this.resolve(_result) : rejected && this.reject(_error);\n\t                }\n\t            }\n\t            var _proto = ZalgoPromise.prototype;\n\t            _proto.resolve = function(result) {\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(result)) throw new Error(\"Can not resolve promise with another promise\");\n\t                this.resolved = !0;\n\t                this.value = result;\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.reject = function(error) {\n\t                var _this2 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(error)) throw new Error(\"Can not reject promise with another promise\");\n\t                if (!error) {\n\t                    var _err = error && \"function\" == typeof error.toString ? error.toString() : {}.toString.call(error);\n\t                    error = new Error(\"Expected reject to be called with Error, got \" + _err);\n\t                }\n\t                this.rejected = !0;\n\t                this.error = error;\n\t                this.errorHandled || setTimeout((function() {\n\t                    _this2.errorHandled || function(err, promise) {\n\t                        if (-1 === dispatchedErrors.indexOf(err)) {\n\t                            dispatchedErrors.push(err);\n\t                            setTimeout((function() {\n\t                                throw err;\n\t                            }), 1);\n\t                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);\n\t                        }\n\t                    }(error, _this2);\n\t                }), 1);\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.asyncReject = function(error) {\n\t                this.errorHandled = !0;\n\t                this.reject(error);\n\t                return this;\n\t            };\n\t            _proto.dispatch = function() {\n\t                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;\n\t                if (!this.dispatching && (resolved || rejected)) {\n\t                    this.dispatching = !0;\n\t                    startActive();\n\t                    var chain = function(firstPromise, secondPromise) {\n\t                        return firstPromise.then((function(res) {\n\t                            secondPromise.resolve(res);\n\t                        }), (function(err) {\n\t                            secondPromise.reject(err);\n\t                        }));\n\t                    };\n\t                    for (var i = 0; i < handlers.length; i++) {\n\t                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;\n\t                        var _result2 = void 0;\n\t                        if (resolved) try {\n\t                            _result2 = onSuccess ? onSuccess(this.value) : this.value;\n\t                        } catch (err) {\n\t                            promise.reject(err);\n\t                            continue;\n\t                        } else if (rejected) {\n\t                            if (!onError) {\n\t                                promise.reject(this.error);\n\t                                continue;\n\t                            }\n\t                            try {\n\t                                _result2 = onError(this.error);\n\t                            } catch (err) {\n\t                                promise.reject(err);\n\t                                continue;\n\t                            }\n\t                        }\n\t                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {\n\t                            var promiseResult = _result2;\n\t                            promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);\n\t                            promiseResult.errorHandled = !0;\n\t                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);\n\t                    }\n\t                    handlers.length = 0;\n\t                    this.dispatching = !1;\n\t                    endActive();\n\t                }\n\t            };\n\t            _proto.then = function(onSuccess, onError) {\n\t                if (onSuccess && \"function\" != typeof onSuccess && !onSuccess.call) throw new Error(\"Promise.then expected a function for success handler\");\n\t                if (onError && \"function\" != typeof onError && !onError.call) throw new Error(\"Promise.then expected a function for error handler\");\n\t                var promise = new ZalgoPromise;\n\t                this.handlers.push({\n\t                    promise: promise,\n\t                    onSuccess: onSuccess,\n\t                    onError: onError\n\t                });\n\t                this.errorHandled = !0;\n\t                this.dispatch();\n\t                return promise;\n\t            };\n\t            _proto.catch = function(onError) {\n\t                return this.then(void 0, onError);\n\t            };\n\t            _proto.finally = function(onFinally) {\n\t                if (onFinally && \"function\" != typeof onFinally && !onFinally.call) throw new Error(\"Promise.finally expected a function\");\n\t                return this.then((function(result) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        return result;\n\t                    }));\n\t                }), (function(err) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        throw err;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.timeout = function(time, err) {\n\t                var _this3 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                var timeout = setTimeout((function() {\n\t                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error(\"Promise timed out after \" + time + \"ms\"));\n\t                }), time);\n\t                return this.then((function(result) {\n\t                    clearTimeout(timeout);\n\t                    return result;\n\t                }));\n\t            };\n\t            _proto.toPromise = function() {\n\t                if (\"undefined\" == typeof Promise) throw new TypeError(\"Could not find Promise\");\n\t                return Promise.resolve(this);\n\t            };\n\t            _proto.lazy = function() {\n\t                this.errorHandled = !0;\n\t                return this;\n\t            };\n\t            ZalgoPromise.resolve = function(value) {\n\t                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {\n\t                    return value.then(resolve, reject);\n\t                })) : (new ZalgoPromise).resolve(value);\n\t            };\n\t            ZalgoPromise.reject = function(error) {\n\t                return (new ZalgoPromise).reject(error);\n\t            };\n\t            ZalgoPromise.asyncReject = function(error) {\n\t                return (new ZalgoPromise).asyncReject(error);\n\t            };\n\t            ZalgoPromise.all = function(promises) {\n\t                var promise = new ZalgoPromise;\n\t                var count = promises.length;\n\t                var results = [].slice();\n\t                if (!count) {\n\t                    promise.resolve(results);\n\t                    return promise;\n\t                }\n\t                var chain = function(i, firstPromise, secondPromise) {\n\t                    return firstPromise.then((function(res) {\n\t                        results[i] = res;\n\t                        0 == (count -= 1) && promise.resolve(results);\n\t                    }), (function(err) {\n\t                        secondPromise.reject(err);\n\t                    }));\n\t                };\n\t                for (var i = 0; i < promises.length; i++) {\n\t                    var prom = promises[i];\n\t                    if (prom instanceof ZalgoPromise) {\n\t                        if (prom.resolved) {\n\t                            results[i] = prom.value;\n\t                            count -= 1;\n\t                            continue;\n\t                        }\n\t                    } else if (!utils_isPromise(prom)) {\n\t                        results[i] = prom;\n\t                        count -= 1;\n\t                        continue;\n\t                    }\n\t                    chain(i, ZalgoPromise.resolve(prom), promise);\n\t                }\n\t                0 === count && promise.resolve(results);\n\t                return promise;\n\t            };\n\t            ZalgoPromise.hash = function(promises) {\n\t                var result = {};\n\t                var awaitPromises = [];\n\t                var _loop = function(key) {\n\t                    if (promises.hasOwnProperty(key)) {\n\t                        var value = promises[key];\n\t                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {\n\t                            result[key] = res;\n\t                        }))) : result[key] = value;\n\t                    }\n\t                };\n\t                for (var key in promises) _loop(key);\n\t                return ZalgoPromise.all(awaitPromises).then((function() {\n\t                    return result;\n\t                }));\n\t            };\n\t            ZalgoPromise.map = function(items, method) {\n\t                return ZalgoPromise.all(items.map(method));\n\t            };\n\t            ZalgoPromise.onPossiblyUnhandledException = function(handler) {\n\t                return function(handler) {\n\t                    possiblyUnhandledPromiseHandlers.push(handler);\n\t                    return {\n\t                        cancel: function() {\n\t                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n\t                        }\n\t                    };\n\t                }(handler);\n\t            };\n\t            ZalgoPromise.try = function(method, context, args) {\n\t                if (method && \"function\" != typeof method && !method.call) throw new Error(\"Promise.try expected a function\");\n\t                var result;\n\t                startActive();\n\t                try {\n\t                    result = method.apply(context, args || []);\n\t                } catch (err) {\n\t                    endActive();\n\t                    return ZalgoPromise.reject(err);\n\t                }\n\t                endActive();\n\t                return ZalgoPromise.resolve(result);\n\t            };\n\t            ZalgoPromise.delay = function(_delay) {\n\t                return new ZalgoPromise((function(resolve) {\n\t                    setTimeout(resolve, _delay);\n\t                }));\n\t            };\n\t            ZalgoPromise.isPromise = function(value) {\n\t                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);\n\t            };\n\t            ZalgoPromise.flush = function() {\n\t                return function(Zalgo) {\n\t                    var promise = flushPromise = flushPromise || new Zalgo;\n\t                    flushActive();\n\t                    return promise;\n\t                }(ZalgoPromise);\n\t            };\n\t            return ZalgoPromise;\n\t        }();\n\t        function util_safeIndexOf(collection, item) {\n\t            for (var i = 0; i < collection.length; i++) try {\n\t                if (collection[i] === item) return i;\n\t            } catch (err) {}\n\t            return -1;\n\t        }\n\t        var weakmap_CrossDomainSafeWeakMap = function() {\n\t            function CrossDomainSafeWeakMap() {\n\t                this.name = void 0;\n\t                this.weakmap = void 0;\n\t                this.keys = void 0;\n\t                this.values = void 0;\n\t                this.name = \"__weakmap_\" + (1e9 * Math.random() >>> 0) + \"__\";\n\t                if (function() {\n\t                    if (\"undefined\" == typeof WeakMap) return !1;\n\t                    if (void 0 === Object.freeze) return !1;\n\t                    try {\n\t                        var testWeakMap = new WeakMap;\n\t                        var testKey = {};\n\t                        Object.freeze(testKey);\n\t                        testWeakMap.set(testKey, \"__testvalue__\");\n\t                        return \"__testvalue__\" === testWeakMap.get(testKey);\n\t                    } catch (err) {\n\t                        return !1;\n\t                    }\n\t                }()) try {\n\t                    this.weakmap = new WeakMap;\n\t                } catch (err) {}\n\t                this.keys = [];\n\t                this.values = [];\n\t            }\n\t            var _proto = CrossDomainSafeWeakMap.prototype;\n\t            _proto._cleanupClosedWindows = function() {\n\t                var weakmap = this.weakmap;\n\t                var keys = this.keys;\n\t                for (var i = 0; i < keys.length; i++) {\n\t                    var value = keys[i];\n\t                    if (isWindow(value) && isWindowClosed(value)) {\n\t                        if (weakmap) try {\n\t                            weakmap.delete(value);\n\t                        } catch (err) {}\n\t                        keys.splice(i, 1);\n\t                        this.values.splice(i, 1);\n\t                        i -= 1;\n\t                    }\n\t                }\n\t            };\n\t            _proto.isSafeToReadWrite = function(key) {\n\t                return !isWindow(key);\n\t            };\n\t            _proto.set = function(key, value) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.set(key, value);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var name = this.name;\n\t                    var entry = key[name];\n\t                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {\n\t                        value: [ key, value ],\n\t                        writable: !0\n\t                    });\n\t                    return;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var values = this.values;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 === index) {\n\t                    keys.push(key);\n\t                    values.push(value);\n\t                } else values[index] = value;\n\t            };\n\t            _proto.get = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return weakmap.get(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return entry && entry[0] === key ? entry[1] : void 0;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var index = util_safeIndexOf(this.keys, key);\n\t                if (-1 !== index) return this.values[index];\n\t            };\n\t            _proto.delete = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.delete(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 !== index) {\n\t                    keys.splice(index, 1);\n\t                    this.values.splice(index, 1);\n\t                }\n\t            };\n\t            _proto.has = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return !0;\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return !(!entry || entry[0] !== key);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                return -1 !== util_safeIndexOf(this.keys, key);\n\t            };\n\t            _proto.getOrSet = function(key, getter) {\n\t                if (this.has(key)) return this.get(key);\n\t                var value = getter();\n\t                this.set(key, value);\n\t                return value;\n\t            };\n\t            return CrossDomainSafeWeakMap;\n\t        }();\n\t        function getFunctionName(fn) {\n\t            return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n\t        }\n\t        function setFunctionName(fn, name) {\n\t            try {\n\t                delete fn.name;\n\t                fn.name = name;\n\t            } catch (err) {}\n\t            fn.__name__ = fn.displayName = name;\n\t            return fn;\n\t        }\n\t        function uniqueID() {\n\t            var chars = \"0123456789abcdef\";\n\t            return \"uid_\" + \"xxxxxxxxxx\".replace(/./g, (function() {\n\t                return chars.charAt(Math.floor(Math.random() * chars.length));\n\t            })) + \"_\" + function(str) {\n\t                if (\"function\" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {\n\t                    return String.fromCharCode(parseInt(p1, 16));\n\t                }))).replace(/[=]/g, \"\");\n\t                if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n\t                throw new Error(\"Can not find window.btoa or Buffer\");\n\t            }((new Date).toISOString().slice(11, 19).replace(\"T\", \".\")).replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n\t        }\n\t        var objectIDs;\n\t        function serializeArgs(args) {\n\t            try {\n\t                return JSON.stringify([].slice.call(args), (function(subkey, val) {\n\t                    return \"function\" == typeof val ? \"memoize[\" + function(obj) {\n\t                        objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;\n\t                        if (null == obj || \"object\" != typeof obj && \"function\" != typeof obj) throw new Error(\"Invalid object\");\n\t                        var uid = objectIDs.get(obj);\n\t                        if (!uid) {\n\t                            uid = typeof obj + \":\" + uniqueID();\n\t                            objectIDs.set(obj, uid);\n\t                        }\n\t                        return uid;\n\t                    }(val) + \"]\" : \"undefined\" != typeof window && val instanceof window.Element || null !== val && \"object\" == typeof val && 1 === val.nodeType && \"object\" == typeof val.style && \"object\" == typeof val.ownerDocument ? {} : val;\n\t                }));\n\t            } catch (err) {\n\t                throw new Error(\"Arguments not serializable -- can not be used to memoize\");\n\t            }\n\t        }\n\t        function getEmptyObject() {\n\t            return {};\n\t        }\n\t        var memoizeGlobalIndex = 0;\n\t        var memoizeGlobalIndexValidFrom = 0;\n\t        function memoize(method, options) {\n\t            void 0 === options && (options = {});\n\t            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;\n\t            var simpleCache;\n\t            var thisCache;\n\t            var memoizeIndex = memoizeGlobalIndex;\n\t            memoizeGlobalIndex += 1;\n\t            var memoizedFunction = function() {\n\t                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\t                if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n\t                    simpleCache = null;\n\t                    thisCache = null;\n\t                    memoizeIndex = memoizeGlobalIndex;\n\t                    memoizeGlobalIndex += 1;\n\t                }\n\t                var cache;\n\t                cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};\n\t                var cacheKey;\n\t                try {\n\t                    cacheKey = serializeArgs(args);\n\t                } catch (_unused) {\n\t                    return method.apply(this, arguments);\n\t                }\n\t                var cacheResult = cache[cacheKey];\n\t                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n\t                    delete cache[cacheKey];\n\t                    cacheResult = null;\n\t                }\n\t                if (cacheResult) return cacheResult.value;\n\t                var time = Date.now();\n\t                var value = method.apply(this, arguments);\n\t                cache[cacheKey] = {\n\t                    time: time,\n\t                    value: value\n\t                };\n\t                return value;\n\t            };\n\t            memoizedFunction.reset = function() {\n\t                simpleCache = null;\n\t                thisCache = null;\n\t            };\n\t            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + \"::memoized\");\n\t        }\n\t        memoize.clear = function() {\n\t            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n\t        };\n\t        function memoizePromise(method) {\n\t            var cache = {};\n\t            function memoizedPromiseFunction() {\n\t                var _arguments = arguments, _this = this;\n\t                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n\t                var key = serializeArgs(args);\n\t                if (cache.hasOwnProperty(key)) return cache[key];\n\t                cache[key] = promise_ZalgoPromise.try((function() {\n\t                    return method.apply(_this, _arguments);\n\t                })).finally((function() {\n\t                    delete cache[key];\n\t                }));\n\t                return cache[key];\n\t            }\n\t            memoizedPromiseFunction.reset = function() {\n\t                cache = {};\n\t            };\n\t            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + \"::promiseMemoized\");\n\t        }\n\t        function src_util_noop() {}\n\t        function stringifyError(err, level) {\n\t            void 0 === level && (level = 1);\n\t            if (level >= 3) return \"stringifyError stack overflow\";\n\t            try {\n\t                if (!err) return \"<unknown error: \" + {}.toString.call(err) + \">\";\n\t                if (\"string\" == typeof err) return err;\n\t                if (err instanceof Error) {\n\t                    var stack = err && err.stack;\n\t                    var message = err && err.message;\n\t                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + \"\\n\" + stack;\n\t                    if (stack) return stack;\n\t                    if (message) return message;\n\t                }\n\t                return err && err.toString && \"function\" == typeof err.toString ? err.toString() : {}.toString.call(err);\n\t            } catch (newErr) {\n\t                return \"Error while stringifying error: \" + stringifyError(newErr, level + 1);\n\t            }\n\t        }\n\t        function stringify(item) {\n\t            return \"string\" == typeof item ? item : item && item.toString && \"function\" == typeof item.toString ? item.toString() : {}.toString.call(item);\n\t        }\n\t        memoize((function(obj) {\n\t            if (Object.values) return Object.values(obj);\n\t            var result = [];\n\t            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);\n\t            return result;\n\t        }));\n\t        function util_isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        function util_getOrSet(obj, key, getter) {\n\t            if (obj.hasOwnProperty(key)) return obj[key];\n\t            var val = getter();\n\t            obj[key] = val;\n\t            return val;\n\t        }\n\t        function getBody() {\n\t            var body = document.body;\n\t            if (!body) throw new Error(\"Body element not found\");\n\t            return body;\n\t        }\n\t        function isDocumentReady() {\n\t            return Boolean(document.body) && \"complete\" === document.readyState;\n\t        }\n\t        function isDocumentInteractive() {\n\t            return Boolean(document.body) && \"interactive\" === document.readyState;\n\t        }\n\t        memoize((function() {\n\t            return new promise_ZalgoPromise((function(resolve) {\n\t                if (isDocumentReady() || isDocumentInteractive()) return resolve();\n\t                var interval = setInterval((function() {\n\t                    if (isDocumentReady() || isDocumentInteractive()) {\n\t                        clearInterval(interval);\n\t                        return resolve();\n\t                    }\n\t                }), 10);\n\t            }));\n\t        }));\n\t        var currentScript = \"undefined\" != typeof document ? document.currentScript : null;\n\t        var getCurrentScript = memoize((function() {\n\t            if (currentScript) return currentScript;\n\t            if (currentScript = function() {\n\t                try {\n\t                    var stack = function() {\n\t                        try {\n\t                            throw new Error(\"_\");\n\t                        } catch (err) {\n\t                            return err.stack || \"\";\n\t                        }\n\t                    }();\n\t                    var stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n\t                    var scriptLocation = stackDetails && stackDetails[1];\n\t                    if (!scriptLocation) return;\n\t                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName(\"script\")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {\n\t                        var script = _Array$prototype$slic2[_i22];\n\t                        if (script.src && script.src === scriptLocation) return script;\n\t                    }\n\t                } catch (err) {}\n\t            }()) return currentScript;\n\t            throw new Error(\"Can not determine current script\");\n\t        }));\n\t        var currentUID = uniqueID();\n\t        memoize((function() {\n\t            var script;\n\t            try {\n\t                script = getCurrentScript();\n\t            } catch (err) {\n\t                return currentUID;\n\t            }\n\t            var uid = script.getAttribute(\"data-uid\");\n\t            if (uid && \"string\" == typeof uid) return uid;\n\t            if ((uid = script.getAttribute(\"data-uid-auto\")) && \"string\" == typeof uid) return uid;\n\t            if (script.src) {\n\t                var hashedString = function(str) {\n\t                    var hash = \"\";\n\t                    for (var i = 0; i < str.length; i++) {\n\t                        var total = str[i].charCodeAt(0) * i;\n\t                        str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));\n\t                        hash += String.fromCharCode(97 + Math.abs(total) % 26);\n\t                    }\n\t                    return hash;\n\t                }(JSON.stringify({\n\t                    src: script.src,\n\t                    dataset: script.dataset\n\t                }));\n\t                uid = \"uid_\" + hashedString.slice(hashedString.length - 30);\n\t            } else uid = uniqueID();\n\t            script.setAttribute(\"data-uid-auto\", uid);\n\t            return uid;\n\t        }));\n\t        function global_getGlobal(win) {\n\t            void 0 === win && (win = window);\n\t            var globalKey = \"__post_robot_10_0_46__\";\n\t            return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};\n\t        }\n\t        var getObj = function() {\n\t            return {};\n\t        };\n\t        function globalStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return util_getOrSet(global_getGlobal(), key, (function() {\n\t                var store = defStore();\n\t                return {\n\t                    has: function(storeKey) {\n\t                        return store.hasOwnProperty(storeKey);\n\t                    },\n\t                    get: function(storeKey, defVal) {\n\t                        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n\t                    },\n\t                    set: function(storeKey, val) {\n\t                        store[storeKey] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(storeKey) {\n\t                        delete store[storeKey];\n\t                    },\n\t                    getOrSet: function(storeKey, getter) {\n\t                        return util_getOrSet(store, storeKey, getter);\n\t                    },\n\t                    reset: function() {\n\t                        store = defStore();\n\t                    },\n\t                    keys: function() {\n\t                        return Object.keys(store);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        var WildCard = function() {};\n\t        function getWildcard() {\n\t            var global = global_getGlobal();\n\t            global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard;\n\t            return global.WINDOW_WILDCARD;\n\t        }\n\t        function windowStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return globalStore(\"windowStore\").getOrSet(key, (function() {\n\t                var winStore = new weakmap_CrossDomainSafeWeakMap;\n\t                var getStore = function(win) {\n\t                    return winStore.getOrSet(win, defStore);\n\t                };\n\t                return {\n\t                    has: function(win) {\n\t                        return getStore(win).hasOwnProperty(key);\n\t                    },\n\t                    get: function(win, defVal) {\n\t                        var store = getStore(win);\n\t                        return store.hasOwnProperty(key) ? store[key] : defVal;\n\t                    },\n\t                    set: function(win, val) {\n\t                        getStore(win)[key] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(win) {\n\t                        delete getStore(win)[key];\n\t                    },\n\t                    getOrSet: function(win, getter) {\n\t                        return util_getOrSet(getStore(win), key, getter);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        function getInstanceID() {\n\t            return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n\t        }\n\t        function resolveHelloPromise(win, _ref) {\n\t            var domain = _ref.domain;\n\t            var helloPromises = windowStore(\"helloPromises\");\n\t            var existingPromise = helloPromises.get(win);\n\t            existingPromise && existingPromise.resolve({\n\t                domain: domain\n\t            });\n\t            var newPromise = promise_ZalgoPromise.resolve({\n\t                domain: domain\n\t            });\n\t            helloPromises.set(win, newPromise);\n\t            return newPromise;\n\t        }\n\t        function sayHello(win, _ref4) {\n\t            return (0, _ref4.send)(win, \"postrobot_hello\", {\n\t                instanceID: getInstanceID()\n\t            }, {\n\t                domain: \"*\",\n\t                timeout: -1\n\t            }).then((function(_ref5) {\n\t                var origin = _ref5.origin, instanceID = _ref5.data.instanceID;\n\t                resolveHelloPromise(win, {\n\t                    domain: origin\n\t                });\n\t                return {\n\t                    win: win,\n\t                    domain: origin,\n\t                    instanceID: instanceID\n\t                };\n\t            }));\n\t        }\n\t        function getWindowInstanceID(win, _ref6) {\n\t            var send = _ref6.send;\n\t            return windowStore(\"windowInstanceIDPromises\").getOrSet(win, (function() {\n\t                return sayHello(win, {\n\t                    send: send\n\t                }).then((function(_ref7) {\n\t                    return _ref7.instanceID;\n\t                }));\n\t            }));\n\t        }\n\t        function markWindowKnown(win) {\n\t            windowStore(\"knownWindows\").set(win, !0);\n\t        }\n\t        function isSerializedType(item) {\n\t            return \"object\" == typeof item && null !== item && \"string\" == typeof item.__type__;\n\t        }\n\t        function determineType(val) {\n\t            return void 0 === val ? \"undefined\" : null === val ? \"null\" : Array.isArray(val) ? \"array\" : \"function\" == typeof val ? \"function\" : \"object\" == typeof val ? val instanceof Error ? \"error\" : \"function\" == typeof val.then ? \"promise\" : \"[object RegExp]\" === {}.toString.call(val) ? \"regex\" : \"[object Date]\" === {}.toString.call(val) ? \"date\" : \"object\" : \"string\" == typeof val ? \"string\" : \"number\" == typeof val ? \"number\" : \"boolean\" == typeof val ? \"boolean\" : void 0;\n\t        }\n\t        function serializeType(type, val) {\n\t            return {\n\t                __type__: type,\n\t                __val__: val\n\t            };\n\t        }\n\t        var _SERIALIZER;\n\t        var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {\n\t            return serializeType(\"error\", {\n\t                message: _ref.message,\n\t                stack: _ref.stack,\n\t                code: _ref.code,\n\t                data: _ref.data\n\t            });\n\t        }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {\n\t            return serializeType(\"regex\", val.source);\n\t        }, _SERIALIZER.date = function(val) {\n\t            return serializeType(\"date\", val.toJSON());\n\t        }, _SERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _SERIALIZER[void 0] = function(val) {\n\t            return serializeType(\"undefined\", val);\n\t        }, _SERIALIZER);\n\t        var defaultSerializers = {};\n\t        var _DESERIALIZER;\n\t        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {\n\t            throw new Error(\"Function serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.error = function(_ref2) {\n\t            var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;\n\t            var error = new Error(_ref2.message);\n\t            error.code = code;\n\t            data && (error.data = data);\n\t            error.stack = stack + \"\\n\\n\" + error.stack;\n\t            return error;\n\t        }, _DESERIALIZER.promise = function() {\n\t            throw new Error(\"Promise serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.regex = function(val) {\n\t            return new RegExp(val);\n\t        }, _DESERIALIZER.date = function(val) {\n\t            return new Date(val);\n\t        }, _DESERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER[void 0] = function() {}, _DESERIALIZER);\n\t        var defaultDeserializers = {};\n\t        new promise_ZalgoPromise((function(resolve) {\n\t            if (window.document && window.document.body) return resolve(window.document.body);\n\t            var interval = setInterval((function() {\n\t                if (window.document && window.document.body) {\n\t                    clearInterval(interval);\n\t                    return resolve(window.document.body);\n\t                }\n\t            }), 10);\n\t        }));\n\t        function cleanupProxyWindows() {\n\t            var idToProxyWindow = globalStore(\"idToProxyWindow\");\n\t            for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {\n\t                var id = _idToProxyWindow$keys2[_i2];\n\t                idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);\n\t            }\n\t        }\n\t        function getSerializedWindow(winPromise, _ref) {\n\t            var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;\n\t            var windowNamePromise = winPromise.then((function(win) {\n\t                if (isSameDomain(win)) return assertSameDomain(win).name;\n\t            }));\n\t            var windowTypePromise = winPromise.then((function(window) {\n\t                if (isWindowClosed(window)) throw new Error(\"Window is closed, can not determine type\");\n\t                return getOpener(window) ? \"popup\" : \"iframe\";\n\t            }));\n\t            windowNamePromise.catch(src_util_noop);\n\t            windowTypePromise.catch(src_util_noop);\n\t            var getName = function() {\n\t                return winPromise.then((function(win) {\n\t                    if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;\n\t                }));\n\t            };\n\t            return {\n\t                id: id,\n\t                getType: function() {\n\t                    return windowTypePromise;\n\t                },\n\t                getInstanceID: memoizePromise((function() {\n\t                    return winPromise.then((function(win) {\n\t                        return getWindowInstanceID(win, {\n\t                            send: send\n\t                        });\n\t                    }));\n\t                })),\n\t                close: function() {\n\t                    return winPromise.then(closeWindow);\n\t                },\n\t                getName: getName,\n\t                focus: function() {\n\t                    return winPromise.then((function(win) {\n\t                        win.focus();\n\t                    }));\n\t                },\n\t                isClosed: function() {\n\t                    return winPromise.then((function(win) {\n\t                        return isWindowClosed(win);\n\t                    }));\n\t                },\n\t                setLocation: function(href, opts) {\n\t                    void 0 === opts && (opts = {});\n\t                    return winPromise.then((function(win) {\n\t                        var domain = window.location.protocol + \"//\" + window.location.host;\n\t                        var _opts$method = opts.method, method = void 0 === _opts$method ? \"get\" : _opts$method, body = opts.body;\n\t                        if (0 === href.indexOf(\"/\")) href = \"\" + domain + href; else if (!href.match(/^https?:\\/\\//) && 0 !== href.indexOf(domain)) throw new Error(\"Expected url to be http or https url, or absolute path, got \" + JSON.stringify(href));\n\t                        if (\"post\" === method) return getName().then((function(name) {\n\t                            if (!name) throw new Error(\"Can not post to window without target name\");\n\t                            !function(_ref3) {\n\t                                var url = _ref3.url, target = _ref3.target, body = _ref3.body, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? \"post\" : _ref3$method;\n\t                                var form = document.createElement(\"form\");\n\t                                form.setAttribute(\"target\", target);\n\t                                form.setAttribute(\"method\", method);\n\t                                form.setAttribute(\"action\", url);\n\t                                form.style.display = \"none\";\n\t                                if (body) for (var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++) {\n\t                                    var _body$key;\n\t                                    var key = _Object$keys4[_i24];\n\t                                    var input = document.createElement(\"input\");\n\t                                    input.setAttribute(\"name\", key);\n\t                                    input.setAttribute(\"value\", null == (_body$key = body[key]) ? void 0 : _body$key.toString());\n\t                                    form.appendChild(input);\n\t                                }\n\t                                getBody().appendChild(form);\n\t                                form.submit();\n\t                                getBody().removeChild(form);\n\t                            }({\n\t                                url: href,\n\t                                target: name,\n\t                                method: method,\n\t                                body: body\n\t                            });\n\t                        }));\n\t                        if (\"get\" !== method) throw new Error(\"Unsupported method: \" + method);\n\t                        if (isSameDomain(win)) try {\n\t                            if (win.location && \"function\" == typeof win.location.replace) {\n\t                                win.location.replace(href);\n\t                                return;\n\t                            }\n\t                        } catch (err) {}\n\t                        win.location = href;\n\t                    }));\n\t                },\n\t                setName: function(name) {\n\t                    return winPromise.then((function(win) {\n\t                        var sameDomain = isSameDomain(win);\n\t                        var frame = getFrameForWindow(win);\n\t                        if (!sameDomain) throw new Error(\"Can not set name for cross-domain window: \" + name);\n\t                        assertSameDomain(win).name = name;\n\t                        frame && frame.setAttribute(\"name\", name);\n\t                        windowNamePromise = promise_ZalgoPromise.resolve(name);\n\t                    }));\n\t                }\n\t            };\n\t        }\n\t        var window_ProxyWindow = function() {\n\t            function ProxyWindow(_ref2) {\n\t                var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;\n\t                this.id = void 0;\n\t                this.isProxyWindow = !0;\n\t                this.serializedWindow = void 0;\n\t                this.actualWindow = void 0;\n\t                this.actualWindowPromise = void 0;\n\t                this.send = void 0;\n\t                this.name = void 0;\n\t                this.actualWindowPromise = new promise_ZalgoPromise;\n\t                this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send\n\t                });\n\t                globalStore(\"idToProxyWindow\").set(this.getID(), this);\n\t                win && this.setWindow(win, {\n\t                    send: send\n\t                });\n\t            }\n\t            var _proto = ProxyWindow.prototype;\n\t            _proto.getID = function() {\n\t                return this.serializedWindow.id;\n\t            };\n\t            _proto.getType = function() {\n\t                return this.serializedWindow.getType();\n\t            };\n\t            _proto.isPopup = function() {\n\t                return this.getType().then((function(type) {\n\t                    return \"popup\" === type;\n\t                }));\n\t            };\n\t            _proto.setLocation = function(href, opts) {\n\t                var _this = this;\n\t                return this.serializedWindow.setLocation(href, opts).then((function() {\n\t                    return _this;\n\t                }));\n\t            };\n\t            _proto.getName = function() {\n\t                return this.serializedWindow.getName();\n\t            };\n\t            _proto.setName = function(name) {\n\t                var _this2 = this;\n\t                return this.serializedWindow.setName(name).then((function() {\n\t                    return _this2;\n\t                }));\n\t            };\n\t            _proto.close = function() {\n\t                var _this3 = this;\n\t                return this.serializedWindow.close().then((function() {\n\t                    return _this3;\n\t                }));\n\t            };\n\t            _proto.focus = function() {\n\t                var _this4 = this;\n\t                var isPopupPromise = this.isPopup();\n\t                var getNamePromise = this.getName();\n\t                var reopenPromise = promise_ZalgoPromise.hash({\n\t                    isPopup: isPopupPromise,\n\t                    name: getNamePromise\n\t                }).then((function(_ref3) {\n\t                    var name = _ref3.name;\n\t                    _ref3.isPopup && name && window.open(\"\", name, \"noopener\");\n\t                }));\n\t                var focusPromise = this.serializedWindow.focus();\n\t                return promise_ZalgoPromise.all([ reopenPromise, focusPromise ]).then((function() {\n\t                    return _this4;\n\t                }));\n\t            };\n\t            _proto.isClosed = function() {\n\t                return this.serializedWindow.isClosed();\n\t            };\n\t            _proto.getWindow = function() {\n\t                return this.actualWindow;\n\t            };\n\t            _proto.setWindow = function(win, _ref4) {\n\t                var send = _ref4.send;\n\t                this.actualWindow = win;\n\t                this.actualWindowPromise.resolve(this.actualWindow);\n\t                this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send,\n\t                    id: this.getID()\n\t                });\n\t                windowStore(\"winToProxyWindow\").set(win, this);\n\t            };\n\t            _proto.awaitWindow = function() {\n\t                return this.actualWindowPromise;\n\t            };\n\t            _proto.matchWindow = function(win, _ref5) {\n\t                var _this5 = this;\n\t                var send = _ref5.send;\n\t                return promise_ZalgoPromise.try((function() {\n\t                    return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({\n\t                        proxyInstanceID: _this5.getInstanceID(),\n\t                        knownWindowInstanceID: getWindowInstanceID(win, {\n\t                            send: send\n\t                        })\n\t                    }).then((function(_ref6) {\n\t                        var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;\n\t                        match && _this5.setWindow(win, {\n\t                            send: send\n\t                        });\n\t                        return match;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.unwrap = function() {\n\t                return this.actualWindow || this;\n\t            };\n\t            _proto.getInstanceID = function() {\n\t                return this.serializedWindow.getInstanceID();\n\t            };\n\t            _proto.shouldClean = function() {\n\t                return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n\t            };\n\t            _proto.serialize = function() {\n\t                return this.serializedWindow;\n\t            };\n\t            ProxyWindow.unwrap = function(win) {\n\t                return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;\n\t            };\n\t            ProxyWindow.serialize = function(win, _ref7) {\n\t                var send = _ref7.send;\n\t                cleanupProxyWindows();\n\t                return ProxyWindow.toProxyWindow(win, {\n\t                    send: send\n\t                }).serialize();\n\t            };\n\t            ProxyWindow.deserialize = function(serializedWindow, _ref8) {\n\t                var send = _ref8.send;\n\t                cleanupProxyWindows();\n\t                return globalStore(\"idToProxyWindow\").get(serializedWindow.id) || new ProxyWindow({\n\t                    serializedWindow: serializedWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            ProxyWindow.isProxyWindow = function(obj) {\n\t                return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n\t            };\n\t            ProxyWindow.toProxyWindow = function(win, _ref9) {\n\t                var send = _ref9.send;\n\t                cleanupProxyWindows();\n\t                if (ProxyWindow.isProxyWindow(win)) return win;\n\t                var actualWindow = win;\n\t                return windowStore(\"winToProxyWindow\").get(actualWindow) || new ProxyWindow({\n\t                    win: actualWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            return ProxyWindow;\n\t        }();\n\t        function addMethod(id, val, name, source, domain) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {\n\t                val: val,\n\t                name: name,\n\t                domain: domain,\n\t                source: source\n\t            }); else {\n\t                proxyWindowMethods.del(id);\n\t                methodStore.getOrSet(source, (function() {\n\t                    return {};\n\t                }))[id] = {\n\t                    domain: domain,\n\t                    name: name,\n\t                    val: val,\n\t                    source: source\n\t                };\n\t            }\n\t        }\n\t        function lookupMethod(source, id) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            return methodStore.getOrSet(source, (function() {\n\t                return {};\n\t            }))[id] || proxyWindowMethods.get(id);\n\t        }\n\t        function function_serializeFunction(destination, domain, val, key, _ref3) {\n\t            on = (_ref = {\n\t                on: _ref3.on,\n\t                send: _ref3.send\n\t            }).on, send = _ref.send, globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", (function() {\n\t                return on(\"postrobot_method\", {\n\t                    domain: \"*\"\n\t                }, (function(_ref2) {\n\t                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;\n\t                    var id = data.id, name = data.name;\n\t                    var meth = lookupMethod(source, id);\n\t                    if (!meth) throw new Error(\"Could not find method '\" + name + \"' with id: \" + data.id + \" in \" + getDomain(window));\n\t                    var methodSource = meth.source, domain = meth.domain, val = meth.val;\n\t                    return promise_ZalgoPromise.try((function() {\n\t                        if (!matchDomain(domain, origin)) throw new Error(\"Method '\" + data.name + \"' domain \" + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + \" does not match origin \" + origin + \" in \" + getDomain(window));\n\t                        if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {\n\t                            send: send\n\t                        }).then((function(match) {\n\t                            if (!match) throw new Error(\"Method call '\" + data.name + \"' failed - proxy window does not match source in \" + getDomain(window));\n\t                        }));\n\t                    })).then((function() {\n\t                        return val.apply({\n\t                            source: source,\n\t                            origin: origin\n\t                        }, data.args);\n\t                    }), (function(err) {\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            if (val.onError) return val.onError(err);\n\t                        })).then((function() {\n\t                            err.stack && (err.stack = \"Remote call to \" + name + \"(\" + function(args) {\n\t                                void 0 === args && (args = []);\n\t                                return (item = args, [].slice.call(item)).map((function(arg) {\n\t                                    return \"string\" == typeof arg ? \"'\" + arg + \"'\" : void 0 === arg ? \"undefined\" : null === arg ? \"null\" : \"boolean\" == typeof arg ? arg.toString() : Array.isArray(arg) ? \"[ ... ]\" : \"object\" == typeof arg ? \"{ ... }\" : \"function\" == typeof arg ? \"() => { ... }\" : \"<\" + typeof arg + \">\";\n\t                                })).join(\", \");\n\t                                var item;\n\t                            }(data.args) + \") failed\\n\\n\" + err.stack);\n\t                            throw err;\n\t                        }));\n\t                    })).then((function(result) {\n\t                        return {\n\t                            result: result,\n\t                            id: id,\n\t                            name: name\n\t                        };\n\t                    }));\n\t                }));\n\t            }));\n\t            var _ref, on, send;\n\t            var id = val.__id__ || uniqueID();\n\t            destination = window_ProxyWindow.unwrap(destination);\n\t            var name = val.__name__ || val.name || key;\n\t            \"string\" == typeof name && \"function\" == typeof name.indexOf && 0 === name.indexOf(\"anonymous::\") && (name = name.replace(\"anonymous::\", key + \"::\"));\n\t            if (window_ProxyWindow.isProxyWindow(destination)) {\n\t                addMethod(id, val, name, destination, domain);\n\t                destination.awaitWindow().then((function(win) {\n\t                    addMethod(id, val, name, win, domain);\n\t                }));\n\t            } else addMethod(id, val, name, destination, domain);\n\t            return serializeType(\"cross_domain_function\", {\n\t                id: id,\n\t                name: name\n\t            });\n\t        }\n\t        function serializeMessage(destination, domain, obj, _ref) {\n\t            var _serialize;\n\t            var on = _ref.on, send = _ref.send;\n\t            return function(obj, serializers) {\n\t                void 0 === serializers && (serializers = defaultSerializers);\n\t                var result = JSON.stringify(obj, (function(key) {\n\t                    var val = this[key];\n\t                    if (isSerializedType(this)) return val;\n\t                    var type = determineType(val);\n\t                    if (!type) return val;\n\t                    var serializer = serializers[type] || SERIALIZER[type];\n\t                    return serializer ? serializer(val, key) : val;\n\t                }));\n\t                return void 0 === result ? \"undefined\" : result;\n\t            }(obj, ((_serialize = {}).promise = function(val, key) {\n\t                return function(destination, domain, val, key, _ref) {\n\t                    return serializeType(\"cross_domain_zalgo_promise\", {\n\t                        then: function_serializeFunction(destination, domain, (function(resolve, reject) {\n\t                            return val.then(resolve, reject);\n\t                        }), key, {\n\t                            on: _ref.on,\n\t                            send: _ref.send\n\t                        })\n\t                    });\n\t                }(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.function = function(val, key) {\n\t                return function_serializeFunction(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.object = function(val) {\n\t                return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType(\"cross_domain_window\", window_ProxyWindow.serialize(val, {\n\t                    send: send\n\t                })) : val;\n\t            }, _serialize));\n\t        }\n\t        function deserializeMessage(source, origin, message, _ref2) {\n\t            var _deserialize;\n\t            var send = _ref2.send;\n\t            return function(str, deserializers) {\n\t                void 0 === deserializers && (deserializers = defaultDeserializers);\n\t                if (\"undefined\" !== str) return JSON.parse(str, (function(key, val) {\n\t                    if (isSerializedType(this)) return val;\n\t                    var type;\n\t                    var value;\n\t                    if (isSerializedType(val)) {\n\t                        type = val.__type__;\n\t                        value = val.__val__;\n\t                    } else {\n\t                        type = determineType(val);\n\t                        value = val;\n\t                    }\n\t                    if (!type) return value;\n\t                    var deserializer = deserializers[type] || DESERIALIZER[type];\n\t                    return deserializer ? deserializer(value, key) : value;\n\t                }));\n\t            }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {\n\t                return function(source, origin, _ref2) {\n\t                    return new promise_ZalgoPromise(_ref2.then);\n\t                }(0, 0, serializedPromise);\n\t            }, _deserialize.cross_domain_function = function(serializedFunction) {\n\t                return function(source, origin, _ref4, _ref5) {\n\t                    var id = _ref4.id, name = _ref4.name;\n\t                    var send = _ref5.send;\n\t                    var getDeserializedFunction = function(opts) {\n\t                        void 0 === opts && (opts = {});\n\t                        function crossDomainFunctionWrapper() {\n\t                            var _arguments = arguments;\n\t                            return window_ProxyWindow.toProxyWindow(source, {\n\t                                send: send\n\t                            }).awaitWindow().then((function(win) {\n\t                                var meth = lookupMethod(win, id);\n\t                                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({\n\t                                    source: window,\n\t                                    origin: getDomain()\n\t                                }, _arguments);\n\t                                var _args = [].slice.call(_arguments);\n\t                                return opts.fireAndForget ? send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: !0\n\t                                }) : send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: !1\n\t                                }).then((function(res) {\n\t                                    return res.data.result;\n\t                                }));\n\t                            })).catch((function(err) {\n\t                                throw err;\n\t                            }));\n\t                        }\n\t                        crossDomainFunctionWrapper.__name__ = name;\n\t                        crossDomainFunctionWrapper.__origin__ = origin;\n\t                        crossDomainFunctionWrapper.__source__ = source;\n\t                        crossDomainFunctionWrapper.__id__ = id;\n\t                        crossDomainFunctionWrapper.origin = origin;\n\t                        return crossDomainFunctionWrapper;\n\t                    };\n\t                    var crossDomainFunctionWrapper = getDeserializedFunction();\n\t                    crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n\t                        fireAndForget: !0\n\t                    });\n\t                    return crossDomainFunctionWrapper;\n\t                }(source, origin, serializedFunction, {\n\t                    send: send\n\t                });\n\t            }, _deserialize.cross_domain_window = function(serializedWindow) {\n\t                return window_ProxyWindow.deserialize(serializedWindow, {\n\t                    send: send\n\t                });\n\t            }, _deserialize));\n\t        }\n\t        var SEND_MESSAGE_STRATEGIES = {};\n\t        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {\n\t            0 === domain.indexOf(\"file:\") && (domain = \"*\");\n\t            win.postMessage(serializedMessage, domain);\n\t        };\n\t        function send_sendMessage(win, domain, message, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            return promise_ZalgoPromise.try((function() {\n\t                var domainBuffer = windowStore().getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                domainBuffer.buffer = domainBuffer.buffer || [];\n\t                domainBuffer.buffer.push(message);\n\t                domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then((function() {\n\t                    if (isWindowClosed(win)) throw new Error(\"Window is closed\");\n\t                    var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_46__ = domainBuffer.buffer || [], \n\t                    _ref), {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                    var _ref;\n\t                    delete domainBuffer.buffer;\n\t                    var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n\t                    var errors = [];\n\t                    for (var _i2 = 0; _i2 < strategies.length; _i2++) {\n\t                        var strategyName = strategies[_i2];\n\t                        try {\n\t                            SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n\t                        } catch (err) {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                    if (errors.length === strategies.length) throw new Error(\"All post-robot messaging strategies failed:\\n\\n\" + errors.map((function(err, i) {\n\t                        return i + \". \" + stringifyError(err);\n\t                    })).join(\"\\n\\n\"));\n\t                }));\n\t                return domainBuffer.flush.then((function() {\n\t                    delete domainBuffer.flush;\n\t                }));\n\t            })).then(src_util_noop);\n\t        }\n\t        function getResponseListener(hash) {\n\t            return globalStore(\"responseListeners\").get(hash);\n\t        }\n\t        function deleteResponseListener(hash) {\n\t            globalStore(\"responseListeners\").del(hash);\n\t        }\n\t        function isResponseListenerErrored(hash) {\n\t            return globalStore(\"erroredResponseListeners\").has(hash);\n\t        }\n\t        function getRequestListener(_ref) {\n\t            var name = _ref.name, win = _ref.win, domain = _ref.domain;\n\t            var requestListeners = windowStore(\"requestListeners\");\n\t            \"*\" === win && (win = null);\n\t            \"*\" === domain && (domain = null);\n\t            if (!name) throw new Error(\"Name required to get request listener\");\n\t            for (var _i4 = 0, _ref3 = [ win, getWildcard() ]; _i4 < _ref3.length; _i4++) {\n\t                var winQualifier = _ref3[_i4];\n\t                if (winQualifier) {\n\t                    var nameListeners = requestListeners.get(winQualifier);\n\t                    if (nameListeners) {\n\t                        var domainListeners = nameListeners[name];\n\t                        if (domainListeners) {\n\t                            if (domain && \"string\" == typeof domain) {\n\t                                if (domainListeners[domain]) return domainListeners[domain];\n\t                                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {\n\t                                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;\n\t                                    if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;\n\t                                }\n\t                            }\n\t                            if (domainListeners[\"*\"]) return domainListeners[\"*\"];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function handleRequest(source, origin, message, _ref) {\n\t            var on = _ref.on, send = _ref.send;\n\t            var options = getRequestListener({\n\t                name: message.name,\n\t                win: source,\n\t                domain: origin\n\t            });\n\t            var logName = \"postrobot_method\" === message.name && message.data && \"string\" == typeof message.data.name ? message.data.name + \"()\" : message.name;\n\t            function sendResponse(ack, data, error) {\n\t                return promise_ZalgoPromise.flush().then((function() {\n\t                    if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                        return send_sendMessage(source, origin, {\n\t                            id: uniqueID(),\n\t                            origin: getDomain(window),\n\t                            type: \"postrobot_message_response\",\n\t                            hash: message.hash,\n\t                            name: message.name,\n\t                            ack: ack,\n\t                            data: data,\n\t                            error: error\n\t                        }, {\n\t                            on: on,\n\t                            send: send\n\t                        });\n\t                    } catch (err) {\n\t                        throw new Error(\"Send response message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }\n\t                }));\n\t            }\n\t            return promise_ZalgoPromise.all([ promise_ZalgoPromise.flush().then((function() {\n\t                if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                    return send_sendMessage(source, origin, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_ack\",\n\t                        hash: message.hash,\n\t                        name: message.name\n\t                    }, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    throw new Error(\"Send ack message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                }\n\t            })), promise_ZalgoPromise.try((function() {\n\t                if (!options) throw new Error(\"No handler found for post message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                return options.handler({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            })).then((function(data) {\n\t                return sendResponse(\"success\", data);\n\t            }), (function(error) {\n\t                return sendResponse(\"error\", null, error);\n\t            })) ]).then(src_util_noop).catch((function(err) {\n\t                if (options && options.handleError) return options.handleError(err);\n\t                throw err;\n\t            }));\n\t        }\n\t        function handleAck(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message ack for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                try {\n\t                    if (!matchDomain(options.domain, origin)) throw new Error(\"Ack origin \" + origin + \" does not match domain \" + options.domain.toString());\n\t                    if (source !== options.win) throw new Error(\"Ack source does not match registered window\");\n\t                } catch (err) {\n\t                    options.promise.reject(err);\n\t                }\n\t                options.ack = !0;\n\t            }\n\t        }\n\t        function handleResponse(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message response for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                if (!matchDomain(options.domain, origin)) throw new Error(\"Response origin \" + origin + \" does not match domain \" + (pattern = options.domain, \n\t                Array.isArray(pattern) ? \"(\" + pattern.join(\" | \") + \")\" : isRegex(pattern) ? \"RegExp(\" + pattern.toString() + \")\" : pattern.toString()));\n\t                var pattern;\n\t                if (source !== options.win) throw new Error(\"Response source does not match registered window\");\n\t                deleteResponseListener(message.hash);\n\t                \"error\" === message.ack ? options.promise.reject(message.error) : \"success\" === message.ack && options.promise.resolve({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            }\n\t        }\n\t        function receive_receiveMessage(event, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            var receivedMessages = globalStore(\"receivedMessages\");\n\t            try {\n\t                if (!window || window.closed || !event.source) return;\n\t            } catch (err) {\n\t                return;\n\t            }\n\t            var source = event.source, origin = event.origin;\n\t            var messages = function(message, source, origin, _ref) {\n\t                var on = _ref.on, send = _ref.send;\n\t                var parsedMessage;\n\t                try {\n\t                    parsedMessage = deserializeMessage(source, origin, message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    return;\n\t                }\n\t                if (parsedMessage && \"object\" == typeof parsedMessage && null !== parsedMessage) {\n\t                    var parseMessages = parsedMessage.__post_robot_10_0_46__;\n\t                    if (Array.isArray(parseMessages)) return parseMessages;\n\t                }\n\t            }(event.data, source, origin, {\n\t                on: on,\n\t                send: send\n\t            });\n\t            if (messages) {\n\t                markWindowKnown(source);\n\t                for (var _i2 = 0; _i2 < messages.length; _i2++) {\n\t                    var message = messages[_i2];\n\t                    if (receivedMessages.has(message.id)) return;\n\t                    receivedMessages.set(message.id, !0);\n\t                    if (isWindowClosed(source) && !message.fireAndForget) return;\n\t                    0 === message.origin.indexOf(\"file:\") && (origin = \"file://\");\n\t                    try {\n\t                        \"postrobot_message_request\" === message.type ? handleRequest(source, origin, message, {\n\t                            on: on,\n\t                            send: send\n\t                        }) : \"postrobot_message_response\" === message.type ? handleResponse(source, origin, message) : \"postrobot_message_ack\" === message.type && handleAck(source, origin, message);\n\t                    } catch (err) {\n\t                        setTimeout((function() {\n\t                            throw err;\n\t                        }), 0);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function on_on(name, options, handler) {\n\t            if (!name) throw new Error(\"Expected name\");\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            if (!handler) throw new Error(\"Expected handler\");\n\t            var requestListener = function addRequestListener(_ref4, listener) {\n\t                var name = _ref4.name, winCandidate = _ref4.win, domain = _ref4.domain;\n\t                var requestListeners = windowStore(\"requestListeners\");\n\t                if (!name || \"string\" != typeof name) throw new Error(\"Name required to add request listener\");\n\t                if (winCandidate && \"*\" !== winCandidate && window_ProxyWindow.isProxyWindow(winCandidate)) {\n\t                    var requestListenerPromise = winCandidate.awaitWindow().then((function(actualWin) {\n\t                        return addRequestListener({\n\t                            name: name,\n\t                            win: actualWin,\n\t                            domain: domain\n\t                        }, listener);\n\t                    }));\n\t                    return {\n\t                        cancel: function() {\n\t                            requestListenerPromise.then((function(requestListener) {\n\t                                return requestListener.cancel();\n\t                            }), src_util_noop);\n\t                        }\n\t                    };\n\t                }\n\t                var win = winCandidate;\n\t                if (Array.isArray(win)) {\n\t                    var listenersCollection = [];\n\t                    for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        domain: domain,\n\t                        win: _win2[_i8]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                if (Array.isArray(domain)) {\n\t                    var _listenersCollection = [];\n\t                    for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        win: win,\n\t                        domain: _domain2[_i12]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                var existingListener = getRequestListener({\n\t                    name: name,\n\t                    win: win,\n\t                    domain: domain\n\t                });\n\t                win && \"*\" !== win || (win = getWildcard());\n\t                var strDomain = (domain = domain || \"*\").toString();\n\t                if (existingListener) throw win && domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString() + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : win ? new Error(\"Request listener already exists for \" + name + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString()) : new Error(\"Request listener already exists for \" + name);\n\t                var winNameListeners = requestListeners.getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainListeners = util_getOrSet(winNameListeners, name, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainRegexListeners;\n\t                var winNameDomainRegexListener;\n\t                util_isRegex(domain) ? (winNameDomainRegexListeners = util_getOrSet(winNameDomainListeners, \"__domain_regex__\", (function() {\n\t                    return [];\n\t                }))).push(winNameDomainRegexListener = {\n\t                    regex: domain,\n\t                    listener: listener\n\t                }) : winNameDomainListeners[strDomain] = listener;\n\t                return {\n\t                    cancel: function() {\n\t                        delete winNameDomainListeners[strDomain];\n\t                        if (winNameDomainRegexListener) {\n\t                            winNameDomainRegexListeners.splice(winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1));\n\t                            winNameDomainRegexListeners.length || delete winNameDomainListeners.__domain_regex__;\n\t                        }\n\t                        Object.keys(winNameDomainListeners).length || delete winNameListeners[name];\n\t                        win && !Object.keys(winNameListeners).length && requestListeners.del(win);\n\t                    }\n\t                };\n\t            }({\n\t                name: name,\n\t                win: options.window,\n\t                domain: options.domain || \"*\"\n\t            }, {\n\t                handler: handler || options.handler,\n\t                handleError: options.errorHandler || function(err) {\n\t                    throw err;\n\t                }\n\t            });\n\t            return {\n\t                cancel: function() {\n\t                    requestListener.cancel();\n\t                }\n\t            };\n\t        }\n\t        function on_once(name, options, handler) {\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            var promise = new promise_ZalgoPromise;\n\t            var listener;\n\t            options.errorHandler = function(err) {\n\t                listener.cancel();\n\t                promise.reject(err);\n\t            };\n\t            listener = on_on(name, options, (function(event) {\n\t                listener.cancel();\n\t                promise.resolve(event);\n\t                if (handler) return handler(event);\n\t            }));\n\t            promise.cancel = listener.cancel;\n\t            return promise;\n\t        }\n\t        var send_send = function send(winOrProxyWin, name, data, options) {\n\t            var domainMatcher = (options = options || {}).domain || \"*\";\n\t            var responseTimeout = options.timeout || -1;\n\t            var childTimeout = options.timeout || 5e3;\n\t            var fireAndForget = options.fireAndForget || !1;\n\t            return window_ProxyWindow.toProxyWindow(winOrProxyWin, {\n\t                send: send\n\t            }).awaitWindow().then((function(win) {\n\t                return promise_ZalgoPromise.try((function() {\n\t                    !function(name, win, domain) {\n\t                        if (!name) throw new Error(\"Expected name\");\n\t                        if (domain && \"string\" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError(\"Can not send \" + name + \". Expected domain \" + JSON.stringify(domain) + \" to be a string, array, or regex\");\n\t                        if (isWindowClosed(win)) throw new Error(\"Can not send \" + name + \". Target window is closed\");\n\t                    }(name, win, domainMatcher);\n\t                    if (function(parent, child) {\n\t                        var actualParent = getAncestor(child);\n\t                        if (actualParent) return actualParent === parent;\n\t                        if (child === parent) return !1;\n\t                        if (function(win) {\n\t                            void 0 === win && (win = window);\n\t                            try {\n\t                                if (win.top) return win.top;\n\t                            } catch (err) {}\n\t                            if (getParent(win) === win) return win;\n\t                            try {\n\t                                if (isAncestorParent(window, win) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            try {\n\t                                if (isAncestorParent(win, window) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            for (var _i7 = 0, _getAllChildFrames4 = function getAllChildFrames(win) {\n\t                                var result = [];\n\t                                for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n\t                                    var frame = _getFrames2[_i3];\n\t                                    result.push(frame);\n\t                                    for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);\n\t                                }\n\t                                return result;\n\t                            }(win); _i7 < _getAllChildFrames4.length; _i7++) {\n\t                                var frame = _getAllChildFrames4[_i7];\n\t                                try {\n\t                                    if (frame.top) return frame.top;\n\t                                } catch (err) {}\n\t                                if (getParent(frame) === frame) return frame;\n\t                            }\n\t                        }(child) === child) return !1;\n\t                        for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return !0;\n\t                        return !1;\n\t                    }(window, win)) return function(win, timeout, name) {\n\t                        void 0 === timeout && (timeout = 5e3);\n\t                        void 0 === name && (name = \"Window\");\n\t                        var promise = function(win) {\n\t                            return windowStore(\"helloPromises\").getOrSet(win, (function() {\n\t                                return new promise_ZalgoPromise;\n\t                            }));\n\t                        }(win);\n\t                        -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + \" did not load after \" + timeout + \"ms\")));\n\t                        return promise;\n\t                    }(win, childTimeout);\n\t                })).then((function(_temp) {\n\t                    return function(win, targetDomain, actualDomain, _ref) {\n\t                        var send = _ref.send;\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            return \"string\" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try((function() {\n\t                                return actualDomain || sayHello(win, {\n\t                                    send: send\n\t                                }).then((function(_ref2) {\n\t                                    return _ref2.domain;\n\t                                }));\n\t                            })).then((function(normalizedDomain) {\n\t                                if (!matchDomain(targetDomain, targetDomain)) throw new Error(\"Domain \" + stringify(targetDomain) + \" does not match \" + stringify(targetDomain));\n\t                                return normalizedDomain;\n\t                            }));\n\t                        }));\n\t                    }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {\n\t                        send: send\n\t                    });\n\t                })).then((function(targetDomain) {\n\t                    var domain = targetDomain;\n\t                    var logName = \"postrobot_method\" === name && data && \"string\" == typeof data.name ? data.name + \"()\" : name;\n\t                    var promise = new promise_ZalgoPromise;\n\t                    var hash = name + \"_\" + uniqueID();\n\t                    if (!fireAndForget) {\n\t                        var responseListener = {\n\t                            name: name,\n\t                            win: win,\n\t                            domain: domain,\n\t                            promise: promise\n\t                        };\n\t                        !function(hash, listener) {\n\t                            globalStore(\"responseListeners\").set(hash, listener);\n\t                        }(hash, responseListener);\n\t                        var reqPromises = windowStore(\"requestPromises\").getOrSet(win, (function() {\n\t                            return [];\n\t                        }));\n\t                        reqPromises.push(promise);\n\t                        promise.catch((function() {\n\t                            !function(hash) {\n\t                                globalStore(\"erroredResponseListeners\").set(hash, !0);\n\t                            }(hash);\n\t                            deleteResponseListener(hash);\n\t                        }));\n\t                        var totalAckTimeout = function(win) {\n\t                            return windowStore(\"knownWindows\").get(win, !1);\n\t                        }(win) ? 1e4 : 2e3;\n\t                        var totalResTimeout = responseTimeout;\n\t                        var ackTimeout = totalAckTimeout;\n\t                        var resTimeout = totalResTimeout;\n\t                        var interval = function(method, time) {\n\t                            var timeout;\n\t                            !function loop() {\n\t                                timeout = setTimeout((function() {\n\t                                    !function() {\n\t                                        if (isWindowClosed(win)) return promise.reject(new Error(\"Window closed for \" + name + \" before \" + (responseListener.ack ? \"response\" : \"ack\")));\n\t                                        if (responseListener.cancelled) return promise.reject(new Error(\"Response listener was cancelled for \" + name));\n\t                                        ackTimeout = Math.max(ackTimeout - 500, 0);\n\t                                        -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));\n\t                                        responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout && promise.reject(new Error(\"No response for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalResTimeout + \"ms\")) : promise.reject(new Error(\"No ack for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalAckTimeout + \"ms\"));\n\t                                    }();\n\t                                    loop();\n\t                                }), 500);\n\t                            }();\n\t                            return {\n\t                                cancel: function() {\n\t                                    clearTimeout(timeout);\n\t                                }\n\t                            };\n\t                        }();\n\t                        promise.finally((function() {\n\t                            interval.cancel();\n\t                            reqPromises.splice(reqPromises.indexOf(promise, 1));\n\t                        })).catch(src_util_noop);\n\t                    }\n\t                    return send_sendMessage(win, domain, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_request\",\n\t                        hash: hash,\n\t                        name: name,\n\t                        data: data,\n\t                        fireAndForget: fireAndForget\n\t                    }, {\n\t                        on: on_on,\n\t                        send: send\n\t                    }).then((function() {\n\t                        return fireAndForget ? promise.resolve() : promise;\n\t                    }), (function(err) {\n\t                        throw new Error(\"Send request message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }));\n\t                }));\n\t            }));\n\t        };\n\t        function setup_serializeMessage(destination, domain, obj) {\n\t            return serializeMessage(destination, domain, obj, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup_deserializeMessage(source, origin, message) {\n\t            return deserializeMessage(source, origin, message, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function createProxyWindow(win) {\n\t            return new window_ProxyWindow({\n\t                send: send_send,\n\t                win: win\n\t            });\n\t        }\n\t        function setup_toProxyWindow(win) {\n\t            return window_ProxyWindow.toProxyWindow(win, {\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup() {\n\t            if (!global_getGlobal().initialized) {\n\t                global_getGlobal().initialized = !0;\n\t                on = (_ref3 = {\n\t                    on: on_on,\n\t                    send: send_send\n\t                }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function(message) {\n\t                    return receive_receiveMessage(message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                };\n\t                !function(_ref5) {\n\t                    var on = _ref5.on, send = _ref5.send;\n\t                    globalStore().getOrSet(\"postMessageListener\", (function() {\n\t                        return function(obj, event, handler) {\n\t                            obj.addEventListener(\"message\", handler);\n\t                            return {\n\t                                cancel: function() {\n\t                                    obj.removeEventListener(\"message\", handler);\n\t                                }\n\t                            };\n\t                        }(window, 0, (function(event) {\n\t                            !function(event, _ref4) {\n\t                                var on = _ref4.on, send = _ref4.send;\n\t                                promise_ZalgoPromise.try((function() {\n\t                                    var source = event.source || event.sourceElement;\n\t                                    var origin = event.origin || event.originalEvent && event.originalEvent.origin;\n\t                                    var data = event.data;\n\t                                    \"null\" === origin && (origin = \"file://\");\n\t                                    if (source) {\n\t                                        if (!origin) throw new Error(\"Post message did not have origin domain\");\n\t                                        receive_receiveMessage({\n\t                                            source: source,\n\t                                            origin: origin,\n\t                                            data: data\n\t                                        }, {\n\t                                            on: on,\n\t                                            send: send\n\t                                        });\n\t                                    }\n\t                                }));\n\t                            }(event, {\n\t                                on: on,\n\t                                send: send\n\t                            });\n\t                        }));\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t                !function(_ref8) {\n\t                    var on = _ref8.on, send = _ref8.send;\n\t                    globalStore(\"builtinListeners\").getOrSet(\"helloListener\", (function() {\n\t                        var listener = on(\"postrobot_hello\", {\n\t                            domain: \"*\"\n\t                        }, (function(_ref3) {\n\t                            resolveHelloPromise(_ref3.source, {\n\t                                domain: _ref3.origin\n\t                            });\n\t                            return {\n\t                                instanceID: getInstanceID()\n\t                            };\n\t                        }));\n\t                        var parent = getAncestor();\n\t                        parent && sayHello(parent, {\n\t                            send: send\n\t                        }).catch((function(err) {}));\n\t                        return listener;\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t            }\n\t            var _ref3, on, send, global;\n\t        }\n\t        function destroy() {\n\t            !function() {\n\t                var responseListeners = globalStore(\"responseListeners\");\n\t                for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {\n\t                    var hash = _responseListeners$ke2[_i2];\n\t                    var listener = responseListeners.get(hash);\n\t                    listener && (listener.cancelled = !0);\n\t                    responseListeners.del(hash);\n\t                }\n\t            }();\n\t            (listener = globalStore().get(\"postMessageListener\")) && listener.cancel();\n\t            var listener;\n\t            delete window.__post_robot_10_0_46__;\n\t        }\n\t        var src_types_TYPES_0 = !0;\n\t        function cleanUpWindow(win) {\n\t            for (var _i2 = 0, _requestPromises$get2 = windowStore(\"requestPromises\").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error(\"Window \" + (isWindowClosed(win) ? \"closed\" : \"cleaned up\") + \" before response\")).catch(src_util_noop);\n\t        }\n\t        setup();\n\t    } ]);\n\t})); \n} (postRobot));\n\nvar postRobotExports$1 = postRobot.exports;\n\n/* @flow */\n\n(function (module) {\n\t// $FlowFixMe\n\tmodule.exports = postRobotExports$1; // eslint-disable-line import/no-commonjs\n\n\t// $FlowFixMe\n\tmodule.exports.default = module.exports; // eslint-disable-line import/no-commonjs \n} (postRobot$1));\n\nvar postRobotExports = postRobot$1.exports;\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postRobotExports);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n\t__proto__: null,\n\tdefault: index\n}, [postRobotExports]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFtaWx5L2xpYi9pbmRleC1ERF9rbmREcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwrQkFBbUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUIsU0FBUywrQkFBbUI7QUFDNUIsU0FBUywrQkFBbUI7QUFDNUIsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCLGtDQUFrQywrQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDhFQUE4RSwrQkFBbUI7QUFDakc7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsK0JBQW1CO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixzQkFBc0I7QUFDdEI7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixnQkFBZ0IsK0JBQW1CLENBQUMsK0JBQW1CO0FBQ3ZELE1BQU0sb0JBQW9CLDBCQUFtQixFQUFFLCtCQUFtQjtBQUNsRSxTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRCxTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQiwwQkFBMEI7QUFDNUU7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHFDQUFxQztBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxvQ0FBb0M7QUFDeEk7QUFDQTtBQUNBLE9BQU87QUFDUCxFQUFFO0FBQ0YsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBLDBDQUEwQztBQUMxQyxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibGluay1zdGFydGVyLW1vbmFkLy4vbm9kZV9tb2R1bGVzL2ZhbWlseS9saWIvaW5kZXgtRERfa25kRHMuanM/ZGY5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcblx0bS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0ZSAmJiB0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhKGsgaW4gbikpIHtcblx0XHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgcG9zdFJvYm90JDEgPSB7ZXhwb3J0czoge319O1xuXG52YXIgcG9zdFJvYm90ID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0IWZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDtcblx0fShcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZWxmID8gc2VsZiA6IGNvbW1vbmpzR2xvYmFsLCAoZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24obW9kdWxlcykge1xuXHQgICAgICAgIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cdCAgICAgICAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQgICAgICAgICAgICBpZiAoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXHQgICAgICAgICAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG5cdCAgICAgICAgICAgICAgICBpOiBtb2R1bGVJZCxcblx0ICAgICAgICAgICAgICAgIGw6ICExLFxuXHQgICAgICAgICAgICAgICAgZXhwb3J0czoge31cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdCAgICAgICAgICAgIG1vZHVsZS5sID0gITA7XG5cdCAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0ICAgICAgICB9XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuXHQgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcblx0ICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuXHQgICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG5cdCAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHQgICAgICAgICAgICAgICAgdmFsdWU6IFwiTW9kdWxlXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcblx0ICAgICAgICAgICAgMSAmIG1vZGUgJiYgKHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSkpO1xuXHQgICAgICAgICAgICBpZiAoOCAmIG1vZGUpIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKDQgJiBtb2RlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgdmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCBcImRlZmF1bHRcIiwge1xuXHQgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGlmICgyICYgbW9kZSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiB2YWx1ZSkgZm9yICh2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcblx0ICAgICAgICAgICAgfS5iaW5kKG51bGwsIGtleSkpO1xuXHQgICAgICAgICAgICByZXR1cm4gbnM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0ICAgICAgICAgICAgdmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5kZWZhdWx0O1xuXHQgICAgICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCBcImFcIiwgZ2V0dGVyKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldHRlcjtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHQgICAgICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuXHQgICAgfShbIGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQcm9taXNlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUWVBFU1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzcmNfdHlwZXNfVFlQRVNfMDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUHJveHlXaW5kb3dcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXR1cFwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXR1cDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVzdHJveVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkZXN0cm95O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXJpYWxpemVNZXNzYWdlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHVwX3NlcmlhbGl6ZU1lc3NhZ2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlc2VyaWFsaXplTWVzc2FnZVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXR1cF9kZXNlcmlhbGl6ZU1lc3NhZ2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNyZWF0ZVByb3h5V2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5V2luZG93O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0b1Byb3h5V2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHVwX3RvUHJveHlXaW5kb3c7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9uXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG9uX29uO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvbmNlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG9uX29uY2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlbmRcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VuZF9zZW5kO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtYXJrV2luZG93S25vd25cIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbWFya1dpbmRvd0tub3duO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjbGVhblVwV2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNsZWFuVXBXaW5kb3c7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJyaWRnZVwiLCAoZnVuY3Rpb24oKSB7fSkpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGlzUmVnZXgoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFJlZ0V4cF1cIiA9PT0ge30udG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIElFX1dJTl9BQ0NFU1NfRVJST1IgPSBcIkNhbGwgd2FzIHJlamVjdGVkIGJ5IGNhbGxlZS5cXHJcXG5cIjtcblx0ICAgICAgICBmdW5jdGlvbiBnZXRBY3R1YWxQcm90b2NvbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW4ubG9jYXRpb24ucHJvdG9jb2w7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFByb3RvY29sKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgaWYgKHdpbi5tb2NrRG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSB3aW4ubW9ja0RvbWFpbi5zcGxpdChcIi8vXCIpWzBdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHByb3RvY29sKSByZXR1cm4gcHJvdG9jb2w7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGdldEFjdHVhbFByb3RvY29sKHdpbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzQWJvdXRQcm90b2NvbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHJldHVybiBcImFib3V0OlwiID09PSBnZXRQcm90b2NvbCh3aW4pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRQYXJlbnQod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICBpZiAod2luKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbi5wYXJlbnQgJiYgd2luLnBhcmVudCAhPT0gd2luKSByZXR1cm4gd2luLnBhcmVudDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRPcGVuZXIod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICBpZiAod2luICYmICFnZXRQYXJlbnQod2luKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB3aW4ub3BlbmVyO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGNhblJlYWRGcm9tV2luZG93KHdpbikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0QWN0dWFsRG9tYWluKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gd2luLmxvY2F0aW9uO1xuXHQgICAgICAgICAgICBpZiAoIWxvY2F0aW9uKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IGxvY2F0aW9uXCIpO1xuXHQgICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBnZXRBY3R1YWxQcm90b2NvbCh3aW4pO1xuXHQgICAgICAgICAgICBpZiAoIXByb3RvY29sKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IHByb3RvY29sXCIpO1xuXHQgICAgICAgICAgICBpZiAoXCJmaWxlOlwiID09PSBwcm90b2NvbCkgcmV0dXJuIFwiZmlsZTovL1wiO1xuXHQgICAgICAgICAgICBpZiAoXCJhYm91dDpcIiA9PT0gcHJvdG9jb2wpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQod2luKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgJiYgY2FuUmVhZEZyb21XaW5kb3coKSA/IGdldEFjdHVhbERvbWFpbihwYXJlbnQpIDogXCJhYm91dDovL1wiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBob3N0ID0gbG9jYXRpb24uaG9zdDtcblx0ICAgICAgICAgICAgaWYgKCFob3N0KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IGhvc3RcIik7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm90b2NvbCArIFwiLy9cIiArIGhvc3Q7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldERvbWFpbih3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXRBY3R1YWxEb21haW4od2luKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGRvbWFpbiAmJiB3aW4ubW9ja0RvbWFpbiAmJiAwID09PSB3aW4ubW9ja0RvbWFpbi5pbmRleE9mKFwibW9jazpcIikgPyB3aW4ubW9ja0RvbWFpbiA6IGRvbWFpbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNTYW1lRG9tYWluKHdpbikge1xuXHQgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAod2luID09PSB3aW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbiwgXCJsb2NhdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiAhMSA9PT0gZGVzYy5lbnVtZXJhYmxlKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc0Fib3V0UHJvdG9jb2wod2luKSAmJiBjYW5SZWFkRnJvbVdpbmRvdygpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1vY2s6XCIgPT09IGdldFByb3RvY29sKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGdldEFjdHVhbERvbWFpbih3aW4pID09PSBnZXRBY3R1YWxEb21haW4od2luZG93KSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB9KHdpbikpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzQWJvdXRQcm90b2NvbCh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIGlmIChnZXREb21haW4od2luZG93KSA9PT0gZ2V0RG9tYWluKHdpbikpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGFzc2VydFNhbWVEb21haW4od2luKSB7XG5cdCAgICAgICAgICAgIGlmICghaXNTYW1lRG9tYWluKHdpbikpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHdpbmRvdyB0byBiZSBzYW1lIGRvbWFpblwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNBbmNlc3RvclBhcmVudChwYXJlbnQsIGNoaWxkKSB7XG5cdCAgICAgICAgICAgIGlmICghcGFyZW50IHx8ICFjaGlsZCkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRQYXJlbnQgPSBnZXRQYXJlbnQoY2hpbGQpO1xuXHQgICAgICAgICAgICByZXR1cm4gY2hpbGRQYXJlbnQgPyBjaGlsZFBhcmVudCA9PT0gcGFyZW50IDogLTEgIT09IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKDt3aW4ucGFyZW50ICE9PSB3aW47ICkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3aW4ucGFyZW50KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luID0gd2luLnBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICB9KGNoaWxkKS5pbmRleE9mKHBhcmVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYW1lcyh3aW4pIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgZnJhbWVzO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZnJhbWVzID0gd2luLmZyYW1lcztcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBmcmFtZXMgPSB3aW47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGxlbjtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGxlbiA9IGZyYW1lcy5sZW5ndGg7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgaWYgKDAgPT09IGxlbikgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgaWYgKGxlbikge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGZyYW1lc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDEwMDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gZnJhbWVzW19pXTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoIV9mcmFtZSkgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKF9mcmFtZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGlmcmFtZVdpbmRvd3MgPSBbXTtcblx0ICAgICAgICB2YXIgaWZyYW1lRnJhbWVzID0gW107XG5cdCAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3dDbG9zZWQod2luLCBhbGxvd01vY2spIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBhbGxvd01vY2sgJiYgKGFsbG93TW9jayA9ICEwKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCF3aW4pIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4uY2xvc2VkKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICFlcnIgfHwgZXJyLm1lc3NhZ2UgIT09IElFX1dJTl9BQ0NFU1NfRVJST1I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGFsbG93TW9jayAmJiBpc1NhbWVEb21haW4od2luKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4ubW9ja2Nsb3NlZCkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXdpbi5wYXJlbnQgfHwgIXdpbi50b3ApIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB2YXIgaWZyYW1lSW5kZXggPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25baV0gPT09IGl0ZW0pIHJldHVybiBpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICB9KGlmcmFtZVdpbmRvd3MsIHdpbik7XG5cdCAgICAgICAgICAgIGlmICgtMSAhPT0gaWZyYW1lSW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGlmcmFtZUZyYW1lc1tpZnJhbWVJbmRleF07XG5cdCAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgZnVuY3Rpb24oZnJhbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWZyYW1lLmNvbnRlbnRXaW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWZyYW1lLnBhcmVudE5vZGUpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gZnJhbWUub3duZXJEb2N1bWVudDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZG9jICYmIGRvYy5kb2N1bWVudEVsZW1lbnQgJiYgIWRvYy5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZnJhbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBmcmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7cGFyZW50LnBhcmVudE5vZGUgJiYgcGFyZW50LnBhcmVudE5vZGUgIT09IHBhcmVudDsgKSBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQuaG9zdCB8fCAhZG9jLmRvY3VtZW50RWxlbWVudC5jb250YWlucyhwYXJlbnQuaG9zdCkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgfShmcmFtZSkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEFuY2VzdG9yKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldE9wZW5lcih3aW4gPSB3aW4gfHwgd2luZG93KSB8fCBnZXRQYXJlbnQod2luKSB8fCB2b2lkIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG1hdGNoRG9tYWluKHBhdHRlcm4sIG9yaWdpbikge1xuXHQgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcGF0dGVybikge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIG9yaWdpbikgcmV0dXJuIFwiKlwiID09PSBwYXR0ZXJuIHx8IG9yaWdpbiA9PT0gcGF0dGVybjtcblx0ICAgICAgICAgICAgICAgIGlmIChpc1JlZ2V4KG9yaWdpbikpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gaXNSZWdleChwYXR0ZXJuKSA/IGlzUmVnZXgob3JpZ2luKSA/IHBhdHRlcm4udG9TdHJpbmcoKSA9PT0gb3JpZ2luLnRvU3RyaW5nKCkgOiAhQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIEJvb2xlYW4ob3JpZ2luLm1hdGNoKHBhdHRlcm4pKSA6ICEhQXJyYXkuaXNBcnJheShwYXR0ZXJuKSAmJiAoQXJyYXkuaXNBcnJheShvcmlnaW4pID8gSlNPTi5zdHJpbmdpZnkocGF0dGVybikgPT09IEpTT04uc3RyaW5naWZ5KG9yaWdpbikgOiAhaXNSZWdleChvcmlnaW4pICYmIHBhdHRlcm4uc29tZSgoZnVuY3Rpb24oc3VicGF0dGVybikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoRG9tYWluKHN1YnBhdHRlcm4sIG9yaWdpbik7XG5cdCAgICAgICAgICAgIH0pKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gd2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiA9PT0ge30udG9TdHJpbmcuY2FsbChvYmopKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luZG93LldpbmRvdyAmJiBvYmogaW5zdGFuY2VvZiB3aW5kb3cuV2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5zZWxmID09PSBvYmopIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnBhcmVudCA9PT0gb2JqKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai50b3AgPT09IG9iaikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBcIl9fdW5saWtlbHlfdmFsdWVfX1wiID09PSBvYmouX19jcm9zc19kb21haW5fdXRpbHNfd2luZG93X2NoZWNrX18pIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChcInBvc3RNZXNzYWdlXCIgaW4gb2JqICYmIFwic2VsZlwiIGluIG9iaiAmJiBcImxvY2F0aW9uXCIgaW4gb2JqKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFtZUZvcldpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSByZXR1cm4gYXNzZXJ0U2FtZURvbWFpbih3aW4pLmZyYW1lRWxlbWVudDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kyMSA9IDAsIF9kb2N1bWVudCRxdWVyeVNlbGVjdDIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaWZyYW1lXCIpOyBfaTIxIDwgX2RvY3VtZW50JHF1ZXJ5U2VsZWN0Mi5sZW5ndGg7IF9pMjErKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX2RvY3VtZW50JHF1ZXJ5U2VsZWN0MltfaTIxXTtcblx0ICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBmcmFtZS5jb250ZW50V2luZG93ICYmIGZyYW1lLmNvbnRlbnRXaW5kb3cgPT09IHdpbikgcmV0dXJuIGZyYW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGNsb3NlV2luZG93KHdpbikge1xuXHQgICAgICAgICAgICBpZiAoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGdldFBhcmVudCh3aW4pKTtcblx0ICAgICAgICAgICAgfSh3aW4pKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBnZXRGcmFtZUZvcldpbmRvdyh3aW4pO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZyYW1lICYmIGZyYW1lLnBhcmVudEVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmcmFtZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGZyYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHdpbi5jbG9zZSgpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHV0aWxzX2lzUHJvbWlzZShpdGVtKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBQcm9taXNlICYmIGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygd2luZG93LldpbmRvdyAmJiBpdGVtIGluc3RhbmNlb2Ygd2luZG93LldpbmRvdykgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbmRvdy5jb25zdHJ1Y3RvciAmJiBpdGVtIGluc3RhbmNlb2Ygd2luZG93LmNvbnN0cnVjdG9yKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICBpZiAoX3RvU3RyaW5nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfdG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiA9PT0gbmFtZSB8fCBcIltvYmplY3QgZ2xvYmFsXVwiID09PSBuYW1lIHx8IFwiW29iamVjdCBET01XaW5kb3ddXCIgPT09IG5hbWUpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZW0udGhlbikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBkaXNwYXRjaGVkRXJyb3JzID0gW107XG5cdCAgICAgICAgdmFyIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzID0gW107XG5cdCAgICAgICAgdmFyIGFjdGl2ZUNvdW50ID0gMDtcblx0ICAgICAgICB2YXIgZmx1c2hQcm9taXNlO1xuXHQgICAgICAgIGZ1bmN0aW9uIGZsdXNoQWN0aXZlKCkge1xuXHQgICAgICAgICAgICBpZiAoIWFjdGl2ZUNvdW50ICYmIGZsdXNoUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmbHVzaFByb21pc2U7XG5cdCAgICAgICAgICAgICAgICBmbHVzaFByb21pc2UgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RhcnRBY3RpdmUoKSB7XG5cdCAgICAgICAgICAgIGFjdGl2ZUNvdW50ICs9IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGVuZEFjdGl2ZSgpIHtcblx0ICAgICAgICAgICAgYWN0aXZlQ291bnQgLT0gMTtcblx0ICAgICAgICAgICAgZmx1c2hBY3RpdmUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHByb21pc2VfWmFsZ29Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIFphbGdvUHJvbWlzZShoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9ICExO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RlZCA9ICExO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSAhMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9lcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSAhMTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSAhMTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaXNBc3luYyA9ICExO1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luYykgX3RoaXMucmVzb2x2ZShyZXMpOyBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQgPSByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luYykgX3RoaXMucmVqZWN0KGVycik7IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdGVkID0gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yID0gZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlzQXN5bmMgPSAhMDtcblx0ICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA/IHRoaXMucmVzb2x2ZShfcmVzdWx0KSA6IHJlamVjdGVkICYmIHRoaXMucmVqZWN0KF9lcnJvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIF9wcm90byA9IFphbGdvUHJvbWlzZS5wcm90b3R5cGU7XG5cdCAgICAgICAgICAgIF9wcm90by5yZXNvbHZlID0gZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmICh1dGlsc19pc1Byb21pc2UocmVzdWx0KSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBhbm90aGVyIHByb21pc2VcIik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gITA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5yZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmICh1dGlsc19pc1Byb21pc2UoZXJyb3IpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlamVjdCBwcm9taXNlIHdpdGggYW5vdGhlciBwcm9taXNlXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfZXJyID0gZXJyb3IgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlcnJvci50b1N0cmluZyA/IGVycm9yLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkV4cGVjdGVkIHJlamVjdCB0byBiZSBjYWxsZWQgd2l0aCBFcnJvciwgZ290IFwiICsgX2Vycik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gITA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCB8fCBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpczIuZXJyb3JIYW5kbGVkIHx8IGZ1bmN0aW9uKGVyciwgcHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IGRpc3BhdGNoZWRFcnJvcnMuaW5kZXhPZihlcnIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVkRXJyb3JzLnB1c2goZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzW2pdKGVyciwgcHJvbWlzZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KGVycm9yLCBfdGhpczIpO1xuXHQgICAgICAgICAgICAgICAgfSksIDEpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5hc3luY1JlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5kaXNwYXRjaCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gdGhpcy5yZXNvbHZlZCwgcmVqZWN0ZWQgPSB0aGlzLnJlamVjdGVkLCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGF0Y2hpbmcgJiYgKHJlc29sdmVkIHx8IHJlamVjdGVkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSAhMDtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFydEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGFpbiA9IGZ1bmN0aW9uKGZpcnN0UHJvbWlzZSwgc2Vjb25kUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaGFuZGxlcnMkaSA9IGhhbmRsZXJzW2ldLCBvblN1Y2Nlc3MgPSBfaGFuZGxlcnMkaS5vblN1Y2Nlc3MsIG9uRXJyb3IgPSBfaGFuZGxlcnMkaS5vbkVycm9yLCBwcm9taXNlID0gX2hhbmRsZXJzJGkucHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQyID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0MiA9IG9uU3VjY2VzcyA/IG9uU3VjY2Vzcyh0aGlzLnZhbHVlKSA6IHRoaXMudmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlamVjdGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9uRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdDIgPSBvbkVycm9yKHRoaXMuZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Jlc3VsdDIgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UgJiYgKF9yZXN1bHQyLnJlc29sdmVkIHx8IF9yZXN1bHQyLnJlamVjdGVkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VSZXN1bHQgPSBfcmVzdWx0Mjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXN1bHQucmVzb2x2ZWQgPyBwcm9taXNlLnJlc29sdmUocHJvbWlzZVJlc3VsdC52YWx1ZSkgOiBwcm9taXNlLnJlamVjdChwcm9taXNlUmVzdWx0LmVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXN1bHQuZXJyb3JIYW5kbGVkID0gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB1dGlsc19pc1Byb21pc2UoX3Jlc3VsdDIpID8gX3Jlc3VsdDIgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UgJiYgKF9yZXN1bHQyLnJlc29sdmVkIHx8IF9yZXN1bHQyLnJlamVjdGVkKSA/IF9yZXN1bHQyLnJlc29sdmVkID8gcHJvbWlzZS5yZXNvbHZlKF9yZXN1bHQyLnZhbHVlKSA6IHByb21pc2UucmVqZWN0KF9yZXN1bHQyLmVycm9yKSA6IGNoYWluKF9yZXN1bHQyLCBwcm9taXNlKSA6IHByb21pc2UucmVzb2x2ZShfcmVzdWx0Mik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmxlbmd0aCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9ICExO1xuXHQgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uKG9uU3VjY2Vzcywgb25FcnJvcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9uU3VjY2VzcyAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uU3VjY2VzcyAmJiAhb25TdWNjZXNzLmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UudGhlbiBleHBlY3RlZCBhIGZ1bmN0aW9uIGZvciBzdWNjZXNzIGhhbmRsZXJcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAob25FcnJvciAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uRXJyb3IgJiYgIW9uRXJyb3IuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS50aGVuIGV4cGVjdGVkIGEgZnVuY3Rpb24gZm9yIGVycm9yIGhhbmRsZXJcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBvblN1Y2Nlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5jYXRjaCA9IGZ1bmN0aW9uKG9uRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCBvbkVycm9yKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmZpbmFsbHkgPSBmdW5jdGlvbihvbkZpbmFsbHkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChvbkZpbmFsbHkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvbkZpbmFsbHkgJiYgIW9uRmluYWxseS5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLmZpbmFsbHkgZXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UudHJ5KG9uRmluYWxseSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnRyeShvbkZpbmFsbHkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udGltZW91dCA9IGZ1bmN0aW9uKHRpbWUsIGVycikge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMzLnJlc29sdmVkIHx8IF90aGlzMy5yZWplY3RlZCB8fCBfdGhpczMucmVqZWN0KGVyciB8fCBuZXcgRXJyb3IoXCJQcm9taXNlIHRpbWVkIG91dCBhZnRlciBcIiArIHRpbWUgKyBcIm1zXCIpKTtcblx0ICAgICAgICAgICAgICAgIH0pLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udG9Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgUHJvbWlzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvdWxkIG5vdCBmaW5kIFByb21pc2VcIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8ubGF6eSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UgPyB2YWx1ZSA6IHV0aWxzX2lzUHJvbWlzZSh2YWx1ZSkgPyBuZXcgWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgfSkpIDogKG5ldyBaYWxnb1Byb21pc2UpLnJlc29sdmUodmFsdWUpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAobmV3IFphbGdvUHJvbWlzZSkucmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmFzeW5jUmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAobmV3IFphbGdvUHJvbWlzZSkuYXN5bmNSZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuYWxsID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFphbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHByb21pc2VzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW10uc2xpY2UoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghY291bnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbihpLCBmaXJzdFByb21pc2UsIHNlY29uZFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAwID09IChjb3VudCAtPSAxKSAmJiBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9tID0gcHJvbWlzZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb20gaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb20ucmVzb2x2ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBwcm9tLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgLT0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdXRpbHNfaXNQcm9taXNlKHByb20pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBwcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhaW4oaSwgWmFsZ29Qcm9taXNlLnJlc29sdmUocHJvbSksIHByb21pc2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgMCA9PT0gY291bnQgJiYgcHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5oYXNoID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgICAgICAgICAgICAgIHZhciBhd2FpdFByb21pc2VzID0gW107XG5cdCAgICAgICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9taXNlc1trZXldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1dGlsc19pc1Byb21pc2UodmFsdWUpID8gYXdhaXRQcm9taXNlcy5wdXNoKHZhbHVlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKSkgOiByZXN1bHRba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvbWlzZXMpIF9sb29wKGtleSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLmFsbChhd2FpdFByb21pc2VzKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UubWFwID0gZnVuY3Rpb24oaXRlbXMsIG1ldGhvZCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5hbGwoaXRlbXMubWFwKG1ldGhvZCkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMuc3BsaWNlKHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLmluZGV4T2YoaGFuZGxlciksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0oaGFuZGxlcik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS50cnkgPSBmdW5jdGlvbihtZXRob2QsIGNvbnRleHQsIGFyZ3MpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChtZXRob2QgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBtZXRob2QgJiYgIW1ldGhvZC5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRyeSBleHBlY3RlZCBhIGZ1bmN0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0QWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzIHx8IFtdKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuZGVsYXkgPSBmdW5jdGlvbihfZGVsYXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBfZGVsYXkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuaXNQcm9taXNlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSkgfHwgdXRpbHNfaXNQcm9taXNlKHZhbHVlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oWmFsZ28pIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZsdXNoUHJvbWlzZSA9IGZsdXNoUHJvbWlzZSB8fCBuZXcgWmFsZ287XG5cdCAgICAgICAgICAgICAgICAgICAgZmx1c2hBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH0oWmFsZ29Qcm9taXNlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZTtcblx0ICAgICAgICB9KCk7XG5cdCAgICAgICAgZnVuY3Rpb24gdXRpbF9zYWZlSW5kZXhPZihjb2xsZWN0aW9uLCBpdGVtKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09PSBpdGVtKSByZXR1cm4gaTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB3ZWFrbWFwX0Nyb3NzRG9tYWluU2FmZVdlYWtNYXAgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gQ3Jvc3NEb21haW5TYWZlV2Vha01hcCgpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMud2Vha21hcCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMua2V5cyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gXCJfX3dlYWttYXBfXCIgKyAoMWU5ICogTWF0aC5yYW5kb20oKSA+Pj4gMCkgKyBcIl9fXCI7XG5cdCAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBPYmplY3QuZnJlZXplKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RXZWFrTWFwID0gbmV3IFdlYWtNYXA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0S2V5ID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGVzdEtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RXZWFrTWFwLnNldCh0ZXN0S2V5LCBcIl9fdGVzdHZhbHVlX19cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIl9fdGVzdHZhbHVlX19cIiA9PT0gdGVzdFdlYWtNYXAuZ2V0KHRlc3RLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSgpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMud2Vha21hcCA9IG5ldyBXZWFrTWFwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5rZXlzID0gW107XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcHJvdG8gPSBDcm9zc0RvbWFpblNhZmVXZWFrTWFwLnByb3RvdHlwZTtcblx0ICAgICAgICAgICAgX3Byb3RvLl9jbGVhbnVwQ2xvc2VkV2luZG93cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGtleXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93KHZhbHVlKSAmJiBpc1dpbmRvd0Nsb3NlZCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLmRlbGV0ZSh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmlzU2FmZVRvUmVhZFdyaXRlID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gIWlzV2luZG93KGtleSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHdlYWttYXAuc2V0KGtleSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W25hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA9IHZhbHVlIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KGtleSwgbmFtZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHV0aWxfc2FmZUluZGV4T2Yoa2V5cywga2V5KTtcblx0ICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gaW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwLmhhcyhrZXkpKSByZXR1cm4gd2Vha21hcC5nZXQoa2V5KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoLTEgIT09IGluZGV4KSByZXR1cm4gdGhpcy52YWx1ZXNbaW5kZXhdO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZGVsZXRlID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHdlYWttYXAuZGVsZXRlKGtleSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ICYmIChlbnRyeVswXSA9IGVudHJ5WzFdID0gdm9pZCAwKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHV0aWxfc2FmZUluZGV4T2Yoa2V5cywga2V5KTtcblx0ICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcC5oYXMoa2V5KSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAtMSAhPT0gdXRpbF9zYWZlSW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRPclNldCA9IGZ1bmN0aW9uKGtleSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcblx0ICAgICAgICB9KCk7XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmbi5uYW1lIHx8IGZuLl9fbmFtZV9fIHx8IGZuLmRpc3BsYXlOYW1lIHx8IFwiYW5vbnltb3VzXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNldEZ1bmN0aW9uTmFtZShmbiwgbmFtZSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGZuLm5hbWU7XG5cdCAgICAgICAgICAgICAgICBmbi5uYW1lID0gbmFtZTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICBmbi5fX25hbWVfXyA9IGZuLmRpc3BsYXlOYW1lID0gbmFtZTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiB1bmlxdWVJRCgpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5cdCAgICAgICAgICAgIHJldHVybiBcInVpZF9cIiArIFwieHh4eHh4eHh4eFwiLnJlcGxhY2UoLy4vZywgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcblx0ICAgICAgICAgICAgfSkpICsgXCJfXCIgKyBmdW5jdGlvbihzdHIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGJ0b2EpIHJldHVybiBidG9hKGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoLyUoWzAtOUEtRl17Mn0pL2csIChmdW5jdGlvbihtLCBwMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHAxLCAxNikpO1xuXHQgICAgICAgICAgICAgICAgfSkpKS5yZXBsYWNlKC9bPV0vZywgXCJcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQnVmZmVyKSByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcInV0ZjhcIikudG9TdHJpbmcoXCJiYXNlNjRcIikucmVwbGFjZSgvWz1dL2csIFwiXCIpO1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIHdpbmRvdy5idG9hIG9yIEJ1ZmZlclwiKTtcblx0ICAgICAgICAgICAgfSgobmV3IERhdGUpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMTEsIDE5KS5yZXBsYWNlKFwiVFwiLCBcIi5cIikpLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgb2JqZWN0SURzO1xuXHQgICAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUFyZ3MoYXJncykge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtdLnNsaWNlLmNhbGwoYXJncyksIChmdW5jdGlvbihzdWJrZXksIHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHZhbCA/IFwibWVtb2l6ZVtcIiArIGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMgPSBvYmplY3RJRHMgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gb2JqIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIG9iaiAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9iaikgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvYmplY3RcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1aWQgPSBvYmplY3RJRHMuZ2V0KG9iaik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdWlkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQgPSB0eXBlb2Ygb2JqICsgXCI6XCIgKyB1bmlxdWVJRCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SURzLnNldChvYmosIHVpZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVpZDtcblx0ICAgICAgICAgICAgICAgICAgICB9KHZhbCkgKyBcIl1cIiA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiB2YWwgaW5zdGFuY2VvZiB3aW5kb3cuRWxlbWVudCB8fCBudWxsICE9PSB2YWwgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsICYmIDEgPT09IHZhbC5ub2RlVHlwZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWwuc3R5bGUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsLm93bmVyRG9jdW1lbnQgPyB7fSA6IHZhbDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudHMgbm90IHNlcmlhbGl6YWJsZSAtLSBjYW4gbm90IGJlIHVzZWQgdG8gbWVtb2l6ZVwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRFbXB0eU9iamVjdCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbWVtb2l6ZUdsb2JhbEluZGV4ID0gMDtcblx0ICAgICAgICB2YXIgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tID0gMDtcblx0ICAgICAgICBmdW5jdGlvbiBtZW1vaXplKG1ldGhvZCwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IG9wdGlvbnMgJiYgKG9wdGlvbnMgPSB7fSk7XG5cdCAgICAgICAgICAgIHZhciBfb3B0aW9ucyR0aGlzTmFtZXNwYWMgPSBvcHRpb25zLnRoaXNOYW1lc3BhY2UsIHRoaXNOYW1lc3BhY2UgPSB2b2lkIDAgIT09IF9vcHRpb25zJHRoaXNOYW1lc3BhYyAmJiBfb3B0aW9ucyR0aGlzTmFtZXNwYWMsIGNhY2hlVGltZSA9IG9wdGlvbnMudGltZTtcblx0ICAgICAgICAgICAgdmFyIHNpbXBsZUNhY2hlO1xuXHQgICAgICAgICAgICB2YXIgdGhpc0NhY2hlO1xuXHQgICAgICAgICAgICB2YXIgbWVtb2l6ZUluZGV4ID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuXHQgICAgICAgICAgICBtZW1vaXplR2xvYmFsSW5kZXggKz0gMTtcblx0ICAgICAgICAgICAgdmFyIG1lbW9pemVkRnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgICAgICAgICAgICAgIGlmIChtZW1vaXplSW5kZXggPCBtZW1vaXplR2xvYmFsSW5kZXhWYWxpZEZyb20pIHtcblx0ICAgICAgICAgICAgICAgICAgICBzaW1wbGVDYWNoZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc0NhY2hlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICBtZW1vaXplSW5kZXggPSBtZW1vaXplR2xvYmFsSW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4ICs9IDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY2FjaGU7XG5cdCAgICAgICAgICAgICAgICBjYWNoZSA9IHRoaXNOYW1lc3BhY2UgPyAodGhpc0NhY2hlID0gdGhpc0NhY2hlIHx8IG5ldyB3ZWFrbWFwX0Nyb3NzRG9tYWluU2FmZVdlYWtNYXApLmdldE9yU2V0KHRoaXMsIGdldEVtcHR5T2JqZWN0KSA6IHNpbXBsZUNhY2hlID0gc2ltcGxlQ2FjaGUgfHwge307XG5cdCAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXk7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5ID0gc2VyaWFsaXplQXJncyhhcmdzKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY2FjaGVSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FjaGVSZXN1bHQgJiYgY2FjaGVUaW1lICYmIERhdGUubm93KCkgLSBjYWNoZVJlc3VsdC50aW1lIDwgY2FjaGVUaW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2NhY2hlS2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYWNoZVJlc3VsdCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FjaGVSZXN1bHQpIHJldHVybiBjYWNoZVJlc3VsdC52YWx1ZTtcblx0ICAgICAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBtZW1vaXplZEZ1bmN0aW9uLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBzaW1wbGVDYWNoZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB0aGlzQ2FjaGUgPSBudWxsO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0RnVuY3Rpb25OYW1lKG1lbW9pemVkRnVuY3Rpb24sIChvcHRpb25zLm5hbWUgfHwgZ2V0RnVuY3Rpb25OYW1lKG1ldGhvZCkpICsgXCI6Om1lbW9pemVkXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtZW1vaXplLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIG1lbW9pemVHbG9iYWxJbmRleFZhbGlkRnJvbSA9IG1lbW9pemVHbG9iYWxJbmRleDtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIG1lbW9pemVQcm9taXNlKG1ldGhvZCkge1xuXHQgICAgICAgICAgICB2YXIgY2FjaGUgPSB7fTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cywgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5ID0gc2VyaWFsaXplQXJncyhhcmdzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gY2FjaGVba2V5XTtcblx0ICAgICAgICAgICAgICAgIGNhY2hlW2tleV0gPSBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoX3RoaXMsIF9hcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgfSkpLmZpbmFsbHkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24ucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGNhY2hlID0ge307XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUobWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24sIGdldEZ1bmN0aW9uTmFtZShtZXRob2QpICsgXCI6OnByb21pc2VNZW1vaXplZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3JjX3V0aWxfbm9vcCgpIHt9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyLCBsZXZlbCkge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGxldmVsICYmIChsZXZlbCA9IDEpO1xuXHQgICAgICAgICAgICBpZiAobGV2ZWwgPj0gMykgcmV0dXJuIFwic3RyaW5naWZ5RXJyb3Igc3RhY2sgb3ZlcmZsb3dcIjtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghZXJyKSByZXR1cm4gXCI8dW5rbm93biBlcnJvcjogXCIgKyB7fS50b1N0cmluZy5jYWxsKGVycikgKyBcIj5cIjtcblx0ICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlcnIpIHJldHVybiBlcnI7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnIgJiYgZXJyLnN0YWNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyICYmIGVyci5tZXNzYWdlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjayAmJiBtZXNzYWdlKSByZXR1cm4gLTEgIT09IHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPyBzdGFjayA6IG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrKSByZXR1cm4gc3RhY2s7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHJldHVybiBtZXNzYWdlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGVyciAmJiBlcnIudG9TdHJpbmcgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlcnIudG9TdHJpbmcgPyBlcnIudG9TdHJpbmcoKSA6IHt9LnRvU3RyaW5nLmNhbGwoZXJyKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAobmV3RXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvciB3aGlsZSBzdHJpbmdpZnlpbmcgZXJyb3I6IFwiICsgc3RyaW5naWZ5RXJyb3IobmV3RXJyLCBsZXZlbCArIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBpdGVtID8gaXRlbSA6IGl0ZW0gJiYgaXRlbS50b1N0cmluZyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZW0udG9TdHJpbmcgPyBpdGVtLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtZW1vaXplKChmdW5jdGlvbihvYmopIHtcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMpIHJldHVybiBPYmplY3QudmFsdWVzKG9iaik7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgb2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgcmVzdWx0LnB1c2gob2JqW2tleV0pO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBmdW5jdGlvbiB1dGlsX2lzUmVnZXgoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFJlZ0V4cF1cIiA9PT0ge30udG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gdXRpbF9nZXRPclNldChvYmosIGtleSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuIG9ialtrZXldO1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gZ2V0dGVyKCk7XG5cdCAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuXHQgICAgICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cdCAgICAgICAgICAgIGlmICghYm9keSkgdGhyb3cgbmV3IEVycm9yKFwiQm9keSBlbGVtZW50IG5vdCBmb3VuZFwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRSZWFkeSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZG9jdW1lbnQuYm9keSkgJiYgXCJjb21wbGV0ZVwiID09PSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc0RvY3VtZW50SW50ZXJhY3RpdmUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGRvY3VtZW50LmJvZHkpICYmIFwiaW50ZXJhY3RpdmVcIiA9PT0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpc0RvY3VtZW50UmVhZHkoKSB8fCBpc0RvY3VtZW50SW50ZXJhY3RpdmUoKSkgcmV0dXJuIHJlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkgfHwgaXNEb2N1bWVudEludGVyYWN0aXZlKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSksIDEwKTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICB2YXIgY3VycmVudFNjcmlwdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGRvY3VtZW50ID8gZG9jdW1lbnQuY3VycmVudFNjcmlwdCA6IG51bGw7XG5cdCAgICAgICAgdmFyIGdldEN1cnJlbnRTY3JpcHQgPSBtZW1vaXplKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JpcHQpIHJldHVybiBjdXJyZW50U2NyaXB0O1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudFNjcmlwdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyci5zdGFjayB8fCBcIlwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFja0RldGFpbHMgPSAvLiphdCBbXihdKlxcKCguKik6KC4rKTooLispXFwpJC9naS5leGVjKHN0YWNrKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0TG9jYXRpb24gPSBzdGFja0RldGFpbHMgJiYgc3RhY2tEZXRhaWxzWzFdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2NyaXB0TG9jYXRpb24pIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIyID0gMCwgX0FycmF5JHByb3RvdHlwZSRzbGljMiA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIikpLnJldmVyc2UoKTsgX2kyMiA8IF9BcnJheSRwcm90b3R5cGUkc2xpYzIubGVuZ3RoOyBfaTIyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcmlwdCA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbX2kyMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JpcHQuc3JjICYmIHNjcmlwdC5zcmMgPT09IHNjcmlwdExvY2F0aW9uKSByZXR1cm4gc2NyaXB0O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfSgpKSByZXR1cm4gY3VycmVudFNjcmlwdDtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXRlcm1pbmUgY3VycmVudCBzY3JpcHRcIik7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIHZhciBjdXJyZW50VUlEID0gdW5pcXVlSUQoKTtcblx0ICAgICAgICBtZW1vaXplKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHNjcmlwdDtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHNjcmlwdCA9IGdldEN1cnJlbnRTY3JpcHQoKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFVJRDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgdWlkID0gc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtdWlkXCIpO1xuXHQgICAgICAgICAgICBpZiAodWlkICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHVpZCkgcmV0dXJuIHVpZDtcblx0ICAgICAgICAgICAgaWYgKCh1aWQgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS11aWQtYXV0b1wiKSkgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdWlkKSByZXR1cm4gdWlkO1xuXHQgICAgICAgICAgICBpZiAoc2NyaXB0LnNyYykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGhhc2hlZFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSBzdHJbaV0uY2hhckNvZGVBdCgwKSAqIGk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0cltpICsgMV0gJiYgKHRvdGFsICs9IHN0cltpICsgMV0uY2hhckNvZGVBdCgwKSAqIChpIC0gMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBNYXRoLmFicyh0b3RhbCkgJSAyNik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgICAgICAgICAgfShKU09OLnN0cmluZ2lmeSh7XG5cdCAgICAgICAgICAgICAgICAgICAgc3JjOiBzY3JpcHQuc3JjLFxuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFzZXQ6IHNjcmlwdC5kYXRhc2V0XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB1aWQgPSBcInVpZF9cIiArIGhhc2hlZFN0cmluZy5zbGljZShoYXNoZWRTdHJpbmcubGVuZ3RoIC0gMzApO1xuXHQgICAgICAgICAgICB9IGVsc2UgdWlkID0gdW5pcXVlSUQoKTtcblx0ICAgICAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZShcImRhdGEtdWlkLWF1dG9cIiwgdWlkKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHVpZDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgZnVuY3Rpb24gZ2xvYmFsX2dldEdsb2JhbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHZhciBnbG9iYWxLZXkgPSBcIl9fcG9zdF9yb2JvdF8xMF8wXzQ2X19cIjtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbiAhPT0gd2luZG93ID8gd2luW2dsb2JhbEtleV0gOiB3aW5bZ2xvYmFsS2V5XSA9IHdpbltnbG9iYWxLZXldIHx8IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZ2V0T2JqID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIGdsb2JhbFN0b3JlKGtleSwgZGVmU3RvcmUpIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBrZXkgJiYgKGtleSA9IFwic3RvcmVcIik7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVmU3RvcmUgJiYgKGRlZlN0b3JlID0gZ2V0T2JqKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoZ2xvYmFsX2dldEdsb2JhbCgpLCBrZXksIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IGRlZlN0b3JlKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24oc3RvcmVLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmhhc093blByb3BlcnR5KHN0b3JlS2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oc3RvcmVLZXksIGRlZlZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuaGFzT3duUHJvcGVydHkoc3RvcmVLZXkpID8gc3RvcmVbc3RvcmVLZXldIDogZGVmVmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihzdG9yZUtleSwgdmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3N0b3JlS2V5XSA9IHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGRlbDogZnVuY3Rpb24oc3RvcmVLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0b3JlW3N0b3JlS2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldE9yU2V0OiBmdW5jdGlvbihzdG9yZUtleSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsX2dldE9yU2V0KHN0b3JlLCBzdG9yZUtleSwgZ2V0dGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSBkZWZTdG9yZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdG9yZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgV2lsZENhcmQgPSBmdW5jdGlvbigpIHt9O1xuXHQgICAgICAgIGZ1bmN0aW9uIGdldFdpbGRjYXJkKCkge1xuXHQgICAgICAgICAgICB2YXIgZ2xvYmFsID0gZ2xvYmFsX2dldEdsb2JhbCgpO1xuXHQgICAgICAgICAgICBnbG9iYWwuV0lORE9XX1dJTERDQVJEID0gZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCB8fCBuZXcgV2lsZENhcmQ7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWwuV0lORE9XX1dJTERDQVJEO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiB3aW5kb3dTdG9yZShrZXksIGRlZlN0b3JlKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0ga2V5ICYmIChrZXkgPSBcInN0b3JlXCIpO1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGRlZlN0b3JlICYmIChkZWZTdG9yZSA9IGdldE9iaik7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcIndpbmRvd1N0b3JlXCIpLmdldE9yU2V0KGtleSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpblN0b3JlID0gbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcblx0ICAgICAgICAgICAgICAgIHZhciBnZXRTdG9yZSA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5TdG9yZS5nZXRPclNldCh3aW4sIGRlZlN0b3JlKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRTdG9yZSh3aW4pLmhhc093blByb3BlcnR5KGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKHdpbiwgZGVmVmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IGdldFN0b3JlKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShrZXkpID8gc3RvcmVba2V5XSA6IGRlZlZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24od2luLCB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RvcmUod2luKVtrZXldID0gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsOiBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdldFN0b3JlKHdpbilba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldE9yU2V0OiBmdW5jdGlvbih3aW4sIGdldHRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF9nZXRPclNldChnZXRTdG9yZSh3aW4pLCBrZXksIGdldHRlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRJbnN0YW5jZUlEKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJpbnN0YW5jZVwiKS5nZXRPclNldChcImluc3RhbmNlSURcIiwgdW5pcXVlSUQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiByZXNvbHZlSGVsbG9Qcm9taXNlKHdpbiwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgZG9tYWluID0gX3JlZi5kb21haW47XG5cdCAgICAgICAgICAgIHZhciBoZWxsb1Byb21pc2VzID0gd2luZG93U3RvcmUoXCJoZWxsb1Byb21pc2VzXCIpO1xuXHQgICAgICAgICAgICB2YXIgZXhpc3RpbmdQcm9taXNlID0gaGVsbG9Qcm9taXNlcy5nZXQod2luKTtcblx0ICAgICAgICAgICAgZXhpc3RpbmdQcm9taXNlICYmIGV4aXN0aW5nUHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB2YXIgbmV3UHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUoe1xuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGhlbGxvUHJvbWlzZXMuc2V0KHdpbiwgbmV3UHJvbWlzZSk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdQcm9taXNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzYXlIZWxsbyh3aW4sIF9yZWY0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgX3JlZjQuc2VuZCkod2luLCBcInBvc3Ryb2JvdF9oZWxsb1wiLCB7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBnZXRJbnN0YW5jZUlEKClcblx0ICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBcIipcIixcblx0ICAgICAgICAgICAgICAgIHRpbWVvdXQ6IC0xXG5cdCAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gX3JlZjUub3JpZ2luLCBpbnN0YW5jZUlEID0gX3JlZjUuZGF0YS5pbnN0YW5jZUlEO1xuXHQgICAgICAgICAgICAgICAgcmVzb2x2ZUhlbGxvUHJvbWlzZSh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpblxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSUQ6IGluc3RhbmNlSURcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0V2luZG93SW5zdGFuY2VJRCh3aW4sIF9yZWY2KSB7XG5cdCAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjYuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwid2luZG93SW5zdGFuY2VJRFByb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNheUhlbGxvKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY3KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY3Lmluc3RhbmNlSUQ7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gbWFya1dpbmRvd0tub3duKHdpbikge1xuXHQgICAgICAgICAgICB3aW5kb3dTdG9yZShcImtub3duV2luZG93c1wiKS5zZXQod2luLCAhMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzU2VyaWFsaXplZFR5cGUoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgaXRlbSAmJiBudWxsICE9PSBpdGVtICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGl0ZW0uX190eXBlX187XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGRldGVybWluZVR5cGUodmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHZhbCA/IFwidW5kZWZpbmVkXCIgOiBudWxsID09PSB2YWwgPyBcIm51bGxcIiA6IEFycmF5LmlzQXJyYXkodmFsKSA/IFwiYXJyYXlcIiA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gXCJmdW5jdGlvblwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsID8gdmFsIGluc3RhbmNlb2YgRXJyb3IgPyBcImVycm9yXCIgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHZhbC50aGVuID8gXCJwcm9taXNlXCIgOiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKHZhbCkgPyBcInJlZ2V4XCIgOiBcIltvYmplY3QgRGF0ZV1cIiA9PT0ge30udG9TdHJpbmcuY2FsbCh2YWwpID8gXCJkYXRlXCIgOiBcIm9iamVjdFwiIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsID8gXCJzdHJpbmdcIiA6IFwibnVtYmVyXCIgPT0gdHlwZW9mIHZhbCA/IFwibnVtYmVyXCIgOiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgdmFsID8gXCJib29sZWFuXCIgOiB2b2lkIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVR5cGUodHlwZSwgdmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBfX3R5cGVfXzogdHlwZSxcblx0ICAgICAgICAgICAgICAgIF9fdmFsX186IHZhbFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgX1NFUklBTElaRVI7XG5cdCAgICAgICAgdmFyIFNFUklBTElaRVIgPSAoKF9TRVJJQUxJWkVSID0ge30pLmZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7fSwgX1NFUklBTElaRVIuZXJyb3IgPSBmdW5jdGlvbihfcmVmKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwiZXJyb3JcIiwge1xuXHQgICAgICAgICAgICAgICAgbWVzc2FnZTogX3JlZi5tZXNzYWdlLFxuXHQgICAgICAgICAgICAgICAgc3RhY2s6IF9yZWYuc3RhY2ssXG5cdCAgICAgICAgICAgICAgICBjb2RlOiBfcmVmLmNvZGUsXG5cdCAgICAgICAgICAgICAgICBkYXRhOiBfcmVmLmRhdGFcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIucHJvbWlzZSA9IGZ1bmN0aW9uKCkge30sIF9TRVJJQUxJWkVSLnJlZ2V4ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwicmVnZXhcIiwgdmFsLnNvdXJjZSk7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIuZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImRhdGVcIiwgdmFsLnRvSlNPTigpKTtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5hcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLm9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLnN0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLm51bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLmJvb2xlYW4gPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5udWxsID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVJbdm9pZCAwXSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcInVuZGVmaW5lZFwiLCB2YWwpO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSKTtcblx0ICAgICAgICB2YXIgZGVmYXVsdFNlcmlhbGl6ZXJzID0ge307XG5cdCAgICAgICAgdmFyIF9ERVNFUklBTElaRVI7XG5cdCAgICAgICAgdmFyIERFU0VSSUFMSVpFUiA9ICgoX0RFU0VSSUFMSVpFUiA9IHt9KS5mdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzZXJpYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZDsgbm90aGluZyB0byBkZXNlcmlhbGl6ZVwiKTtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmVycm9yID0gZnVuY3Rpb24oX3JlZjIpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YWNrID0gX3JlZjIuc3RhY2ssIGNvZGUgPSBfcmVmMi5jb2RlLCBkYXRhID0gX3JlZjIuZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKF9yZWYyLm1lc3NhZ2UpO1xuXHQgICAgICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcblx0ICAgICAgICAgICAgZGF0YSAmJiAoZXJyb3IuZGF0YSA9IGRhdGEpO1xuXHQgICAgICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrICsgXCJcXG5cXG5cIiArIGVycm9yLnN0YWNrO1xuXHQgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5wcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb21pc2Ugc2VyaWFsaXphdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQ7IG5vdGhpbmcgdG8gZGVzZXJpYWxpemVcIik7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5yZWdleCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh2YWwpO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsKTtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmFycmF5ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLnN0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIubnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5ib29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5udWxsID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUlt2b2lkIDBdID0gZnVuY3Rpb24oKSB7fSwgX0RFU0VSSUFMSVpFUik7XG5cdCAgICAgICAgdmFyIGRlZmF1bHREZXNlcmlhbGl6ZXJzID0ge307XG5cdCAgICAgICAgbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmJvZHkpIHJldHVybiByZXNvbHZlKHdpbmRvdy5kb2N1bWVudC5ib2R5KTtcblx0ICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHdpbmRvdy5kb2N1bWVudC5ib2R5KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSksIDEwKTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgZnVuY3Rpb24gY2xlYW51cFByb3h5V2luZG93cygpIHtcblx0ICAgICAgICAgICAgdmFyIGlkVG9Qcm94eVdpbmRvdyA9IGdsb2JhbFN0b3JlKFwiaWRUb1Byb3h5V2luZG93XCIpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfaWRUb1Byb3h5V2luZG93JGtleXMyID0gaWRUb1Byb3h5V2luZG93LmtleXMoKTsgX2kyIDwgX2lkVG9Qcm94eVdpbmRvdyRrZXlzMi5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaWQgPSBfaWRUb1Byb3h5V2luZG93JGtleXMyW19pMl07XG5cdCAgICAgICAgICAgICAgICBpZFRvUHJveHlXaW5kb3cuZ2V0KGlkKS5zaG91bGRDbGVhbigpICYmIGlkVG9Qcm94eVdpbmRvdy5kZWwoaWQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFNlcmlhbGl6ZWRXaW5kb3cod2luUHJvbWlzZSwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYuc2VuZCwgX3JlZiRpZCA9IF9yZWYuaWQsIGlkID0gdm9pZCAwID09PSBfcmVmJGlkID8gdW5pcXVlSUQoKSA6IF9yZWYkaWQ7XG5cdCAgICAgICAgICAgIHZhciB3aW5kb3dOYW1lUHJvbWlzZSA9IHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNTYW1lRG9tYWluKHdpbikpIHJldHVybiBhc3NlcnRTYW1lRG9tYWluKHdpbikubmFtZTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB2YXIgd2luZG93VHlwZVByb21pc2UgPSB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbmRvdykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbmRvdykpIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBpcyBjbG9zZWQsIGNhbiBub3QgZGV0ZXJtaW5lIHR5cGVcIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T3BlbmVyKHdpbmRvdykgPyBcInBvcHVwXCIgOiBcImlmcmFtZVwiO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHdpbmRvd05hbWVQcm9taXNlLmNhdGNoKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgICAgICB3aW5kb3dUeXBlUHJvbWlzZS5jYXRjaChzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICAgICAgdmFyIGdldE5hbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaW5kb3dDbG9zZWQod2luKSkgcmV0dXJuIGlzU2FtZURvbWFpbih3aW4pID8gYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWUgOiB3aW5kb3dOYW1lUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dUeXBlUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBnZXRJbnN0YW5jZUlEOiBtZW1vaXplUHJvbWlzZSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRXaW5kb3dJbnN0YW5jZUlEKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSksXG5cdCAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbihjbG9zZVdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgZ2V0TmFtZTogZ2V0TmFtZSxcblx0ICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luLmZvY3VzKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGlzQ2xvc2VkOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2luZG93Q2xvc2VkKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHNldExvY2F0aW9uOiBmdW5jdGlvbihocmVmLCBvcHRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBvcHRzICYmIChvcHRzID0ge30pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfb3B0cyRtZXRob2QgPSBvcHRzLm1ldGhvZCwgbWV0aG9kID0gdm9pZCAwID09PSBfb3B0cyRtZXRob2QgPyBcImdldFwiIDogX29wdHMkbWV0aG9kLCBib2R5ID0gb3B0cy5ib2R5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gaHJlZi5pbmRleE9mKFwiL1wiKSkgaHJlZiA9IFwiXCIgKyBkb21haW4gKyBocmVmOyBlbHNlIGlmICghaHJlZi5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vKSAmJiAwICE9PSBocmVmLmluZGV4T2YoZG9tYWluKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdXJsIHRvIGJlIGh0dHAgb3IgaHR0cHMgdXJsLCBvciBhYnNvbHV0ZSBwYXRoLCBnb3QgXCIgKyBKU09OLnN0cmluZ2lmeShocmVmKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInBvc3RcIiA9PT0gbWV0aG9kKSByZXR1cm4gZ2V0TmFtZSgpLnRoZW4oKGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBwb3N0IHRvIHdpbmRvdyB3aXRob3V0IHRhcmdldCBuYW1lXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKF9yZWYzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IF9yZWYzLnVybCwgdGFyZ2V0ID0gX3JlZjMudGFyZ2V0LCBib2R5ID0gX3JlZjMuYm9keSwgX3JlZjMkbWV0aG9kID0gX3JlZjMubWV0aG9kLCBtZXRob2QgPSB2b2lkIDAgPT09IF9yZWYzJG1ldGhvZCA/IFwicG9zdFwiIDogX3JlZjMkbWV0aG9kO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZShcIm1ldGhvZFwiLCBtZXRob2QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwiYWN0aW9uXCIsIHVybCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkpIGZvciAodmFyIF9pMjQgPSAwLCBfT2JqZWN0JGtleXM0ID0gT2JqZWN0LmtleXMoYm9keSk7IF9pMjQgPCBfT2JqZWN0JGtleXM0Lmxlbmd0aDsgX2kyNCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYm9keSRrZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXM0W19pMjRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwga2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgbnVsbCA9PSAoX2JvZHkka2V5ID0gYm9keVtrZXldKSA/IHZvaWQgMCA6IF9ib2R5JGtleS50b1N0cmluZygpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChpbnB1dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJvZHkoKS5hcHBlbmRDaGlsZChmb3JtKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJvZHkoKS5yZW1vdmVDaGlsZChmb3JtKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogaHJlZixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZ2V0XCIgIT09IG1ldGhvZCkgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgbWV0aG9kOiBcIiArIG1ldGhvZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWVEb21haW4od2luKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4ubG9jYXRpb24gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW4ubG9jYXRpb24ucmVwbGFjZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW4ubG9jYXRpb24gPSBocmVmO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBzZXROYW1lOiBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYW1lRG9tYWluID0gaXNTYW1lRG9tYWluKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGdldEZyYW1lRm9yV2luZG93KHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2FtZURvbWFpbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZXQgbmFtZSBmb3IgY3Jvc3MtZG9tYWluIHdpbmRvdzogXCIgKyBuYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWUgPSBuYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSAmJiBmcmFtZS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dOYW1lUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUobmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgd2luZG93X1Byb3h5V2luZG93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIFByb3h5V2luZG93KF9yZWYyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYyLnNlbmQsIHdpbiA9IF9yZWYyLndpbiwgc2VyaWFsaXplZFdpbmRvdyA9IF9yZWYyLnNlcmlhbGl6ZWRXaW5kb3c7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlkID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pc1Byb3h5V2luZG93ID0gITA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvdyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VuZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZFdpbmRvdyA9IHNlcmlhbGl6ZWRXaW5kb3cgfHwgZ2V0U2VyaWFsaXplZFdpbmRvdyh0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwiaWRUb1Byb3h5V2luZG93XCIpLnNldCh0aGlzLmdldElEKCksIHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgd2luICYmIHRoaXMuc2V0V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcHJvdG8gPSBQcm94eVdpbmRvdy5wcm90b3R5cGU7XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRJRCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5pZDtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldFR5cGUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZ2V0VHlwZSgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uaXNQb3B1cCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnRoZW4oKGZ1bmN0aW9uKHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwb3B1cFwiID09PSB0eXBlO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2V0TG9jYXRpb24gPSBmdW5jdGlvbihocmVmLCBvcHRzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5zZXRMb2NhdGlvbihocmVmLCBvcHRzKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXROYW1lID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldE5hbWUoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNldE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuc2V0TmFtZShuYW1lKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5jbG9zZSgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczM7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgaXNQb3B1cFByb21pc2UgPSB0aGlzLmlzUG9wdXAoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBnZXROYW1lUHJvbWlzZSA9IHRoaXMuZ2V0TmFtZSgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlb3BlblByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICBpc1BvcHVwOiBpc1BvcHVwUHJvbWlzZSxcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZXROYW1lUHJvbWlzZVxuXHQgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgX3JlZjMuaXNQb3B1cCAmJiBuYW1lICYmIHdpbmRvdy5vcGVuKFwiXCIsIG5hbWUsIFwibm9vcGVuZXJcIik7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgZm9jdXNQcm9taXNlID0gdGhpcy5zZXJpYWxpemVkV2luZG93LmZvY3VzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuYWxsKFsgcmVvcGVuUHJvbWlzZSwgZm9jdXNQcm9taXNlIF0pLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczQ7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5pc0Nsb3NlZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5pc0Nsb3NlZCgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0V2luZG93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaW5kb3c7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXRXaW5kb3cgPSBmdW5jdGlvbih3aW4sIF9yZWY0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY0LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvdyA9IHdpbjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZS5yZXNvbHZlKHRoaXMuYWN0dWFsV2luZG93KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZFdpbmRvdyA9IGdldFNlcmlhbGl6ZWRXaW5kb3codGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZCxcblx0ICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5nZXRJRCgpXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHdpbmRvd1N0b3JlKFwid2luVG9Qcm94eVdpbmRvd1wiKS5zZXQod2luLCB0aGlzKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmF3YWl0V2luZG93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8ubWF0Y2hXaW5kb3cgPSBmdW5jdGlvbih3aW4sIF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjUuc2VuZDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczUuYWN0dWFsV2luZG93ID8gd2luID09PSBfdGhpczUuYWN0dWFsV2luZG93IDogcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5SW5zdGFuY2VJRDogX3RoaXM1LmdldEluc3RhbmNlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAga25vd25XaW5kb3dJbnN0YW5jZUlEOiBnZXRXaW5kb3dJbnN0YW5jZUlEKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IF9yZWY2LnByb3h5SW5zdGFuY2VJRCA9PT0gX3JlZjYua25vd25XaW5kb3dJbnN0YW5jZUlEO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCAmJiBfdGhpczUuc2V0V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnVud3JhcCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsV2luZG93IHx8IHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRJbnN0YW5jZUlEID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldEluc3RhbmNlSUQoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNob3VsZENsZWFuID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmFjdHVhbFdpbmRvdyAmJiBpc1dpbmRvd0Nsb3NlZCh0aGlzLmFjdHVhbFdpbmRvdykpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy51bndyYXAgPSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbikgPyB3aW4udW53cmFwKCkgOiB3aW47XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHdpbiwgX3JlZjcpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjcuc2VuZDtcblx0ICAgICAgICAgICAgICAgIGNsZWFudXBQcm94eVdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pLnNlcmlhbGl6ZSgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRXaW5kb3csIF9yZWY4KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY4LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJpZFRvUHJveHlXaW5kb3dcIikuZ2V0KHNlcmlhbGl6ZWRXaW5kb3cuaWQpIHx8IG5ldyBQcm94eVdpbmRvdyh7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZFdpbmRvdzogc2VyaWFsaXplZFdpbmRvdyxcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqICYmICFpc1dpbmRvdyhvYmopICYmIG9iai5pc1Byb3h5V2luZG93KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyA9IGZ1bmN0aW9uKHdpbiwgX3JlZjkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjkuc2VuZDtcblx0ICAgICAgICAgICAgICAgIGNsZWFudXBQcm94eVdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIGlmIChQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbikpIHJldHVybiB3aW47XG5cdCAgICAgICAgICAgICAgICB2YXIgYWN0dWFsV2luZG93ID0gd2luO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwid2luVG9Qcm94eVdpbmRvd1wiKS5nZXQoYWN0dWFsV2luZG93KSB8fCBuZXcgUHJveHlXaW5kb3coe1xuXHQgICAgICAgICAgICAgICAgICAgIHdpbjogYWN0dWFsV2luZG93LFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gUHJveHlXaW5kb3c7XG5cdCAgICAgICAgfSgpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGFkZE1ldGhvZChpZCwgdmFsLCBuYW1lLCBzb3VyY2UsIGRvbWFpbikge1xuXHQgICAgICAgICAgICB2YXIgbWV0aG9kU3RvcmUgPSB3aW5kb3dTdG9yZShcIm1ldGhvZFN0b3JlXCIpO1xuXHQgICAgICAgICAgICB2YXIgcHJveHlXaW5kb3dNZXRob2RzID0gZ2xvYmFsU3RvcmUoXCJwcm94eVdpbmRvd01ldGhvZHNcIik7XG5cdCAgICAgICAgICAgIGlmICh3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyhzb3VyY2UpKSBwcm94eVdpbmRvd01ldGhvZHMuc2V0KGlkLCB7XG5cdCAgICAgICAgICAgICAgICB2YWw6IHZhbCxcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG5cdCAgICAgICAgICAgIH0pOyBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHByb3h5V2luZG93TWV0aG9kcy5kZWwoaWQpO1xuXHQgICAgICAgICAgICAgICAgbWV0aG9kU3RvcmUuZ2V0T3JTZXQoc291cmNlLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICAgICAgfSkpW2lkXSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbDogdmFsLFxuXHQgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGxvb2t1cE1ldGhvZChzb3VyY2UsIGlkKSB7XG5cdCAgICAgICAgICAgIHZhciBtZXRob2RTdG9yZSA9IHdpbmRvd1N0b3JlKFwibWV0aG9kU3RvcmVcIik7XG5cdCAgICAgICAgICAgIHZhciBwcm94eVdpbmRvd01ldGhvZHMgPSBnbG9iYWxTdG9yZShcInByb3h5V2luZG93TWV0aG9kc1wiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG1ldGhvZFN0b3JlLmdldE9yU2V0KHNvdXJjZSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICB9KSlbaWRdIHx8IHByb3h5V2luZG93TWV0aG9kcy5nZXQoaWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBmdW5jdGlvbl9zZXJpYWxpemVGdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCB2YWwsIGtleSwgX3JlZjMpIHtcblx0ICAgICAgICAgICAgb24gPSAoX3JlZiA9IHtcblx0ICAgICAgICAgICAgICAgIG9uOiBfcmVmMy5vbixcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IF9yZWYzLnNlbmRcblx0ICAgICAgICAgICAgfSkub24sIHNlbmQgPSBfcmVmLnNlbmQsIGdsb2JhbFN0b3JlKFwiYnVpbHRpbkxpc3RlbmVyc1wiKS5nZXRPclNldChcImZ1bmN0aW9uQ2FsbHNcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG9uKFwicG9zdHJvYm90X21ldGhvZFwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBcIipcIlxuXHQgICAgICAgICAgICAgICAgfSwgKGZ1bmN0aW9uKF9yZWYyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IF9yZWYyLnNvdXJjZSwgb3JpZ2luID0gX3JlZjIub3JpZ2luLCBkYXRhID0gX3JlZjIuZGF0YTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBkYXRhLmlkLCBuYW1lID0gZGF0YS5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXRoID0gbG9va3VwTWV0aG9kKHNvdXJjZSwgaWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbWV0aCkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgbWV0aG9kICdcIiArIG5hbWUgKyBcIicgd2l0aCBpZDogXCIgKyBkYXRhLmlkICsgXCIgaW4gXCIgKyBnZXREb21haW4od2luZG93KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZFNvdXJjZSA9IG1ldGguc291cmNlLCBkb21haW4gPSBtZXRoLmRvbWFpbiwgdmFsID0gbWV0aC52YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4oZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2QgJ1wiICsgZGF0YS5uYW1lICsgXCInIGRvbWFpbiBcIiArIEpTT04uc3RyaW5naWZ5KHV0aWxfaXNSZWdleChtZXRoLmRvbWFpbikgPyBtZXRoLmRvbWFpbi5zb3VyY2UgOiBtZXRoLmRvbWFpbikgKyBcIiBkb2VzIG5vdCBtYXRjaCBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIGdldERvbWFpbih3aW5kb3cpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KG1ldGhvZFNvdXJjZSkpIHJldHVybiBtZXRob2RTb3VyY2UubWF0Y2hXaW5kb3coc291cmNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKG1hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2QgY2FsbCAnXCIgKyBkYXRhLm5hbWUgKyBcIicgZmFpbGVkIC0gcHJveHkgd2luZG93IGRvZXMgbm90IG1hdGNoIHNvdXJjZSBpbiBcIiArIGdldERvbWFpbih3aW5kb3cpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5hcHBseSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRhdGEuYXJncyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsLm9uRXJyb3IpIHJldHVybiB2YWwub25FcnJvcihlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuc3RhY2sgJiYgKGVyci5zdGFjayA9IFwiUmVtb3RlIGNhbGwgdG8gXCIgKyBuYW1lICsgXCIoXCIgKyBmdW5jdGlvbihhcmdzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBhcmdzICYmIChhcmdzID0gW10pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXRlbSA9IGFyZ3MsIFtdLnNsaWNlLmNhbGwoaXRlbSkpLm1hcCgoZnVuY3Rpb24oYXJnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBhcmcgPyBcIidcIiArIGFyZyArIFwiJ1wiIDogdm9pZCAwID09PSBhcmcgPyBcInVuZGVmaW5lZFwiIDogbnVsbCA9PT0gYXJnID8gXCJudWxsXCIgOiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgYXJnID8gYXJnLnRvU3RyaW5nKCkgOiBBcnJheS5pc0FycmF5KGFyZykgPyBcIlsgLi4uIF1cIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGFyZyA/IFwieyAuLi4gfVwiIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBhcmcgPyBcIigpID0+IHsgLi4uIH1cIiA6IFwiPFwiICsgdHlwZW9mIGFyZyArIFwiPlwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5qb2luKFwiLCBcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGRhdGEuYXJncykgKyBcIikgZmFpbGVkXFxuXFxuXCIgKyBlcnIuc3RhY2spO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHZhciBfcmVmLCBvbiwgc2VuZDtcblx0ICAgICAgICAgICAgdmFyIGlkID0gdmFsLl9faWRfXyB8fCB1bmlxdWVJRCgpO1xuXHQgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IHdpbmRvd19Qcm94eVdpbmRvdy51bndyYXAoZGVzdGluYXRpb24pO1xuXHQgICAgICAgICAgICB2YXIgbmFtZSA9IHZhbC5fX25hbWVfXyB8fCB2YWwubmFtZSB8fCBrZXk7XG5cdCAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIG5hbWUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBuYW1lLmluZGV4T2YgJiYgMCA9PT0gbmFtZS5pbmRleE9mKFwiYW5vbnltb3VzOjpcIikgJiYgKG5hbWUgPSBuYW1lLnJlcGxhY2UoXCJhbm9ueW1vdXM6OlwiLCBrZXkgKyBcIjo6XCIpKTtcblx0ICAgICAgICAgICAgaWYgKHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KGRlc3RpbmF0aW9uKSkge1xuXHQgICAgICAgICAgICAgICAgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIGRlc3RpbmF0aW9uLCBkb21haW4pO1xuXHQgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgd2luLCBkb21haW4pO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9IGVsc2UgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIGRlc3RpbmF0aW9uLCBkb21haW4pO1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImNyb3NzX2RvbWFpbl9mdW5jdGlvblwiLCB7XG5cdCAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVNZXNzYWdlKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaiwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgX3NlcmlhbGl6ZTtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZi5vbiwgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgc2VyaWFsaXplcnMpIHtcblx0ICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gc2VyaWFsaXplcnMgJiYgKHNlcmlhbGl6ZXJzID0gZGVmYXVsdFNlcmlhbGl6ZXJzKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShvYmosIChmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpc1trZXldO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRUeXBlKHRoaXMpKSByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZGV0ZXJtaW5lVHlwZSh2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdHlwZSkgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplciA9IHNlcmlhbGl6ZXJzW3R5cGVdIHx8IFNFUklBTElaRVJbdHlwZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPyBzZXJpYWxpemVyKHZhbCwga2V5KSA6IHZhbDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHJlc3VsdCA/IFwidW5kZWZpbmVkXCIgOiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH0ob2JqLCAoKF9zZXJpYWxpemUgPSB7fSkucHJvbWlzZSA9IGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIF9yZWYpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImNyb3NzX2RvbWFpbl96YWxnb19wcm9taXNlXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhlbjogZnVuY3Rpb25fc2VyaWFsaXplRnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBrZXksIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBfcmVmLm9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogX3JlZi5zZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCBfc2VyaWFsaXplLmZ1bmN0aW9uID0gZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbl9zZXJpYWxpemVGdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCB2YWwsIGtleSwge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZS5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpc1dpbmRvdyh2YWwpIHx8IHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHZhbCkgPyBzZXJpYWxpemVUeXBlKFwiY3Jvc3NfZG9tYWluX3dpbmRvd1wiLCB3aW5kb3dfUHJveHlXaW5kb3cuc2VyaWFsaXplKHZhbCwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pKSA6IHZhbDtcblx0ICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIF9yZWYyKSB7XG5cdCAgICAgICAgICAgIHZhciBfZGVzZXJpYWxpemU7XG5cdCAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjIuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgZGVzZXJpYWxpemVycykge1xuXHQgICAgICAgICAgICAgICAgdm9pZCAwID09PSBkZXNlcmlhbGl6ZXJzICYmIChkZXNlcmlhbGl6ZXJzID0gZGVmYXVsdERlc2VyaWFsaXplcnMpO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHN0cikgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLCAoZnVuY3Rpb24oa2V5LCB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh0aGlzKSkgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFR5cGUodmFsKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gdmFsLl9fdHlwZV9fO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbC5fX3ZhbF9fO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBkZXRlcm1pbmVUeXBlKHZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGUpIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVzZXJpYWxpemVyID0gZGVzZXJpYWxpemVyc1t0eXBlXSB8fCBERVNFUklBTElaRVJbdHlwZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplciA/IGRlc2VyaWFsaXplcih2YWx1ZSwga2V5KSA6IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KG1lc3NhZ2UsICgoX2Rlc2VyaWFsaXplID0ge30pLmNyb3NzX2RvbWFpbl96YWxnb19wcm9taXNlID0gZnVuY3Rpb24oc2VyaWFsaXplZFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIG9yaWdpbiwgX3JlZjIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKF9yZWYyLnRoZW4pO1xuXHQgICAgICAgICAgICAgICAgfSgwLCAwLCBzZXJpYWxpemVkUHJvbWlzZSk7XG5cdCAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZS5jcm9zc19kb21haW5fZnVuY3Rpb24gPSBmdW5jdGlvbihzZXJpYWxpemVkRnVuY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIG9yaWdpbiwgX3JlZjQsIF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gX3JlZjQuaWQsIG5hbWUgPSBfcmVmNC5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjUuc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0RGVzZXJpYWxpemVkRnVuY3Rpb24gPSBmdW5jdGlvbihvcHRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0cyAmJiAob3B0cyA9IHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyhzb3VyY2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5hd2FpdFdpbmRvdygpLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRoID0gbG9va3VwTWV0aG9kKHdpbiwgaWQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRoICYmIG1ldGgudmFsICE9PSBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcikgcmV0dXJuIG1ldGgudmFsLmFwcGx5KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB3aW5kb3csXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2FyZ3MgPSBbXS5zbGljZS5jYWxsKF9hcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRzLmZpcmVBbmRGb3JnZXQgPyBzZW5kKHdpbiwgXCJwb3N0cm9ib3RfbWV0aG9kXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBfYXJnc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICEwXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBzZW5kKHdpbiwgXCJwb3N0cm9ib3RfbWV0aG9kXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBfYXJnc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICExXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuZGF0YS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19uYW1lX18gPSBuYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX29yaWdpbl9fID0gb3JpZ2luO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX3NvdXJjZV9fID0gc291cmNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX2lkX18gPSBpZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIub3JpZ2luID0gb3JpZ2luO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIgPSBnZXREZXNlcmlhbGl6ZWRGdW5jdGlvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLmZpcmVBbmRGb3JnZXQgPSBnZXREZXNlcmlhbGl6ZWRGdW5jdGlvbih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICEwXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyO1xuXHQgICAgICAgICAgICAgICAgfShzb3VyY2UsIG9yaWdpbiwgc2VyaWFsaXplZEZ1bmN0aW9uLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZS5jcm9zc19kb21haW5fd2luZG93ID0gZnVuY3Rpb24oc2VyaWFsaXplZFdpbmRvdykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy5kZXNlcmlhbGl6ZShzZXJpYWxpemVkV2luZG93LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgU0VORF9NRVNTQUdFX1NUUkFURUdJRVMgPSB7fTtcblx0ICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFUy5wb3N0cm9ib3RfcG9zdF9tZXNzYWdlID0gZnVuY3Rpb24od2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKSB7XG5cdCAgICAgICAgICAgIDAgPT09IGRvbWFpbi5pbmRleE9mKFwiZmlsZTpcIikgJiYgKGRvbWFpbiA9IFwiKlwiKTtcblx0ICAgICAgICAgICAgd2luLnBvc3RNZXNzYWdlKHNlcmlhbGl6ZWRNZXNzYWdlLCBkb21haW4pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZnVuY3Rpb24gc2VuZF9zZW5kTWVzc2FnZSh3aW4sIGRvbWFpbiwgbWVzc2FnZSwgX3JlZjIpIHtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZjIub24sIHNlbmQgPSBfcmVmMi5zZW5kO1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBkb21haW5CdWZmZXIgPSB3aW5kb3dTdG9yZSgpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbkJ1ZmZlci5idWZmZXIgPSBkb21haW5CdWZmZXIuYnVmZmVyIHx8IFtdO1xuXHQgICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmZsdXNoID0gZG9tYWluQnVmZmVyLmZsdXNoIHx8IHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbikpIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBpcyBjbG9zZWRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRNZXNzYWdlID0gc2VyaWFsaXplTWVzc2FnZSh3aW4sIGRvbWFpbiwgKChfcmVmID0ge30pLl9fcG9zdF9yb2JvdF8xMF8wXzQ2X18gPSBkb21haW5CdWZmZXIuYnVmZmVyIHx8IFtdLCBcblx0ICAgICAgICAgICAgICAgICAgICBfcmVmKSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluQnVmZmVyLmJ1ZmZlcjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RyYXRlZ2llcyA9IE9iamVjdC5rZXlzKFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc3RyYXRlZ2llcy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJhdGVneU5hbWUgPSBzdHJhdGVnaWVzW19pMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFU1tzdHJhdGVneU5hbWVdKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gc3RyYXRlZ2llcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIkFsbCBwb3N0LXJvYm90IG1lc3NhZ2luZyBzdHJhdGVnaWVzIGZhaWxlZDpcXG5cXG5cIiArIGVycm9ycy5tYXAoKGZ1bmN0aW9uKGVyciwgaSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSArIFwiLiBcIiArIHN0cmluZ2lmeUVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpLmpvaW4oXCJcXG5cXG5cIikpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkJ1ZmZlci5mbHVzaC50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluQnVmZmVyLmZsdXNoO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KSkudGhlbihzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0UmVzcG9uc2VMaXN0ZW5lcihoYXNoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpLmdldChoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcihoYXNoKSB7XG5cdCAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuZGVsKGhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkKGhhc2gpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzXCIpLmhhcyhoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0UmVxdWVzdExpc3RlbmVyKF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsIHdpbiA9IF9yZWYud2luLCBkb21haW4gPSBfcmVmLmRvbWFpbjtcblx0ICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lcnMgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RMaXN0ZW5lcnNcIik7XG5cdCAgICAgICAgICAgIFwiKlwiID09PSB3aW4gJiYgKHdpbiA9IG51bGwpO1xuXHQgICAgICAgICAgICBcIipcIiA9PT0gZG9tYWluICYmIChkb21haW4gPSBudWxsKTtcblx0ICAgICAgICAgICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIHJlcXVpcmVkIHRvIGdldCByZXF1ZXN0IGxpc3RlbmVyXCIpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfcmVmMyA9IFsgd2luLCBnZXRXaWxkY2FyZCgpIF07IF9pNCA8IF9yZWYzLmxlbmd0aDsgX2k0KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5RdWFsaWZpZXIgPSBfcmVmM1tfaTRdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpblF1YWxpZmllcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lTGlzdGVuZXJzID0gcmVxdWVzdExpc3RlbmVycy5nZXQod2luUXVhbGlmaWVyKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobmFtZUxpc3RlbmVycykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluTGlzdGVuZXJzID0gbmFtZUxpc3RlbmVyc1tuYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVycykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzW2RvbWFpbl0pIHJldHVybiBkb21haW5MaXN0ZW5lcnNbZG9tYWluXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzLl9fZG9tYWluX3JlZ2V4X18pIGZvciAodmFyIF9pNiA9IDAsIF9kb21haW5MaXN0ZW5lcnMkX19ETzIgPSBkb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXzsgX2k2IDwgX2RvbWFpbkxpc3RlbmVycyRfX0RPMi5sZW5ndGg7IF9pNisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZG9tYWluTGlzdGVuZXJzJF9fRE8zID0gX2RvbWFpbkxpc3RlbmVycyRfX0RPMltfaTZdLCBsaXN0ZW5lciA9IF9kb21haW5MaXN0ZW5lcnMkX19ETzMubGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaERvbWFpbihfZG9tYWluTGlzdGVuZXJzJF9fRE8zLnJlZ2V4LCBkb21haW4pKSByZXR1cm4gbGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVyc1tcIipcIl0pIHJldHVybiBkb21haW5MaXN0ZW5lcnNbXCIqXCJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3Qoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZi5vbiwgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lLFxuXHQgICAgICAgICAgICAgICAgd2luOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpblxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdmFyIGxvZ05hbWUgPSBcInBvc3Ryb2JvdF9tZXRob2RcIiA9PT0gbWVzc2FnZS5uYW1lICYmIG1lc3NhZ2UuZGF0YSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBtZXNzYWdlLmRhdGEubmFtZSA/IG1lc3NhZ2UuZGF0YS5uYW1lICsgXCIoKVwiIDogbWVzc2FnZS5uYW1lO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzZW5kUmVzcG9uc2UoYWNrLCBkYXRhLCBlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmZpcmVBbmRGb3JnZXQgJiYgIWlzV2luZG93Q2xvc2VkKHNvdXJjZSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdW5pcXVlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKHdpbmRvdyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3Jlc3BvbnNlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBtZXNzYWdlLmhhc2gsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2s6IGFjayxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3Jcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZCByZXNwb25zZSBtZXNzYWdlIGZhaWxlZCBmb3IgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiXFxuXFxuXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmFsbChbIHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuZmlyZUFuZEZvcmdldCAmJiAhaXNXaW5kb3dDbG9zZWQoc291cmNlKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZF9zZW5kTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZDogdW5pcXVlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4od2luZG93KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb3N0cm9ib3RfbWVzc2FnZV9hY2tcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogbWVzc2FnZS5oYXNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWVcblx0ICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZCBhY2sgbWVzc2FnZSBmYWlsZWQgZm9yIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIlxcblxcblwiICsgc3RyaW5naWZ5RXJyb3IoZXJyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pKSwgcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKFwiTm8gaGFuZGxlciBmb3VuZCBmb3IgcG9zdCBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmhhbmRsZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFJlc3BvbnNlKFwic3VjY2Vzc1wiLCBkYXRhKTtcblx0ICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZShcImVycm9yXCIsIG51bGwsIGVycm9yKTtcblx0ICAgICAgICAgICAgfSkpIF0pLnRoZW4oc3JjX3V0aWxfbm9vcCkuY2F0Y2goKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVFcnJvcikgcmV0dXJuIG9wdGlvbnMuaGFuZGxlRXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBoYW5kbGVBY2soc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgaWYgKCFpc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkKG1lc3NhZ2UuaGFzaCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0UmVzcG9uc2VMaXN0ZW5lcihtZXNzYWdlLmhhc2gpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgYWNrIGZvciBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbihvcHRpb25zLmRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQWNrIG9yaWdpbiBcIiArIG9yaWdpbiArIFwiIGRvZXMgbm90IG1hdGNoIGRvbWFpbiBcIiArIG9wdGlvbnMuZG9tYWluLnRvU3RyaW5nKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IG9wdGlvbnMud2luKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2sgc291cmNlIGRvZXMgbm90IG1hdGNoIHJlZ2lzdGVyZWQgd2luZG93XCIpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5hY2sgPSAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkge1xuXHQgICAgICAgICAgICBpZiAoIWlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQobWVzc2FnZS5oYXNoKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZSByZXNwb25zZSBmb3IgbWVzc2FnZTogXCIgKyBtZXNzYWdlLm5hbWUgKyBcIiBmcm9tIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKG9wdGlvbnMuZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyAocGF0dGVybiA9IG9wdGlvbnMuZG9tYWluLCBcblx0ICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGF0dGVybikgPyBcIihcIiArIHBhdHRlcm4uam9pbihcIiB8IFwiKSArIFwiKVwiIDogaXNSZWdleChwYXR0ZXJuKSA/IFwiUmVnRXhwKFwiICsgcGF0dGVybi50b1N0cmluZygpICsgXCIpXCIgOiBwYXR0ZXJuLnRvU3RyaW5nKCkpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuO1xuXHQgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gb3B0aW9ucy53aW4pIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHNvdXJjZSBkb2VzIG5vdCBtYXRjaCByZWdpc3RlcmVkIHdpbmRvd1wiKTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZVJlc3BvbnNlTGlzdGVuZXIobWVzc2FnZS5oYXNoKTtcblx0ICAgICAgICAgICAgICAgIFwiZXJyb3JcIiA9PT0gbWVzc2FnZS5hY2sgPyBvcHRpb25zLnByb21pc2UucmVqZWN0KG1lc3NhZ2UuZXJyb3IpIDogXCJzdWNjZXNzXCIgPT09IG1lc3NhZ2UuYWNrICYmIG9wdGlvbnMucHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlLmRhdGFcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2UoZXZlbnQsIF9yZWYyKSB7XG5cdCAgICAgICAgICAgIHZhciBvbiA9IF9yZWYyLm9uLCBzZW5kID0gX3JlZjIuc2VuZDtcblx0ICAgICAgICAgICAgdmFyIHJlY2VpdmVkTWVzc2FnZXMgPSBnbG9iYWxTdG9yZShcInJlY2VpdmVkTWVzc2FnZXNcIik7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdyB8fCB3aW5kb3cuY2xvc2VkIHx8ICFldmVudC5zb3VyY2UpIHJldHVybjtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSwgb3JpZ2luID0gZXZlbnQub3JpZ2luO1xuXHQgICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBmdW5jdGlvbihtZXNzYWdlLCBzb3VyY2UsIG9yaWdpbiwgX3JlZikge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZi5vbiwgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJzZWRNZXNzYWdlO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJzZWRNZXNzYWdlID0gZGVzZXJpYWxpemVNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgcGFyc2VkTWVzc2FnZSAmJiBudWxsICE9PSBwYXJzZWRNZXNzYWdlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlTWVzc2FnZXMgPSBwYXJzZWRNZXNzYWdlLl9fcG9zdF9yb2JvdF8xMF8wXzQ2X187XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VNZXNzYWdlcykpIHJldHVybiBwYXJzZU1lc3NhZ2VzO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KGV2ZW50LmRhdGEsIHNvdXJjZSwgb3JpZ2luLCB7XG5cdCAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBpZiAobWVzc2FnZXMpIHtcblx0ICAgICAgICAgICAgICAgIG1hcmtXaW5kb3dLbm93bihzb3VyY2UpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbWVzc2FnZXMubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZXNbX2kyXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRNZXNzYWdlcy5oYXMobWVzc2FnZS5pZCkpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICByZWNlaXZlZE1lc3NhZ2VzLnNldChtZXNzYWdlLmlkLCAhMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHNvdXJjZSkgJiYgIW1lc3NhZ2UuZmlyZUFuZEZvcmdldCkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIDAgPT09IG1lc3NhZ2Uub3JpZ2luLmluZGV4T2YoXCJmaWxlOlwiKSAmJiAob3JpZ2luID0gXCJmaWxlOi8vXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zdHJvYm90X21lc3NhZ2VfcmVxdWVzdFwiID09PSBtZXNzYWdlLnR5cGUgPyBoYW5kbGVSZXF1ZXN0KHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogXCJwb3N0cm9ib3RfbWVzc2FnZV9yZXNwb25zZVwiID09PSBtZXNzYWdlLnR5cGUgPyBoYW5kbGVSZXNwb25zZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkgOiBcInBvc3Ryb2JvdF9tZXNzYWdlX2Fja1wiID09PSBtZXNzYWdlLnR5cGUgJiYgaGFuZGxlQWNrKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gb25fb24obmFtZSwgb3B0aW9ucywgaGFuZGxlcikge1xuXHQgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5hbWVcIik7XG5cdCAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkpIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBvcHRpb25zO1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghaGFuZGxlcikgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaGFuZGxlclwiKTtcblx0ICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZFJlcXVlc3RMaXN0ZW5lcihfcmVmNCwgbGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjQubmFtZSwgd2luQ2FuZGlkYXRlID0gX3JlZjQud2luLCBkb21haW4gPSBfcmVmNC5kb21haW47XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVycyA9IHdpbmRvd1N0b3JlKFwicmVxdWVzdExpc3RlbmVyc1wiKTtcblx0ICAgICAgICAgICAgICAgIGlmICghbmFtZSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIHJlcXVpcmVkIHRvIGFkZCByZXF1ZXN0IGxpc3RlbmVyXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbkNhbmRpZGF0ZSAmJiBcIipcIiAhPT0gd2luQ2FuZGlkYXRlICYmIHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbkNhbmRpZGF0ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVyUHJvbWlzZSA9IHdpbkNhbmRpZGF0ZS5hd2FpdFdpbmRvdygpLnRoZW4oKGZ1bmN0aW9uKGFjdHVhbFdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkUmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW46IGFjdHVhbFdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RMaXN0ZW5lclByb21pc2UudGhlbigoZnVuY3Rpb24ocmVxdWVzdExpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RMaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luID0gd2luQ2FuZGlkYXRlO1xuXHQgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkod2luKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnNDb2xsZWN0aW9uID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX3dpbjIgPSB3aW47IF9pOCA8IF93aW4yLmxlbmd0aDsgX2k4KyspIGxpc3RlbmVyc0NvbGxlY3Rpb24ucHVzaChhZGRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luOiBfd2luMltfaThdXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIpKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBsaXN0ZW5lcnNDb2xsZWN0aW9uLmxlbmd0aDsgX2kxMCsrKSBsaXN0ZW5lcnNDb2xsZWN0aW9uW19pMTBdLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRvbWFpbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX2xpc3RlbmVyc0NvbGxlY3Rpb24gPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTEyID0gMCwgX2RvbWFpbjIgPSBkb21haW47IF9pMTIgPCBfZG9tYWluMi5sZW5ndGg7IF9pMTIrKykgX2xpc3RlbmVyc0NvbGxlY3Rpb24ucHVzaChhZGRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBfZG9tYWluMltfaTEyXVxuXHQgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTQgPSAwOyBfaTE0IDwgX2xpc3RlbmVyc0NvbGxlY3Rpb24ubGVuZ3RoOyBfaTE0KyspIF9saXN0ZW5lcnNDb2xsZWN0aW9uW19pMTRdLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0xpc3RlbmVyID0gZ2V0UmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHdpbiAmJiBcIipcIiAhPT0gd2luIHx8ICh3aW4gPSBnZXRXaWxkY2FyZCgpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdHJEb21haW4gPSAoZG9tYWluID0gZG9tYWluIHx8IFwiKlwiKS50b1N0cmluZygpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nTGlzdGVuZXIpIHRocm93IHdpbiAmJiBkb21haW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBvbiBkb21haW4gXCIgKyBkb21haW4udG9TdHJpbmcoKSArIFwiIGZvciBcIiArICh3aW4gPT09IGdldFdpbGRjYXJkKCkgPyBcIndpbGRjYXJkXCIgOiBcInNwZWNpZmllZFwiKSArIFwiIHdpbmRvd1wiKSA6IHdpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIGZvciBcIiArICh3aW4gPT09IGdldFdpbGRjYXJkKCkgPyBcIndpbGRjYXJkXCIgOiBcInNwZWNpZmllZFwiKSArIFwiIHdpbmRvd1wiKSA6IGRvbWFpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIG9uIGRvbWFpbiBcIiArIGRvbWFpbi50b1N0cmluZygpKSA6IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZUxpc3RlbmVycyA9IHJlcXVlc3RMaXN0ZW5lcnMuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVEb21haW5MaXN0ZW5lcnMgPSB1dGlsX2dldE9yU2V0KHdpbk5hbWVMaXN0ZW5lcnMsIG5hbWUsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgdXRpbF9pc1JlZ2V4KGRvbWFpbikgPyAod2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzID0gdXRpbF9nZXRPclNldCh3aW5OYW1lRG9tYWluTGlzdGVuZXJzLCBcIl9fZG9tYWluX3JlZ2V4X19cIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICAgICAgICAgIH0pKSkucHVzaCh3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICByZWdleDogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuXHQgICAgICAgICAgICAgICAgfSkgOiB3aW5OYW1lRG9tYWluTGlzdGVuZXJzW3N0ckRvbWFpbl0gPSBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdpbk5hbWVEb21haW5MaXN0ZW5lcnNbc3RyRG9tYWluXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnMuc3BsaWNlKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycy5pbmRleE9mKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyLCAxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnMubGVuZ3RoIHx8IGRlbGV0ZSB3aW5OYW1lRG9tYWluTGlzdGVuZXJzLl9fZG9tYWluX3JlZ2V4X187XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMod2luTmFtZURvbWFpbkxpc3RlbmVycykubGVuZ3RoIHx8IGRlbGV0ZSB3aW5OYW1lTGlzdGVuZXJzW25hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW4gJiYgIU9iamVjdC5rZXlzKHdpbk5hbWVMaXN0ZW5lcnMpLmxlbmd0aCAmJiByZXF1ZXN0TGlzdGVuZXJzLmRlbCh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgIHdpbjogb3B0aW9ucy53aW5kb3csXG5cdCAgICAgICAgICAgICAgICBkb21haW46IG9wdGlvbnMuZG9tYWluIHx8IFwiKlwiXG5cdCAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIgfHwgb3B0aW9ucy5oYW5kbGVyLFxuXHQgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3I6IG9wdGlvbnMuZXJyb3JIYW5kbGVyIHx8IGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RMaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gb25fb25jZShuYW1lLCBvcHRpb25zLCBoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkpIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBvcHRpb25zO1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG5cdCAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGxpc3RlbmVyID0gb25fb24obmFtZSwgb3B0aW9ucywgKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShldmVudCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikgcmV0dXJuIGhhbmRsZXIoZXZlbnQpO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHByb21pc2UuY2FuY2VsID0gbGlzdGVuZXIuY2FuY2VsO1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNlbmRfc2VuZCA9IGZ1bmN0aW9uIHNlbmQod2luT3JQcm94eVdpbiwgbmFtZSwgZGF0YSwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgZG9tYWluTWF0Y2hlciA9IChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkuZG9tYWluIHx8IFwiKlwiO1xuXHQgICAgICAgICAgICB2YXIgcmVzcG9uc2VUaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IC0xO1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRUaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDVlMztcblx0ICAgICAgICAgICAgdmFyIGZpcmVBbmRGb3JnZXQgPSBvcHRpb25zLmZpcmVBbmRGb3JnZXQgfHwgITE7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyh3aW5PclByb3h5V2luLCB7XG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgIH0pLmF3YWl0V2luZG93KCkudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24obmFtZSwgd2luLCBkb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBuYW1lXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGRvbWFpbiAmJiAhQXJyYXkuaXNBcnJheShkb21haW4pICYmICF1dGlsX2lzUmVnZXgoZG9tYWluKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3Qgc2VuZCBcIiArIG5hbWUgKyBcIi4gRXhwZWN0ZWQgZG9tYWluIFwiICsgSlNPTi5zdHJpbmdpZnkoZG9tYWluKSArIFwiIHRvIGJlIGEgc3RyaW5nLCBhcnJheSwgb3IgcmVnZXhcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHNlbmQgXCIgKyBuYW1lICsgXCIuIFRhcmdldCB3aW5kb3cgaXMgY2xvc2VkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0obmFtZSwgd2luLCBkb21haW5NYXRjaGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0dWFsUGFyZW50ID0gZ2V0QW5jZXN0b3IoY2hpbGQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0dWFsUGFyZW50KSByZXR1cm4gYWN0dWFsUGFyZW50ID09PSBwYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luLnRvcCkgcmV0dXJuIHdpbi50b3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0UGFyZW50KHdpbikgPT09IHdpbikgcmV0dXJuIHdpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQW5jZXN0b3JQYXJlbnQod2luZG93LCB3aW4pICYmIHdpbmRvdy50b3ApIHJldHVybiB3aW5kb3cudG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbmNlc3RvclBhcmVudCh3aW4sIHdpbmRvdykgJiYgd2luZG93LnRvcCkgcmV0dXJuIHdpbmRvdy50b3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTcgPSAwLCBfZ2V0QWxsQ2hpbGRGcmFtZXM0ID0gZnVuY3Rpb24gZ2V0QWxsQ2hpbGRGcmFtZXMod2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9nZXRGcmFtZXMyID0gZ2V0RnJhbWVzKHdpbik7IF9pMyA8IF9nZXRGcmFtZXMyLmxlbmd0aDsgX2kzKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX2dldEZyYW1lczJbX2kzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwLCBfZ2V0QWxsQ2hpbGRGcmFtZXMyID0gZ2V0QWxsQ2hpbGRGcmFtZXMoZnJhbWUpOyBfaTUgPCBfZ2V0QWxsQ2hpbGRGcmFtZXMyLmxlbmd0aDsgX2k1KyspIHJlc3VsdC5wdXNoKF9nZXRBbGxDaGlsZEZyYW1lczJbX2k1XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbik7IF9pNyA8IF9nZXRBbGxDaGlsZEZyYW1lczQubGVuZ3RoOyBfaTcrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9nZXRBbGxDaGlsZEZyYW1lczRbX2k3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUudG9wKSByZXR1cm4gZnJhbWUudG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0UGFyZW50KGZyYW1lKSA9PT0gZnJhbWUpIHJldHVybiBmcmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfShjaGlsZCkgPT09IGNoaWxkKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTUgPSAwLCBfZ2V0RnJhbWVzOCA9IGdldEZyYW1lcyhwYXJlbnQpOyBfaTE1IDwgX2dldEZyYW1lczgubGVuZ3RoOyBfaTE1KyspIGlmIChfZ2V0RnJhbWVzOFtfaTE1XSA9PT0gY2hpbGQpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgICAgIH0od2luZG93LCB3aW4pKSByZXR1cm4gZnVuY3Rpb24od2luLCB0aW1lb3V0LCBuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdGltZW91dCAmJiAodGltZW91dCA9IDVlMyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gbmFtZSAmJiAobmFtZSA9IFwiV2luZG93XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwiaGVsbG9Qcm9taXNlc1wiKS5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC0xICE9PSB0aW1lb3V0ICYmIChwcm9taXNlID0gcHJvbWlzZS50aW1lb3V0KHRpbWVvdXQsIG5ldyBFcnJvcihuYW1lICsgXCIgZGlkIG5vdCBsb2FkIGFmdGVyIFwiICsgdGltZW91dCArIFwibXNcIikpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW4sIGNoaWxkVGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oX3RlbXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24od2luLCB0YXJnZXREb21haW4sIGFjdHVhbERvbWFpbiwgX3JlZikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGFyZ2V0RG9tYWluID8gdGFyZ2V0RG9tYWluIDogcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsRG9tYWluIHx8IHNheUhlbGxvKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmRvbWFpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24obm9ybWFsaXplZERvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4odGFyZ2V0RG9tYWluLCB0YXJnZXREb21haW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJEb21haW4gXCIgKyBzdHJpbmdpZnkodGFyZ2V0RG9tYWluKSArIFwiIGRvZXMgbm90IG1hdGNoIFwiICsgc3RyaW5naWZ5KHRhcmdldERvbWFpbikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRG9tYWluO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW4sIGRvbWFpbk1hdGNoZXIsICh2b2lkIDAgPT09IF90ZW1wID8ge30gOiBfdGVtcCkuZG9tYWluLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbih0YXJnZXREb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdGFyZ2V0RG9tYWluO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsb2dOYW1lID0gXCJwb3N0cm9ib3RfbWV0aG9kXCIgPT09IG5hbWUgJiYgZGF0YSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkYXRhLm5hbWUgPyBkYXRhLm5hbWUgKyBcIigpXCIgOiBuYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gbmFtZSArIFwiX1wiICsgdW5pcXVlSUQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcmVBbmRGb3JnZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGlzdGVuZXIgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luOiB3aW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGhhc2gsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpLnNldChoYXNoLCBsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0oaGFzaCwgcmVzcG9uc2VMaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFQcm9taXNlcyA9IHdpbmRvd1N0b3JlKFwicmVxdWVzdFByb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcVByb21pc2VzLnB1c2gocHJvbWlzZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2F0Y2goKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGhhc2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImVycm9yZWRSZXNwb25zZUxpc3RlbmVyc1wiKS5zZXQoaGFzaCwgITApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShoYXNoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlc3BvbnNlTGlzdGVuZXIoaGFzaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsQWNrVGltZW91dCA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwia25vd25XaW5kb3dzXCIpLmdldCh3aW4sICExKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW4pID8gMWU0IDogMmUzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxSZXNUaW1lb3V0ID0gcmVzcG9uc2VUaW1lb3V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWNrVGltZW91dCA9IHRvdGFsQWNrVGltZW91dDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc1RpbWVvdXQgPSB0b3RhbFJlc1RpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGZ1bmN0aW9uKG1ldGhvZCwgdGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24gbG9vcCgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSByZXR1cm4gcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV2luZG93IGNsb3NlZCBmb3IgXCIgKyBuYW1lICsgXCIgYmVmb3JlIFwiICsgKHJlc3BvbnNlTGlzdGVuZXIuYWNrID8gXCJyZXNwb25zZVwiIDogXCJhY2tcIikpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUxpc3RlbmVyLmNhbmNlbGxlZCkgcmV0dXJuIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlJlc3BvbnNlIGxpc3RlbmVyIHdhcyBjYW5jZWxsZWQgZm9yIFwiICsgbmFtZSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNrVGltZW91dCA9IE1hdGgubWF4KGFja1RpbWVvdXQgLSA1MDAsIDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgIT09IHJlc1RpbWVvdXQgJiYgKHJlc1RpbWVvdXQgPSBNYXRoLm1heChyZXNUaW1lb3V0IC0gNTAwLCAwKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUxpc3RlbmVyLmFjayB8fCAwICE9PSBhY2tUaW1lb3V0ID8gMCA9PT0gcmVzVGltZW91dCAmJiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmb3IgcG9zdE1lc3NhZ2UgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiIGluIFwiICsgdG90YWxSZXNUaW1lb3V0ICsgXCJtc1wiKSkgOiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBhY2sgZm9yIHBvc3RNZXNzYWdlIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIiBpbiBcIiArIHRvdGFsQWNrVGltZW91dCArIFwibXNcIikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgNTAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5maW5hbGx5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxUHJvbWlzZXMuc3BsaWNlKHJlcVByb21pc2VzLmluZGV4T2YocHJvbWlzZSwgMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHdpbiwgZG9tYWluLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB1bmlxdWVJRCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbih3aW5kb3cpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3JlcXVlc3RcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogZmlyZUFuZEZvcmdldFxuXHQgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJlQW5kRm9yZ2V0ID8gcHJvbWlzZS5yZXNvbHZlKCkgOiBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgcmVxdWVzdCBtZXNzYWdlIGZhaWxlZCBmb3IgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiXFxuXFxuXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIHNldHVwX3NlcmlhbGl6ZU1lc3NhZ2UoZGVzdGluYXRpb24sIGRvbWFpbiwgb2JqKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVNZXNzYWdlKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaiwge1xuXHQgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXR1cF9kZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuXHQgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBjcmVhdGVQcm94eVdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3dfUHJveHlXaW5kb3coe1xuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kLFxuXHQgICAgICAgICAgICAgICAgd2luOiB3aW5cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNldHVwX3RvUHJveHlXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0dXAoKSB7XG5cdCAgICAgICAgICAgIGlmICghZ2xvYmFsX2dldEdsb2JhbCgpLmluaXRpYWxpemVkKSB7XG5cdCAgICAgICAgICAgICAgICBnbG9iYWxfZ2V0R2xvYmFsKCkuaW5pdGlhbGl6ZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgIG9uID0gKF9yZWYzID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgICAgIH0pLm9uLCBzZW5kID0gX3JlZjMuc2VuZCwgKGdsb2JhbCA9IGdsb2JhbF9nZXRHbG9iYWwoKSkucmVjZWl2ZU1lc3NhZ2UgPSBnbG9iYWwucmVjZWl2ZU1lc3NhZ2UgfHwgZnVuY3Rpb24obWVzc2FnZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlX3JlY2VpdmVNZXNzYWdlKG1lc3NhZ2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZjUub24sIHNlbmQgPSBfcmVmNS5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKCkuZ2V0T3JTZXQoXCJwb3N0TWVzc2FnZUxpc3RlbmVyXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgZXZlbnQsIGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0od2luZG93LCAwLCAoZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihldmVudCwgX3JlZjQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmNC5vbiwgc2VuZCA9IF9yZWY0LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCBldmVudC5zb3VyY2VFbGVtZW50O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gZXZlbnQub3JpZ2luIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC5vcmlnaW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJudWxsXCIgPT09IG9yaWdpbiAmJiAob3JpZ2luID0gXCJmaWxlOi8vXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbikgdGhyb3cgbmV3IEVycm9yKFwiUG9zdCBtZXNzYWdlIGRpZCBub3QgaGF2ZSBvcmlnaW4gZG9tYWluXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZV9yZWNlaXZlTWVzc2FnZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oZXZlbnQsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICFmdW5jdGlvbihfcmVmOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWY4Lm9uLCBzZW5kID0gX3JlZjguc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImJ1aWx0aW5MaXN0ZW5lcnNcIikuZ2V0T3JTZXQoXCJoZWxsb0xpc3RlbmVyXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gb24oXCJwb3N0cm9ib3RfaGVsbG9cIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBcIipcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCAoZnVuY3Rpb24oX3JlZjMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVIZWxsb1Byb21pc2UoX3JlZjMuc291cmNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBfcmVmMy5vcmlnaW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBnZXRJbnN0YW5jZUlEKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGdldEFuY2VzdG9yKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJiBzYXlIZWxsbyhwYXJlbnQsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGZ1bmN0aW9uKGVycikge30pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcmVmMywgb24sIHNlbmQsIGdsb2JhbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0ICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGlzdGVuZXJzID0gZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9yZXNwb25zZUxpc3RlbmVycyRrZTIgPSByZXNwb25zZUxpc3RlbmVycy5rZXlzKCk7IF9pMiA8IF9yZXNwb25zZUxpc3RlbmVycyRrZTIubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMltfaTJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHJlc3BvbnNlTGlzdGVuZXJzLmdldChoYXNoKTtcblx0ICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciAmJiAobGlzdGVuZXIuY2FuY2VsbGVkID0gITApO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTGlzdGVuZXJzLmRlbChoYXNoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAobGlzdGVuZXIgPSBnbG9iYWxTdG9yZSgpLmdldChcInBvc3RNZXNzYWdlTGlzdGVuZXJcIikpICYmIGxpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG5cdCAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuX19wb3N0X3JvYm90XzEwXzBfNDZfXztcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNyY190eXBlc19UWVBFU18wID0gITA7XG5cdCAgICAgICAgZnVuY3Rpb24gY2xlYW5VcFdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3JlcXVlc3RQcm9taXNlcyRnZXQyID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0UHJvbWlzZXNcIikuZ2V0KHdpbiwgW10pOyBfaTIgPCBfcmVxdWVzdFByb21pc2VzJGdldDIubGVuZ3RoOyBfaTIrKykgX3JlcXVlc3RQcm9taXNlcyRnZXQyW19pMl0ucmVqZWN0KG5ldyBFcnJvcihcIldpbmRvdyBcIiArIChpc1dpbmRvd0Nsb3NlZCh3aW4pID8gXCJjbG9zZWRcIiA6IFwiY2xlYW5lZCB1cFwiKSArIFwiIGJlZm9yZSByZXNwb25zZVwiKSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNldHVwKCk7XG5cdCAgICB9IF0pO1xuXHR9KSk7IFxufSAocG9zdFJvYm90KSk7XG5cbnZhciBwb3N0Um9ib3RFeHBvcnRzJDEgPSBwb3N0Um9ib3QuZXhwb3J0cztcblxuLyogQGZsb3cgKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0Ly8gJEZsb3dGaXhNZVxuXHRtb2R1bGUuZXhwb3J0cyA9IHBvc3RSb2JvdEV4cG9ydHMkMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tY29tbW9uanNcblxuXHQvLyAkRmxvd0ZpeE1lXG5cdG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0czsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tY29tbW9uanMgXG59IChwb3N0Um9ib3QkMSkpO1xuXG52YXIgcG9zdFJvYm90RXhwb3J0cyA9IHBvc3RSb2JvdCQxLmV4cG9ydHM7XG52YXIgaW5kZXggPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocG9zdFJvYm90RXhwb3J0cyk7XG5cbnZhciBpbmRleCQxID0gLyojX19QVVJFX18qL19tZXJnZU5hbWVzcGFjZXMoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGRlZmF1bHQ6IGluZGV4XG59LCBbcG9zdFJvYm90RXhwb3J0c10pO1xuXG5leHBvcnQgeyBpbmRleCQxIGFzIGkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/family/lib/index-DD_kndDs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/family/lib/sdk.js":
/*!****************************************!*\
  !*** ./node_modules/family/lib/sdk.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommunicationTypes: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   EthereumProvider: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   EthereumProviderConnectionTimeoutError: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   FamilyAccountsSdk: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   SdkStatus: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   SessionCreateResult: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   SessionStatus: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   UsernameType: () => (/* binding */ UsernameType),\n/* harmony export */   createFamilyAccountsClient: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   familyAccountsConnector: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   familyAccountsCustomActions: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   production: () => (/* reexport safe */ _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__.p)\n/* harmony export */ });\n/* harmony import */ var _family_accounts_connector_DNek4H7L_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./family-accounts-connector-DNek4H7L.js */ \"(ssr)/./node_modules/family/lib/family-accounts-connector-DNek4H7L.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n\n\n\n\nvar UsernameType = /* @__PURE__ */ ((UsernameType2) => {\n  UsernameType2[\"EMAIL\"] = \"EMAIL\";\n  UsernameType2[\"PHONE\"] = \"PHONE\";\n  return UsernameType2;\n})(UsernameType || {});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFtaWx5L2xpYi9zZGsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOFY7QUFDaFY7QUFDRTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFRyIsInNvdXJjZXMiOlsid2VicGFjazovL2JsaW5rLXN0YXJ0ZXItbW9uYWQvLi9ub2RlX21vZHVsZXMvZmFtaWx5L2xpYi9zZGsuanM/ODllYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDIGFzIENvbW11bmljYXRpb25UeXBlcywgZCBhcyBFdGhlcmV1bVByb3ZpZGVyLCBFIGFzIEV0aGVyZXVtUHJvdmlkZXJDb25uZWN0aW9uVGltZW91dEVycm9yLCBGIGFzIEZhbWlseUFjY291bnRzU2RrLCBhIGFzIFNka1N0YXR1cywgYiBhcyBTZXNzaW9uQ3JlYXRlUmVzdWx0LCBTIGFzIFNlc3Npb25TdGF0dXMsIGMgYXMgY3JlYXRlRmFtaWx5QWNjb3VudHNDbGllbnQsIGUgYXMgZmFtaWx5QWNjb3VudHNDb25uZWN0b3IsIGYgYXMgZmFtaWx5QWNjb3VudHNDdXN0b21BY3Rpb25zLCBwIGFzIHByb2R1Y3Rpb24gfSBmcm9tICcuL2ZhbWlseS1hY2NvdW50cy1jb25uZWN0b3ItRE5lazRIN0wuanMnO1xuaW1wb3J0ICd2aWVtJztcbmltcG9ydCAnZXZlbnRzJztcblxudmFyIFVzZXJuYW1lVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFVzZXJuYW1lVHlwZTIpID0+IHtcbiAgVXNlcm5hbWVUeXBlMltcIkVNQUlMXCJdID0gXCJFTUFJTFwiO1xuICBVc2VybmFtZVR5cGUyW1wiUEhPTkVcIl0gPSBcIlBIT05FXCI7XG4gIHJldHVybiBVc2VybmFtZVR5cGUyO1xufSkoVXNlcm5hbWVUeXBlIHx8IHt9KTtcblxuZXhwb3J0IHsgVXNlcm5hbWVUeXBlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/family/lib/sdk.js\n");

/***/ })

};
;