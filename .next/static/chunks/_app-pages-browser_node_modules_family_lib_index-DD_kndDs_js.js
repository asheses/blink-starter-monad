"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_family_lib_index-DD_kndDs_js"],{

/***/ "(app-pages-browser)/./node_modules/family/lib/index-DD_kndDs.js":
/*!***************************************************!*\
  !*** ./node_modules/family/lib/index-DD_kndDs.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: function() { return /* binding */ index$1; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\nfunction _mergeNamespaces(n, m) {\n\tm.forEach(function (e) {\n\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\treturn Object.freeze(n);\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar postRobot$1 = {exports: {}};\n\nvar postRobot = {exports: {}};\n\n(function (module, exports) {\n\t!function(root, factory) {\n\t    module.exports = factory() ;\n\t}(\"undefined\" != typeof self ? self : commonjsGlobal, (function() {\n\t    return function(modules) {\n\t        var installedModules = {};\n\t        function __nested_webpack_require_1042__(moduleId) {\n\t            if (installedModules[moduleId]) return installedModules[moduleId].exports;\n\t            var module = installedModules[moduleId] = {\n\t                i: moduleId,\n\t                l: !1,\n\t                exports: {}\n\t            };\n\t            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1042__);\n\t            module.l = !0;\n\t            return module.exports;\n\t        }\n\t        __nested_webpack_require_1042__.m = modules;\n\t        __nested_webpack_require_1042__.c = installedModules;\n\t        __nested_webpack_require_1042__.d = function(exports, name, getter) {\n\t            __nested_webpack_require_1042__.o(exports, name) || Object.defineProperty(exports, name, {\n\t                enumerable: !0,\n\t                get: getter\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.r = function(exports) {\n\t            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n\t                value: \"Module\"\n\t            });\n\t            Object.defineProperty(exports, \"__esModule\", {\n\t                value: !0\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.t = function(value, mode) {\n\t            1 & mode && (value = __nested_webpack_require_1042__(value));\n\t            if (8 & mode) return value;\n\t            if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value;\n\t            var ns = Object.create(null);\n\t            __nested_webpack_require_1042__.r(ns);\n\t            Object.defineProperty(ns, \"default\", {\n\t                enumerable: !0,\n\t                value: value\n\t            });\n\t            if (2 & mode && \"string\" != typeof value) for (var key in value) __nested_webpack_require_1042__.d(ns, key, function(key) {\n\t                return value[key];\n\t            }.bind(null, key));\n\t            return ns;\n\t        };\n\t        __nested_webpack_require_1042__.n = function(module) {\n\t            var getter = module && module.__esModule ? function() {\n\t                return module.default;\n\t            } : function() {\n\t                return module;\n\t            };\n\t            __nested_webpack_require_1042__.d(getter, \"a\", getter);\n\t            return getter;\n\t        };\n\t        __nested_webpack_require_1042__.o = function(object, property) {\n\t            return {}.hasOwnProperty.call(object, property);\n\t        };\n\t        __nested_webpack_require_1042__.p = \"\";\n\t        return __nested_webpack_require_1042__(__nested_webpack_require_1042__.s = 0);\n\t    }([ function(module, __nested_webpack_exports__, __nested_webpack_require_3506__) {\n\t        __nested_webpack_require_3506__.r(__nested_webpack_exports__);\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"Promise\", (function() {\n\t            return promise_ZalgoPromise;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"TYPES\", (function() {\n\t            return src_types_TYPES_0;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"ProxyWindow\", (function() {\n\t            return window_ProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"setup\", (function() {\n\t            return setup;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"destroy\", (function() {\n\t            return destroy;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"serializeMessage\", (function() {\n\t            return setup_serializeMessage;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"deserializeMessage\", (function() {\n\t            return setup_deserializeMessage;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"createProxyWindow\", (function() {\n\t            return createProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"toProxyWindow\", (function() {\n\t            return setup_toProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"on\", (function() {\n\t            return on_on;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"once\", (function() {\n\t            return on_once;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"send\", (function() {\n\t            return send_send;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"markWindowKnown\", (function() {\n\t            return markWindowKnown;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"cleanUpWindow\", (function() {\n\t            return cleanUpWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"bridge\", (function() {}));\n\t        function isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        var IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\t        function getActualProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return win.location.protocol;\n\t        }\n\t        function getProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            if (win.mockDomain) {\n\t                var protocol = win.mockDomain.split(\"//\")[0];\n\t                if (protocol) return protocol;\n\t            }\n\t            return getActualProtocol(win);\n\t        }\n\t        function isAboutProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return \"about:\" === getProtocol(win);\n\t        }\n\t        function getParent(win) {\n\t            void 0 === win && (win = window);\n\t            if (win) try {\n\t                if (win.parent && win.parent !== win) return win.parent;\n\t            } catch (err) {}\n\t        }\n\t        function getOpener(win) {\n\t            void 0 === win && (win = window);\n\t            if (win && !getParent(win)) try {\n\t                return win.opener;\n\t            } catch (err) {}\n\t        }\n\t        function canReadFromWindow(win) {\n\t            try {\n\t                return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function getActualDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var location = win.location;\n\t            if (!location) throw new Error(\"Can not read window location\");\n\t            var protocol = getActualProtocol(win);\n\t            if (!protocol) throw new Error(\"Can not read window protocol\");\n\t            if (\"file:\" === protocol) return \"file://\";\n\t            if (\"about:\" === protocol) {\n\t                var parent = getParent(win);\n\t                return parent && canReadFromWindow() ? getActualDomain(parent) : \"about://\";\n\t            }\n\t            var host = location.host;\n\t            if (!host) throw new Error(\"Can not read window host\");\n\t            return protocol + \"//\" + host;\n\t        }\n\t        function getDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var domain = getActualDomain(win);\n\t            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(\"mock:\") ? win.mockDomain : domain;\n\t        }\n\t        function isSameDomain(win) {\n\t            if (!function(win) {\n\t                try {\n\t                    if (win === window) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    var desc = Object.getOwnPropertyDescriptor(win, \"location\");\n\t                    if (desc && !1 === desc.enumerable) return !1;\n\t                } catch (err) {}\n\t                try {\n\t                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (function(win) {\n\t                        void 0 === win && (win = window);\n\t                        return \"mock:\" === getProtocol(win);\n\t                    }(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (getActualDomain(win) === getActualDomain(window)) return !0;\n\t                } catch (err) {}\n\t                return !1;\n\t            }(win)) return !1;\n\t            try {\n\t                if (win === window) return !0;\n\t                if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                if (getDomain(window) === getDomain(win)) return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function assertSameDomain(win) {\n\t            if (!isSameDomain(win)) throw new Error(\"Expected window to be same domain\");\n\t            return win;\n\t        }\n\t        function isAncestorParent(parent, child) {\n\t            if (!parent || !child) return !1;\n\t            var childParent = getParent(child);\n\t            return childParent ? childParent === parent : -1 !== function(win) {\n\t                var result = [];\n\t                try {\n\t                    for (;win.parent !== win; ) {\n\t                        result.push(win.parent);\n\t                        win = win.parent;\n\t                    }\n\t                } catch (err) {}\n\t                return result;\n\t            }(child).indexOf(parent);\n\t        }\n\t        function getFrames(win) {\n\t            var result = [];\n\t            var frames;\n\t            try {\n\t                frames = win.frames;\n\t            } catch (err) {\n\t                frames = win;\n\t            }\n\t            var len;\n\t            try {\n\t                len = frames.length;\n\t            } catch (err) {}\n\t            if (0 === len) return result;\n\t            if (len) {\n\t                for (var i = 0; i < len; i++) {\n\t                    var frame = void 0;\n\t                    try {\n\t                        frame = frames[i];\n\t                    } catch (err) {\n\t                        continue;\n\t                    }\n\t                    result.push(frame);\n\t                }\n\t                return result;\n\t            }\n\t            for (var _i = 0; _i < 100; _i++) {\n\t                var _frame = void 0;\n\t                try {\n\t                    _frame = frames[_i];\n\t                } catch (err) {\n\t                    return result;\n\t                }\n\t                if (!_frame) return result;\n\t                result.push(_frame);\n\t            }\n\t            return result;\n\t        }\n\t        var iframeWindows = [];\n\t        var iframeFrames = [];\n\t        function isWindowClosed(win, allowMock) {\n\t            void 0 === allowMock && (allowMock = !0);\n\t            try {\n\t                if (win === window) return !1;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (!win) return !0;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (win.closed) return !0;\n\t            } catch (err) {\n\t                return !err || err.message !== IE_WIN_ACCESS_ERROR;\n\t            }\n\t            if (allowMock && isSameDomain(win)) try {\n\t                if (win.mockclosed) return !0;\n\t            } catch (err) {}\n\t            try {\n\t                if (!win.parent || !win.top) return !0;\n\t            } catch (err) {}\n\t            var iframeIndex = function(collection, item) {\n\t                for (var i = 0; i < collection.length; i++) try {\n\t                    if (collection[i] === item) return i;\n\t                } catch (err) {}\n\t                return -1;\n\t            }(iframeWindows, win);\n\t            if (-1 !== iframeIndex) {\n\t                var frame = iframeFrames[iframeIndex];\n\t                if (frame && function(frame) {\n\t                    if (!frame.contentWindow) return !0;\n\t                    if (!frame.parentNode) return !0;\n\t                    var doc = frame.ownerDocument;\n\t                    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n\t                        var parent = frame;\n\t                        for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;\n\t                        if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;\n\t                    }\n\t                    return !1;\n\t                }(frame)) return !0;\n\t            }\n\t            return !1;\n\t        }\n\t        function getAncestor(win) {\n\t            void 0 === win && (win = window);\n\t            return getOpener(win = win || window) || getParent(win) || void 0;\n\t        }\n\t        function matchDomain(pattern, origin) {\n\t            if (\"string\" == typeof pattern) {\n\t                if (\"string\" == typeof origin) return \"*\" === pattern || origin === pattern;\n\t                if (isRegex(origin)) return !1;\n\t                if (Array.isArray(origin)) return !1;\n\t            }\n\t            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {\n\t                return matchDomain(subpattern, origin);\n\t            })));\n\t        }\n\t        function isWindow(obj) {\n\t            try {\n\t                if (obj === window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (\"[object Window]\" === {}.toString.call(obj)) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (window.Window && obj instanceof window.Window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.self === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.parent === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.top === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && \"__unlikely_value__\" === obj.__cross_domain_utils_window_check__) return !1;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function getFrameForWindow(win) {\n\t            if (isSameDomain(win)) return assertSameDomain(win).frameElement;\n\t            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll(\"iframe\"); _i21 < _document$querySelect2.length; _i21++) {\n\t                var frame = _document$querySelect2[_i21];\n\t                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;\n\t            }\n\t        }\n\t        function closeWindow(win) {\n\t            if (function(win) {\n\t                void 0 === win && (win = window);\n\t                return Boolean(getParent(win));\n\t            }(win)) {\n\t                var frame = getFrameForWindow(win);\n\t                if (frame && frame.parentElement) {\n\t                    frame.parentElement.removeChild(frame);\n\t                    return;\n\t                }\n\t            }\n\t            try {\n\t                win.close();\n\t            } catch (err) {}\n\t        }\n\t        function utils_isPromise(item) {\n\t            try {\n\t                if (!item) return !1;\n\t                if (\"undefined\" != typeof Promise && item instanceof Promise) return !0;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.Window && item instanceof window.Window) return !1;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.constructor && item instanceof window.constructor) return !1;\n\t                var _toString = {}.toString;\n\t                if (_toString) {\n\t                    var name = _toString.call(item);\n\t                    if (\"[object Window]\" === name || \"[object global]\" === name || \"[object DOMWindow]\" === name) return !1;\n\t                }\n\t                if (\"function\" == typeof item.then) return !0;\n\t            } catch (err) {\n\t                return !1;\n\t            }\n\t            return !1;\n\t        }\n\t        var dispatchedErrors = [];\n\t        var possiblyUnhandledPromiseHandlers = [];\n\t        var activeCount = 0;\n\t        var flushPromise;\n\t        function flushActive() {\n\t            if (!activeCount && flushPromise) {\n\t                var promise = flushPromise;\n\t                flushPromise = null;\n\t                promise.resolve();\n\t            }\n\t        }\n\t        function startActive() {\n\t            activeCount += 1;\n\t        }\n\t        function endActive() {\n\t            activeCount -= 1;\n\t            flushActive();\n\t        }\n\t        var promise_ZalgoPromise = function() {\n\t            function ZalgoPromise(handler) {\n\t                var _this = this;\n\t                this.resolved = void 0;\n\t                this.rejected = void 0;\n\t                this.errorHandled = void 0;\n\t                this.value = void 0;\n\t                this.error = void 0;\n\t                this.handlers = void 0;\n\t                this.dispatching = void 0;\n\t                this.stack = void 0;\n\t                this.resolved = !1;\n\t                this.rejected = !1;\n\t                this.errorHandled = !1;\n\t                this.handlers = [];\n\t                if (handler) {\n\t                    var _result;\n\t                    var _error;\n\t                    var resolved = !1;\n\t                    var rejected = !1;\n\t                    var isAsync = !1;\n\t                    startActive();\n\t                    try {\n\t                        handler((function(res) {\n\t                            if (isAsync) _this.resolve(res); else {\n\t                                resolved = !0;\n\t                                _result = res;\n\t                            }\n\t                        }), (function(err) {\n\t                            if (isAsync) _this.reject(err); else {\n\t                                rejected = !0;\n\t                                _error = err;\n\t                            }\n\t                        }));\n\t                    } catch (err) {\n\t                        endActive();\n\t                        this.reject(err);\n\t                        return;\n\t                    }\n\t                    endActive();\n\t                    isAsync = !0;\n\t                    resolved ? this.resolve(_result) : rejected && this.reject(_error);\n\t                }\n\t            }\n\t            var _proto = ZalgoPromise.prototype;\n\t            _proto.resolve = function(result) {\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(result)) throw new Error(\"Can not resolve promise with another promise\");\n\t                this.resolved = !0;\n\t                this.value = result;\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.reject = function(error) {\n\t                var _this2 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(error)) throw new Error(\"Can not reject promise with another promise\");\n\t                if (!error) {\n\t                    var _err = error && \"function\" == typeof error.toString ? error.toString() : {}.toString.call(error);\n\t                    error = new Error(\"Expected reject to be called with Error, got \" + _err);\n\t                }\n\t                this.rejected = !0;\n\t                this.error = error;\n\t                this.errorHandled || setTimeout((function() {\n\t                    _this2.errorHandled || function(err, promise) {\n\t                        if (-1 === dispatchedErrors.indexOf(err)) {\n\t                            dispatchedErrors.push(err);\n\t                            setTimeout((function() {\n\t                                throw err;\n\t                            }), 1);\n\t                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);\n\t                        }\n\t                    }(error, _this2);\n\t                }), 1);\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.asyncReject = function(error) {\n\t                this.errorHandled = !0;\n\t                this.reject(error);\n\t                return this;\n\t            };\n\t            _proto.dispatch = function() {\n\t                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;\n\t                if (!this.dispatching && (resolved || rejected)) {\n\t                    this.dispatching = !0;\n\t                    startActive();\n\t                    var chain = function(firstPromise, secondPromise) {\n\t                        return firstPromise.then((function(res) {\n\t                            secondPromise.resolve(res);\n\t                        }), (function(err) {\n\t                            secondPromise.reject(err);\n\t                        }));\n\t                    };\n\t                    for (var i = 0; i < handlers.length; i++) {\n\t                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;\n\t                        var _result2 = void 0;\n\t                        if (resolved) try {\n\t                            _result2 = onSuccess ? onSuccess(this.value) : this.value;\n\t                        } catch (err) {\n\t                            promise.reject(err);\n\t                            continue;\n\t                        } else if (rejected) {\n\t                            if (!onError) {\n\t                                promise.reject(this.error);\n\t                                continue;\n\t                            }\n\t                            try {\n\t                                _result2 = onError(this.error);\n\t                            } catch (err) {\n\t                                promise.reject(err);\n\t                                continue;\n\t                            }\n\t                        }\n\t                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {\n\t                            var promiseResult = _result2;\n\t                            promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);\n\t                            promiseResult.errorHandled = !0;\n\t                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);\n\t                    }\n\t                    handlers.length = 0;\n\t                    this.dispatching = !1;\n\t                    endActive();\n\t                }\n\t            };\n\t            _proto.then = function(onSuccess, onError) {\n\t                if (onSuccess && \"function\" != typeof onSuccess && !onSuccess.call) throw new Error(\"Promise.then expected a function for success handler\");\n\t                if (onError && \"function\" != typeof onError && !onError.call) throw new Error(\"Promise.then expected a function for error handler\");\n\t                var promise = new ZalgoPromise;\n\t                this.handlers.push({\n\t                    promise: promise,\n\t                    onSuccess: onSuccess,\n\t                    onError: onError\n\t                });\n\t                this.errorHandled = !0;\n\t                this.dispatch();\n\t                return promise;\n\t            };\n\t            _proto.catch = function(onError) {\n\t                return this.then(void 0, onError);\n\t            };\n\t            _proto.finally = function(onFinally) {\n\t                if (onFinally && \"function\" != typeof onFinally && !onFinally.call) throw new Error(\"Promise.finally expected a function\");\n\t                return this.then((function(result) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        return result;\n\t                    }));\n\t                }), (function(err) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        throw err;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.timeout = function(time, err) {\n\t                var _this3 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                var timeout = setTimeout((function() {\n\t                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error(\"Promise timed out after \" + time + \"ms\"));\n\t                }), time);\n\t                return this.then((function(result) {\n\t                    clearTimeout(timeout);\n\t                    return result;\n\t                }));\n\t            };\n\t            _proto.toPromise = function() {\n\t                if (\"undefined\" == typeof Promise) throw new TypeError(\"Could not find Promise\");\n\t                return Promise.resolve(this);\n\t            };\n\t            _proto.lazy = function() {\n\t                this.errorHandled = !0;\n\t                return this;\n\t            };\n\t            ZalgoPromise.resolve = function(value) {\n\t                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {\n\t                    return value.then(resolve, reject);\n\t                })) : (new ZalgoPromise).resolve(value);\n\t            };\n\t            ZalgoPromise.reject = function(error) {\n\t                return (new ZalgoPromise).reject(error);\n\t            };\n\t            ZalgoPromise.asyncReject = function(error) {\n\t                return (new ZalgoPromise).asyncReject(error);\n\t            };\n\t            ZalgoPromise.all = function(promises) {\n\t                var promise = new ZalgoPromise;\n\t                var count = promises.length;\n\t                var results = [].slice();\n\t                if (!count) {\n\t                    promise.resolve(results);\n\t                    return promise;\n\t                }\n\t                var chain = function(i, firstPromise, secondPromise) {\n\t                    return firstPromise.then((function(res) {\n\t                        results[i] = res;\n\t                        0 == (count -= 1) && promise.resolve(results);\n\t                    }), (function(err) {\n\t                        secondPromise.reject(err);\n\t                    }));\n\t                };\n\t                for (var i = 0; i < promises.length; i++) {\n\t                    var prom = promises[i];\n\t                    if (prom instanceof ZalgoPromise) {\n\t                        if (prom.resolved) {\n\t                            results[i] = prom.value;\n\t                            count -= 1;\n\t                            continue;\n\t                        }\n\t                    } else if (!utils_isPromise(prom)) {\n\t                        results[i] = prom;\n\t                        count -= 1;\n\t                        continue;\n\t                    }\n\t                    chain(i, ZalgoPromise.resolve(prom), promise);\n\t                }\n\t                0 === count && promise.resolve(results);\n\t                return promise;\n\t            };\n\t            ZalgoPromise.hash = function(promises) {\n\t                var result = {};\n\t                var awaitPromises = [];\n\t                var _loop = function(key) {\n\t                    if (promises.hasOwnProperty(key)) {\n\t                        var value = promises[key];\n\t                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {\n\t                            result[key] = res;\n\t                        }))) : result[key] = value;\n\t                    }\n\t                };\n\t                for (var key in promises) _loop(key);\n\t                return ZalgoPromise.all(awaitPromises).then((function() {\n\t                    return result;\n\t                }));\n\t            };\n\t            ZalgoPromise.map = function(items, method) {\n\t                return ZalgoPromise.all(items.map(method));\n\t            };\n\t            ZalgoPromise.onPossiblyUnhandledException = function(handler) {\n\t                return function(handler) {\n\t                    possiblyUnhandledPromiseHandlers.push(handler);\n\t                    return {\n\t                        cancel: function() {\n\t                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n\t                        }\n\t                    };\n\t                }(handler);\n\t            };\n\t            ZalgoPromise.try = function(method, context, args) {\n\t                if (method && \"function\" != typeof method && !method.call) throw new Error(\"Promise.try expected a function\");\n\t                var result;\n\t                startActive();\n\t                try {\n\t                    result = method.apply(context, args || []);\n\t                } catch (err) {\n\t                    endActive();\n\t                    return ZalgoPromise.reject(err);\n\t                }\n\t                endActive();\n\t                return ZalgoPromise.resolve(result);\n\t            };\n\t            ZalgoPromise.delay = function(_delay) {\n\t                return new ZalgoPromise((function(resolve) {\n\t                    setTimeout(resolve, _delay);\n\t                }));\n\t            };\n\t            ZalgoPromise.isPromise = function(value) {\n\t                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);\n\t            };\n\t            ZalgoPromise.flush = function() {\n\t                return function(Zalgo) {\n\t                    var promise = flushPromise = flushPromise || new Zalgo;\n\t                    flushActive();\n\t                    return promise;\n\t                }(ZalgoPromise);\n\t            };\n\t            return ZalgoPromise;\n\t        }();\n\t        function util_safeIndexOf(collection, item) {\n\t            for (var i = 0; i < collection.length; i++) try {\n\t                if (collection[i] === item) return i;\n\t            } catch (err) {}\n\t            return -1;\n\t        }\n\t        var weakmap_CrossDomainSafeWeakMap = function() {\n\t            function CrossDomainSafeWeakMap() {\n\t                this.name = void 0;\n\t                this.weakmap = void 0;\n\t                this.keys = void 0;\n\t                this.values = void 0;\n\t                this.name = \"__weakmap_\" + (1e9 * Math.random() >>> 0) + \"__\";\n\t                if (function() {\n\t                    if (\"undefined\" == typeof WeakMap) return !1;\n\t                    if (void 0 === Object.freeze) return !1;\n\t                    try {\n\t                        var testWeakMap = new WeakMap;\n\t                        var testKey = {};\n\t                        Object.freeze(testKey);\n\t                        testWeakMap.set(testKey, \"__testvalue__\");\n\t                        return \"__testvalue__\" === testWeakMap.get(testKey);\n\t                    } catch (err) {\n\t                        return !1;\n\t                    }\n\t                }()) try {\n\t                    this.weakmap = new WeakMap;\n\t                } catch (err) {}\n\t                this.keys = [];\n\t                this.values = [];\n\t            }\n\t            var _proto = CrossDomainSafeWeakMap.prototype;\n\t            _proto._cleanupClosedWindows = function() {\n\t                var weakmap = this.weakmap;\n\t                var keys = this.keys;\n\t                for (var i = 0; i < keys.length; i++) {\n\t                    var value = keys[i];\n\t                    if (isWindow(value) && isWindowClosed(value)) {\n\t                        if (weakmap) try {\n\t                            weakmap.delete(value);\n\t                        } catch (err) {}\n\t                        keys.splice(i, 1);\n\t                        this.values.splice(i, 1);\n\t                        i -= 1;\n\t                    }\n\t                }\n\t            };\n\t            _proto.isSafeToReadWrite = function(key) {\n\t                return !isWindow(key);\n\t            };\n\t            _proto.set = function(key, value) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.set(key, value);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var name = this.name;\n\t                    var entry = key[name];\n\t                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {\n\t                        value: [ key, value ],\n\t                        writable: !0\n\t                    });\n\t                    return;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var values = this.values;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 === index) {\n\t                    keys.push(key);\n\t                    values.push(value);\n\t                } else values[index] = value;\n\t            };\n\t            _proto.get = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return weakmap.get(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return entry && entry[0] === key ? entry[1] : void 0;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var index = util_safeIndexOf(this.keys, key);\n\t                if (-1 !== index) return this.values[index];\n\t            };\n\t            _proto.delete = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.delete(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 !== index) {\n\t                    keys.splice(index, 1);\n\t                    this.values.splice(index, 1);\n\t                }\n\t            };\n\t            _proto.has = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return !0;\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return !(!entry || entry[0] !== key);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                return -1 !== util_safeIndexOf(this.keys, key);\n\t            };\n\t            _proto.getOrSet = function(key, getter) {\n\t                if (this.has(key)) return this.get(key);\n\t                var value = getter();\n\t                this.set(key, value);\n\t                return value;\n\t            };\n\t            return CrossDomainSafeWeakMap;\n\t        }();\n\t        function getFunctionName(fn) {\n\t            return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n\t        }\n\t        function setFunctionName(fn, name) {\n\t            try {\n\t                delete fn.name;\n\t                fn.name = name;\n\t            } catch (err) {}\n\t            fn.__name__ = fn.displayName = name;\n\t            return fn;\n\t        }\n\t        function uniqueID() {\n\t            var chars = \"0123456789abcdef\";\n\t            return \"uid_\" + \"xxxxxxxxxx\".replace(/./g, (function() {\n\t                return chars.charAt(Math.floor(Math.random() * chars.length));\n\t            })) + \"_\" + function(str) {\n\t                if (\"function\" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {\n\t                    return String.fromCharCode(parseInt(p1, 16));\n\t                }))).replace(/[=]/g, \"\");\n\t                if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n\t                throw new Error(\"Can not find window.btoa or Buffer\");\n\t            }((new Date).toISOString().slice(11, 19).replace(\"T\", \".\")).replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n\t        }\n\t        var objectIDs;\n\t        function serializeArgs(args) {\n\t            try {\n\t                return JSON.stringify([].slice.call(args), (function(subkey, val) {\n\t                    return \"function\" == typeof val ? \"memoize[\" + function(obj) {\n\t                        objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;\n\t                        if (null == obj || \"object\" != typeof obj && \"function\" != typeof obj) throw new Error(\"Invalid object\");\n\t                        var uid = objectIDs.get(obj);\n\t                        if (!uid) {\n\t                            uid = typeof obj + \":\" + uniqueID();\n\t                            objectIDs.set(obj, uid);\n\t                        }\n\t                        return uid;\n\t                    }(val) + \"]\" : \"undefined\" != typeof window && val instanceof window.Element || null !== val && \"object\" == typeof val && 1 === val.nodeType && \"object\" == typeof val.style && \"object\" == typeof val.ownerDocument ? {} : val;\n\t                }));\n\t            } catch (err) {\n\t                throw new Error(\"Arguments not serializable -- can not be used to memoize\");\n\t            }\n\t        }\n\t        function getEmptyObject() {\n\t            return {};\n\t        }\n\t        var memoizeGlobalIndex = 0;\n\t        var memoizeGlobalIndexValidFrom = 0;\n\t        function memoize(method, options) {\n\t            void 0 === options && (options = {});\n\t            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;\n\t            var simpleCache;\n\t            var thisCache;\n\t            var memoizeIndex = memoizeGlobalIndex;\n\t            memoizeGlobalIndex += 1;\n\t            var memoizedFunction = function() {\n\t                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\t                if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n\t                    simpleCache = null;\n\t                    thisCache = null;\n\t                    memoizeIndex = memoizeGlobalIndex;\n\t                    memoizeGlobalIndex += 1;\n\t                }\n\t                var cache;\n\t                cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};\n\t                var cacheKey;\n\t                try {\n\t                    cacheKey = serializeArgs(args);\n\t                } catch (_unused) {\n\t                    return method.apply(this, arguments);\n\t                }\n\t                var cacheResult = cache[cacheKey];\n\t                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n\t                    delete cache[cacheKey];\n\t                    cacheResult = null;\n\t                }\n\t                if (cacheResult) return cacheResult.value;\n\t                var time = Date.now();\n\t                var value = method.apply(this, arguments);\n\t                cache[cacheKey] = {\n\t                    time: time,\n\t                    value: value\n\t                };\n\t                return value;\n\t            };\n\t            memoizedFunction.reset = function() {\n\t                simpleCache = null;\n\t                thisCache = null;\n\t            };\n\t            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + \"::memoized\");\n\t        }\n\t        memoize.clear = function() {\n\t            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n\t        };\n\t        function memoizePromise(method) {\n\t            var cache = {};\n\t            function memoizedPromiseFunction() {\n\t                var _arguments = arguments, _this = this;\n\t                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n\t                var key = serializeArgs(args);\n\t                if (cache.hasOwnProperty(key)) return cache[key];\n\t                cache[key] = promise_ZalgoPromise.try((function() {\n\t                    return method.apply(_this, _arguments);\n\t                })).finally((function() {\n\t                    delete cache[key];\n\t                }));\n\t                return cache[key];\n\t            }\n\t            memoizedPromiseFunction.reset = function() {\n\t                cache = {};\n\t            };\n\t            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + \"::promiseMemoized\");\n\t        }\n\t        function src_util_noop() {}\n\t        function stringifyError(err, level) {\n\t            void 0 === level && (level = 1);\n\t            if (level >= 3) return \"stringifyError stack overflow\";\n\t            try {\n\t                if (!err) return \"<unknown error: \" + {}.toString.call(err) + \">\";\n\t                if (\"string\" == typeof err) return err;\n\t                if (err instanceof Error) {\n\t                    var stack = err && err.stack;\n\t                    var message = err && err.message;\n\t                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + \"\\n\" + stack;\n\t                    if (stack) return stack;\n\t                    if (message) return message;\n\t                }\n\t                return err && err.toString && \"function\" == typeof err.toString ? err.toString() : {}.toString.call(err);\n\t            } catch (newErr) {\n\t                return \"Error while stringifying error: \" + stringifyError(newErr, level + 1);\n\t            }\n\t        }\n\t        function stringify(item) {\n\t            return \"string\" == typeof item ? item : item && item.toString && \"function\" == typeof item.toString ? item.toString() : {}.toString.call(item);\n\t        }\n\t        memoize((function(obj) {\n\t            if (Object.values) return Object.values(obj);\n\t            var result = [];\n\t            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);\n\t            return result;\n\t        }));\n\t        function util_isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        function util_getOrSet(obj, key, getter) {\n\t            if (obj.hasOwnProperty(key)) return obj[key];\n\t            var val = getter();\n\t            obj[key] = val;\n\t            return val;\n\t        }\n\t        function getBody() {\n\t            var body = document.body;\n\t            if (!body) throw new Error(\"Body element not found\");\n\t            return body;\n\t        }\n\t        function isDocumentReady() {\n\t            return Boolean(document.body) && \"complete\" === document.readyState;\n\t        }\n\t        function isDocumentInteractive() {\n\t            return Boolean(document.body) && \"interactive\" === document.readyState;\n\t        }\n\t        memoize((function() {\n\t            return new promise_ZalgoPromise((function(resolve) {\n\t                if (isDocumentReady() || isDocumentInteractive()) return resolve();\n\t                var interval = setInterval((function() {\n\t                    if (isDocumentReady() || isDocumentInteractive()) {\n\t                        clearInterval(interval);\n\t                        return resolve();\n\t                    }\n\t                }), 10);\n\t            }));\n\t        }));\n\t        var currentScript = \"undefined\" != typeof document ? document.currentScript : null;\n\t        var getCurrentScript = memoize((function() {\n\t            if (currentScript) return currentScript;\n\t            if (currentScript = function() {\n\t                try {\n\t                    var stack = function() {\n\t                        try {\n\t                            throw new Error(\"_\");\n\t                        } catch (err) {\n\t                            return err.stack || \"\";\n\t                        }\n\t                    }();\n\t                    var stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n\t                    var scriptLocation = stackDetails && stackDetails[1];\n\t                    if (!scriptLocation) return;\n\t                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName(\"script\")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {\n\t                        var script = _Array$prototype$slic2[_i22];\n\t                        if (script.src && script.src === scriptLocation) return script;\n\t                    }\n\t                } catch (err) {}\n\t            }()) return currentScript;\n\t            throw new Error(\"Can not determine current script\");\n\t        }));\n\t        var currentUID = uniqueID();\n\t        memoize((function() {\n\t            var script;\n\t            try {\n\t                script = getCurrentScript();\n\t            } catch (err) {\n\t                return currentUID;\n\t            }\n\t            var uid = script.getAttribute(\"data-uid\");\n\t            if (uid && \"string\" == typeof uid) return uid;\n\t            if ((uid = script.getAttribute(\"data-uid-auto\")) && \"string\" == typeof uid) return uid;\n\t            if (script.src) {\n\t                var hashedString = function(str) {\n\t                    var hash = \"\";\n\t                    for (var i = 0; i < str.length; i++) {\n\t                        var total = str[i].charCodeAt(0) * i;\n\t                        str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));\n\t                        hash += String.fromCharCode(97 + Math.abs(total) % 26);\n\t                    }\n\t                    return hash;\n\t                }(JSON.stringify({\n\t                    src: script.src,\n\t                    dataset: script.dataset\n\t                }));\n\t                uid = \"uid_\" + hashedString.slice(hashedString.length - 30);\n\t            } else uid = uniqueID();\n\t            script.setAttribute(\"data-uid-auto\", uid);\n\t            return uid;\n\t        }));\n\t        function global_getGlobal(win) {\n\t            void 0 === win && (win = window);\n\t            var globalKey = \"__post_robot_10_0_46__\";\n\t            return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};\n\t        }\n\t        var getObj = function() {\n\t            return {};\n\t        };\n\t        function globalStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return util_getOrSet(global_getGlobal(), key, (function() {\n\t                var store = defStore();\n\t                return {\n\t                    has: function(storeKey) {\n\t                        return store.hasOwnProperty(storeKey);\n\t                    },\n\t                    get: function(storeKey, defVal) {\n\t                        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n\t                    },\n\t                    set: function(storeKey, val) {\n\t                        store[storeKey] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(storeKey) {\n\t                        delete store[storeKey];\n\t                    },\n\t                    getOrSet: function(storeKey, getter) {\n\t                        return util_getOrSet(store, storeKey, getter);\n\t                    },\n\t                    reset: function() {\n\t                        store = defStore();\n\t                    },\n\t                    keys: function() {\n\t                        return Object.keys(store);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        var WildCard = function() {};\n\t        function getWildcard() {\n\t            var global = global_getGlobal();\n\t            global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard;\n\t            return global.WINDOW_WILDCARD;\n\t        }\n\t        function windowStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return globalStore(\"windowStore\").getOrSet(key, (function() {\n\t                var winStore = new weakmap_CrossDomainSafeWeakMap;\n\t                var getStore = function(win) {\n\t                    return winStore.getOrSet(win, defStore);\n\t                };\n\t                return {\n\t                    has: function(win) {\n\t                        return getStore(win).hasOwnProperty(key);\n\t                    },\n\t                    get: function(win, defVal) {\n\t                        var store = getStore(win);\n\t                        return store.hasOwnProperty(key) ? store[key] : defVal;\n\t                    },\n\t                    set: function(win, val) {\n\t                        getStore(win)[key] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(win) {\n\t                        delete getStore(win)[key];\n\t                    },\n\t                    getOrSet: function(win, getter) {\n\t                        return util_getOrSet(getStore(win), key, getter);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        function getInstanceID() {\n\t            return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n\t        }\n\t        function resolveHelloPromise(win, _ref) {\n\t            var domain = _ref.domain;\n\t            var helloPromises = windowStore(\"helloPromises\");\n\t            var existingPromise = helloPromises.get(win);\n\t            existingPromise && existingPromise.resolve({\n\t                domain: domain\n\t            });\n\t            var newPromise = promise_ZalgoPromise.resolve({\n\t                domain: domain\n\t            });\n\t            helloPromises.set(win, newPromise);\n\t            return newPromise;\n\t        }\n\t        function sayHello(win, _ref4) {\n\t            return (0, _ref4.send)(win, \"postrobot_hello\", {\n\t                instanceID: getInstanceID()\n\t            }, {\n\t                domain: \"*\",\n\t                timeout: -1\n\t            }).then((function(_ref5) {\n\t                var origin = _ref5.origin, instanceID = _ref5.data.instanceID;\n\t                resolveHelloPromise(win, {\n\t                    domain: origin\n\t                });\n\t                return {\n\t                    win: win,\n\t                    domain: origin,\n\t                    instanceID: instanceID\n\t                };\n\t            }));\n\t        }\n\t        function getWindowInstanceID(win, _ref6) {\n\t            var send = _ref6.send;\n\t            return windowStore(\"windowInstanceIDPromises\").getOrSet(win, (function() {\n\t                return sayHello(win, {\n\t                    send: send\n\t                }).then((function(_ref7) {\n\t                    return _ref7.instanceID;\n\t                }));\n\t            }));\n\t        }\n\t        function markWindowKnown(win) {\n\t            windowStore(\"knownWindows\").set(win, !0);\n\t        }\n\t        function isSerializedType(item) {\n\t            return \"object\" == typeof item && null !== item && \"string\" == typeof item.__type__;\n\t        }\n\t        function determineType(val) {\n\t            return void 0 === val ? \"undefined\" : null === val ? \"null\" : Array.isArray(val) ? \"array\" : \"function\" == typeof val ? \"function\" : \"object\" == typeof val ? val instanceof Error ? \"error\" : \"function\" == typeof val.then ? \"promise\" : \"[object RegExp]\" === {}.toString.call(val) ? \"regex\" : \"[object Date]\" === {}.toString.call(val) ? \"date\" : \"object\" : \"string\" == typeof val ? \"string\" : \"number\" == typeof val ? \"number\" : \"boolean\" == typeof val ? \"boolean\" : void 0;\n\t        }\n\t        function serializeType(type, val) {\n\t            return {\n\t                __type__: type,\n\t                __val__: val\n\t            };\n\t        }\n\t        var _SERIALIZER;\n\t        var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {\n\t            return serializeType(\"error\", {\n\t                message: _ref.message,\n\t                stack: _ref.stack,\n\t                code: _ref.code,\n\t                data: _ref.data\n\t            });\n\t        }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {\n\t            return serializeType(\"regex\", val.source);\n\t        }, _SERIALIZER.date = function(val) {\n\t            return serializeType(\"date\", val.toJSON());\n\t        }, _SERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _SERIALIZER[void 0] = function(val) {\n\t            return serializeType(\"undefined\", val);\n\t        }, _SERIALIZER);\n\t        var defaultSerializers = {};\n\t        var _DESERIALIZER;\n\t        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {\n\t            throw new Error(\"Function serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.error = function(_ref2) {\n\t            var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;\n\t            var error = new Error(_ref2.message);\n\t            error.code = code;\n\t            data && (error.data = data);\n\t            error.stack = stack + \"\\n\\n\" + error.stack;\n\t            return error;\n\t        }, _DESERIALIZER.promise = function() {\n\t            throw new Error(\"Promise serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.regex = function(val) {\n\t            return new RegExp(val);\n\t        }, _DESERIALIZER.date = function(val) {\n\t            return new Date(val);\n\t        }, _DESERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER[void 0] = function() {}, _DESERIALIZER);\n\t        var defaultDeserializers = {};\n\t        new promise_ZalgoPromise((function(resolve) {\n\t            if (window.document && window.document.body) return resolve(window.document.body);\n\t            var interval = setInterval((function() {\n\t                if (window.document && window.document.body) {\n\t                    clearInterval(interval);\n\t                    return resolve(window.document.body);\n\t                }\n\t            }), 10);\n\t        }));\n\t        function cleanupProxyWindows() {\n\t            var idToProxyWindow = globalStore(\"idToProxyWindow\");\n\t            for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {\n\t                var id = _idToProxyWindow$keys2[_i2];\n\t                idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);\n\t            }\n\t        }\n\t        function getSerializedWindow(winPromise, _ref) {\n\t            var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;\n\t            var windowNamePromise = winPromise.then((function(win) {\n\t                if (isSameDomain(win)) return assertSameDomain(win).name;\n\t            }));\n\t            var windowTypePromise = winPromise.then((function(window) {\n\t                if (isWindowClosed(window)) throw new Error(\"Window is closed, can not determine type\");\n\t                return getOpener(window) ? \"popup\" : \"iframe\";\n\t            }));\n\t            windowNamePromise.catch(src_util_noop);\n\t            windowTypePromise.catch(src_util_noop);\n\t            var getName = function() {\n\t                return winPromise.then((function(win) {\n\t                    if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;\n\t                }));\n\t            };\n\t            return {\n\t                id: id,\n\t                getType: function() {\n\t                    return windowTypePromise;\n\t                },\n\t                getInstanceID: memoizePromise((function() {\n\t                    return winPromise.then((function(win) {\n\t                        return getWindowInstanceID(win, {\n\t                            send: send\n\t                        });\n\t                    }));\n\t                })),\n\t                close: function() {\n\t                    return winPromise.then(closeWindow);\n\t                },\n\t                getName: getName,\n\t                focus: function() {\n\t                    return winPromise.then((function(win) {\n\t                        win.focus();\n\t                    }));\n\t                },\n\t                isClosed: function() {\n\t                    return winPromise.then((function(win) {\n\t                        return isWindowClosed(win);\n\t                    }));\n\t                },\n\t                setLocation: function(href, opts) {\n\t                    void 0 === opts && (opts = {});\n\t                    return winPromise.then((function(win) {\n\t                        var domain = window.location.protocol + \"//\" + window.location.host;\n\t                        var _opts$method = opts.method, method = void 0 === _opts$method ? \"get\" : _opts$method, body = opts.body;\n\t                        if (0 === href.indexOf(\"/\")) href = \"\" + domain + href; else if (!href.match(/^https?:\\/\\//) && 0 !== href.indexOf(domain)) throw new Error(\"Expected url to be http or https url, or absolute path, got \" + JSON.stringify(href));\n\t                        if (\"post\" === method) return getName().then((function(name) {\n\t                            if (!name) throw new Error(\"Can not post to window without target name\");\n\t                            !function(_ref3) {\n\t                                var url = _ref3.url, target = _ref3.target, body = _ref3.body, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? \"post\" : _ref3$method;\n\t                                var form = document.createElement(\"form\");\n\t                                form.setAttribute(\"target\", target);\n\t                                form.setAttribute(\"method\", method);\n\t                                form.setAttribute(\"action\", url);\n\t                                form.style.display = \"none\";\n\t                                if (body) for (var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++) {\n\t                                    var _body$key;\n\t                                    var key = _Object$keys4[_i24];\n\t                                    var input = document.createElement(\"input\");\n\t                                    input.setAttribute(\"name\", key);\n\t                                    input.setAttribute(\"value\", null == (_body$key = body[key]) ? void 0 : _body$key.toString());\n\t                                    form.appendChild(input);\n\t                                }\n\t                                getBody().appendChild(form);\n\t                                form.submit();\n\t                                getBody().removeChild(form);\n\t                            }({\n\t                                url: href,\n\t                                target: name,\n\t                                method: method,\n\t                                body: body\n\t                            });\n\t                        }));\n\t                        if (\"get\" !== method) throw new Error(\"Unsupported method: \" + method);\n\t                        if (isSameDomain(win)) try {\n\t                            if (win.location && \"function\" == typeof win.location.replace) {\n\t                                win.location.replace(href);\n\t                                return;\n\t                            }\n\t                        } catch (err) {}\n\t                        win.location = href;\n\t                    }));\n\t                },\n\t                setName: function(name) {\n\t                    return winPromise.then((function(win) {\n\t                        var sameDomain = isSameDomain(win);\n\t                        var frame = getFrameForWindow(win);\n\t                        if (!sameDomain) throw new Error(\"Can not set name for cross-domain window: \" + name);\n\t                        assertSameDomain(win).name = name;\n\t                        frame && frame.setAttribute(\"name\", name);\n\t                        windowNamePromise = promise_ZalgoPromise.resolve(name);\n\t                    }));\n\t                }\n\t            };\n\t        }\n\t        var window_ProxyWindow = function() {\n\t            function ProxyWindow(_ref2) {\n\t                var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;\n\t                this.id = void 0;\n\t                this.isProxyWindow = !0;\n\t                this.serializedWindow = void 0;\n\t                this.actualWindow = void 0;\n\t                this.actualWindowPromise = void 0;\n\t                this.send = void 0;\n\t                this.name = void 0;\n\t                this.actualWindowPromise = new promise_ZalgoPromise;\n\t                this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send\n\t                });\n\t                globalStore(\"idToProxyWindow\").set(this.getID(), this);\n\t                win && this.setWindow(win, {\n\t                    send: send\n\t                });\n\t            }\n\t            var _proto = ProxyWindow.prototype;\n\t            _proto.getID = function() {\n\t                return this.serializedWindow.id;\n\t            };\n\t            _proto.getType = function() {\n\t                return this.serializedWindow.getType();\n\t            };\n\t            _proto.isPopup = function() {\n\t                return this.getType().then((function(type) {\n\t                    return \"popup\" === type;\n\t                }));\n\t            };\n\t            _proto.setLocation = function(href, opts) {\n\t                var _this = this;\n\t                return this.serializedWindow.setLocation(href, opts).then((function() {\n\t                    return _this;\n\t                }));\n\t            };\n\t            _proto.getName = function() {\n\t                return this.serializedWindow.getName();\n\t            };\n\t            _proto.setName = function(name) {\n\t                var _this2 = this;\n\t                return this.serializedWindow.setName(name).then((function() {\n\t                    return _this2;\n\t                }));\n\t            };\n\t            _proto.close = function() {\n\t                var _this3 = this;\n\t                return this.serializedWindow.close().then((function() {\n\t                    return _this3;\n\t                }));\n\t            };\n\t            _proto.focus = function() {\n\t                var _this4 = this;\n\t                var isPopupPromise = this.isPopup();\n\t                var getNamePromise = this.getName();\n\t                var reopenPromise = promise_ZalgoPromise.hash({\n\t                    isPopup: isPopupPromise,\n\t                    name: getNamePromise\n\t                }).then((function(_ref3) {\n\t                    var name = _ref3.name;\n\t                    _ref3.isPopup && name && window.open(\"\", name, \"noopener\");\n\t                }));\n\t                var focusPromise = this.serializedWindow.focus();\n\t                return promise_ZalgoPromise.all([ reopenPromise, focusPromise ]).then((function() {\n\t                    return _this4;\n\t                }));\n\t            };\n\t            _proto.isClosed = function() {\n\t                return this.serializedWindow.isClosed();\n\t            };\n\t            _proto.getWindow = function() {\n\t                return this.actualWindow;\n\t            };\n\t            _proto.setWindow = function(win, _ref4) {\n\t                var send = _ref4.send;\n\t                this.actualWindow = win;\n\t                this.actualWindowPromise.resolve(this.actualWindow);\n\t                this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send,\n\t                    id: this.getID()\n\t                });\n\t                windowStore(\"winToProxyWindow\").set(win, this);\n\t            };\n\t            _proto.awaitWindow = function() {\n\t                return this.actualWindowPromise;\n\t            };\n\t            _proto.matchWindow = function(win, _ref5) {\n\t                var _this5 = this;\n\t                var send = _ref5.send;\n\t                return promise_ZalgoPromise.try((function() {\n\t                    return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({\n\t                        proxyInstanceID: _this5.getInstanceID(),\n\t                        knownWindowInstanceID: getWindowInstanceID(win, {\n\t                            send: send\n\t                        })\n\t                    }).then((function(_ref6) {\n\t                        var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;\n\t                        match && _this5.setWindow(win, {\n\t                            send: send\n\t                        });\n\t                        return match;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.unwrap = function() {\n\t                return this.actualWindow || this;\n\t            };\n\t            _proto.getInstanceID = function() {\n\t                return this.serializedWindow.getInstanceID();\n\t            };\n\t            _proto.shouldClean = function() {\n\t                return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n\t            };\n\t            _proto.serialize = function() {\n\t                return this.serializedWindow;\n\t            };\n\t            ProxyWindow.unwrap = function(win) {\n\t                return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;\n\t            };\n\t            ProxyWindow.serialize = function(win, _ref7) {\n\t                var send = _ref7.send;\n\t                cleanupProxyWindows();\n\t                return ProxyWindow.toProxyWindow(win, {\n\t                    send: send\n\t                }).serialize();\n\t            };\n\t            ProxyWindow.deserialize = function(serializedWindow, _ref8) {\n\t                var send = _ref8.send;\n\t                cleanupProxyWindows();\n\t                return globalStore(\"idToProxyWindow\").get(serializedWindow.id) || new ProxyWindow({\n\t                    serializedWindow: serializedWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            ProxyWindow.isProxyWindow = function(obj) {\n\t                return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n\t            };\n\t            ProxyWindow.toProxyWindow = function(win, _ref9) {\n\t                var send = _ref9.send;\n\t                cleanupProxyWindows();\n\t                if (ProxyWindow.isProxyWindow(win)) return win;\n\t                var actualWindow = win;\n\t                return windowStore(\"winToProxyWindow\").get(actualWindow) || new ProxyWindow({\n\t                    win: actualWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            return ProxyWindow;\n\t        }();\n\t        function addMethod(id, val, name, source, domain) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {\n\t                val: val,\n\t                name: name,\n\t                domain: domain,\n\t                source: source\n\t            }); else {\n\t                proxyWindowMethods.del(id);\n\t                methodStore.getOrSet(source, (function() {\n\t                    return {};\n\t                }))[id] = {\n\t                    domain: domain,\n\t                    name: name,\n\t                    val: val,\n\t                    source: source\n\t                };\n\t            }\n\t        }\n\t        function lookupMethod(source, id) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            return methodStore.getOrSet(source, (function() {\n\t                return {};\n\t            }))[id] || proxyWindowMethods.get(id);\n\t        }\n\t        function function_serializeFunction(destination, domain, val, key, _ref3) {\n\t            on = (_ref = {\n\t                on: _ref3.on,\n\t                send: _ref3.send\n\t            }).on, send = _ref.send, globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", (function() {\n\t                return on(\"postrobot_method\", {\n\t                    domain: \"*\"\n\t                }, (function(_ref2) {\n\t                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;\n\t                    var id = data.id, name = data.name;\n\t                    var meth = lookupMethod(source, id);\n\t                    if (!meth) throw new Error(\"Could not find method '\" + name + \"' with id: \" + data.id + \" in \" + getDomain(window));\n\t                    var methodSource = meth.source, domain = meth.domain, val = meth.val;\n\t                    return promise_ZalgoPromise.try((function() {\n\t                        if (!matchDomain(domain, origin)) throw new Error(\"Method '\" + data.name + \"' domain \" + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + \" does not match origin \" + origin + \" in \" + getDomain(window));\n\t                        if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {\n\t                            send: send\n\t                        }).then((function(match) {\n\t                            if (!match) throw new Error(\"Method call '\" + data.name + \"' failed - proxy window does not match source in \" + getDomain(window));\n\t                        }));\n\t                    })).then((function() {\n\t                        return val.apply({\n\t                            source: source,\n\t                            origin: origin\n\t                        }, data.args);\n\t                    }), (function(err) {\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            if (val.onError) return val.onError(err);\n\t                        })).then((function() {\n\t                            err.stack && (err.stack = \"Remote call to \" + name + \"(\" + function(args) {\n\t                                void 0 === args && (args = []);\n\t                                return (item = args, [].slice.call(item)).map((function(arg) {\n\t                                    return \"string\" == typeof arg ? \"'\" + arg + \"'\" : void 0 === arg ? \"undefined\" : null === arg ? \"null\" : \"boolean\" == typeof arg ? arg.toString() : Array.isArray(arg) ? \"[ ... ]\" : \"object\" == typeof arg ? \"{ ... }\" : \"function\" == typeof arg ? \"() => { ... }\" : \"<\" + typeof arg + \">\";\n\t                                })).join(\", \");\n\t                                var item;\n\t                            }(data.args) + \") failed\\n\\n\" + err.stack);\n\t                            throw err;\n\t                        }));\n\t                    })).then((function(result) {\n\t                        return {\n\t                            result: result,\n\t                            id: id,\n\t                            name: name\n\t                        };\n\t                    }));\n\t                }));\n\t            }));\n\t            var _ref, on, send;\n\t            var id = val.__id__ || uniqueID();\n\t            destination = window_ProxyWindow.unwrap(destination);\n\t            var name = val.__name__ || val.name || key;\n\t            \"string\" == typeof name && \"function\" == typeof name.indexOf && 0 === name.indexOf(\"anonymous::\") && (name = name.replace(\"anonymous::\", key + \"::\"));\n\t            if (window_ProxyWindow.isProxyWindow(destination)) {\n\t                addMethod(id, val, name, destination, domain);\n\t                destination.awaitWindow().then((function(win) {\n\t                    addMethod(id, val, name, win, domain);\n\t                }));\n\t            } else addMethod(id, val, name, destination, domain);\n\t            return serializeType(\"cross_domain_function\", {\n\t                id: id,\n\t                name: name\n\t            });\n\t        }\n\t        function serializeMessage(destination, domain, obj, _ref) {\n\t            var _serialize;\n\t            var on = _ref.on, send = _ref.send;\n\t            return function(obj, serializers) {\n\t                void 0 === serializers && (serializers = defaultSerializers);\n\t                var result = JSON.stringify(obj, (function(key) {\n\t                    var val = this[key];\n\t                    if (isSerializedType(this)) return val;\n\t                    var type = determineType(val);\n\t                    if (!type) return val;\n\t                    var serializer = serializers[type] || SERIALIZER[type];\n\t                    return serializer ? serializer(val, key) : val;\n\t                }));\n\t                return void 0 === result ? \"undefined\" : result;\n\t            }(obj, ((_serialize = {}).promise = function(val, key) {\n\t                return function(destination, domain, val, key, _ref) {\n\t                    return serializeType(\"cross_domain_zalgo_promise\", {\n\t                        then: function_serializeFunction(destination, domain, (function(resolve, reject) {\n\t                            return val.then(resolve, reject);\n\t                        }), key, {\n\t                            on: _ref.on,\n\t                            send: _ref.send\n\t                        })\n\t                    });\n\t                }(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.function = function(val, key) {\n\t                return function_serializeFunction(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.object = function(val) {\n\t                return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType(\"cross_domain_window\", window_ProxyWindow.serialize(val, {\n\t                    send: send\n\t                })) : val;\n\t            }, _serialize));\n\t        }\n\t        function deserializeMessage(source, origin, message, _ref2) {\n\t            var _deserialize;\n\t            var send = _ref2.send;\n\t            return function(str, deserializers) {\n\t                void 0 === deserializers && (deserializers = defaultDeserializers);\n\t                if (\"undefined\" !== str) return JSON.parse(str, (function(key, val) {\n\t                    if (isSerializedType(this)) return val;\n\t                    var type;\n\t                    var value;\n\t                    if (isSerializedType(val)) {\n\t                        type = val.__type__;\n\t                        value = val.__val__;\n\t                    } else {\n\t                        type = determineType(val);\n\t                        value = val;\n\t                    }\n\t                    if (!type) return value;\n\t                    var deserializer = deserializers[type] || DESERIALIZER[type];\n\t                    return deserializer ? deserializer(value, key) : value;\n\t                }));\n\t            }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {\n\t                return function(source, origin, _ref2) {\n\t                    return new promise_ZalgoPromise(_ref2.then);\n\t                }(0, 0, serializedPromise);\n\t            }, _deserialize.cross_domain_function = function(serializedFunction) {\n\t                return function(source, origin, _ref4, _ref5) {\n\t                    var id = _ref4.id, name = _ref4.name;\n\t                    var send = _ref5.send;\n\t                    var getDeserializedFunction = function(opts) {\n\t                        void 0 === opts && (opts = {});\n\t                        function crossDomainFunctionWrapper() {\n\t                            var _arguments = arguments;\n\t                            return window_ProxyWindow.toProxyWindow(source, {\n\t                                send: send\n\t                            }).awaitWindow().then((function(win) {\n\t                                var meth = lookupMethod(win, id);\n\t                                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({\n\t                                    source: window,\n\t                                    origin: getDomain()\n\t                                }, _arguments);\n\t                                var _args = [].slice.call(_arguments);\n\t                                return opts.fireAndForget ? send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: !0\n\t                                }) : send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: !1\n\t                                }).then((function(res) {\n\t                                    return res.data.result;\n\t                                }));\n\t                            })).catch((function(err) {\n\t                                throw err;\n\t                            }));\n\t                        }\n\t                        crossDomainFunctionWrapper.__name__ = name;\n\t                        crossDomainFunctionWrapper.__origin__ = origin;\n\t                        crossDomainFunctionWrapper.__source__ = source;\n\t                        crossDomainFunctionWrapper.__id__ = id;\n\t                        crossDomainFunctionWrapper.origin = origin;\n\t                        return crossDomainFunctionWrapper;\n\t                    };\n\t                    var crossDomainFunctionWrapper = getDeserializedFunction();\n\t                    crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n\t                        fireAndForget: !0\n\t                    });\n\t                    return crossDomainFunctionWrapper;\n\t                }(source, origin, serializedFunction, {\n\t                    send: send\n\t                });\n\t            }, _deserialize.cross_domain_window = function(serializedWindow) {\n\t                return window_ProxyWindow.deserialize(serializedWindow, {\n\t                    send: send\n\t                });\n\t            }, _deserialize));\n\t        }\n\t        var SEND_MESSAGE_STRATEGIES = {};\n\t        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {\n\t            0 === domain.indexOf(\"file:\") && (domain = \"*\");\n\t            win.postMessage(serializedMessage, domain);\n\t        };\n\t        function send_sendMessage(win, domain, message, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            return promise_ZalgoPromise.try((function() {\n\t                var domainBuffer = windowStore().getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                domainBuffer.buffer = domainBuffer.buffer || [];\n\t                domainBuffer.buffer.push(message);\n\t                domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then((function() {\n\t                    if (isWindowClosed(win)) throw new Error(\"Window is closed\");\n\t                    var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_46__ = domainBuffer.buffer || [], \n\t                    _ref), {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                    var _ref;\n\t                    delete domainBuffer.buffer;\n\t                    var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n\t                    var errors = [];\n\t                    for (var _i2 = 0; _i2 < strategies.length; _i2++) {\n\t                        var strategyName = strategies[_i2];\n\t                        try {\n\t                            SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n\t                        } catch (err) {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                    if (errors.length === strategies.length) throw new Error(\"All post-robot messaging strategies failed:\\n\\n\" + errors.map((function(err, i) {\n\t                        return i + \". \" + stringifyError(err);\n\t                    })).join(\"\\n\\n\"));\n\t                }));\n\t                return domainBuffer.flush.then((function() {\n\t                    delete domainBuffer.flush;\n\t                }));\n\t            })).then(src_util_noop);\n\t        }\n\t        function getResponseListener(hash) {\n\t            return globalStore(\"responseListeners\").get(hash);\n\t        }\n\t        function deleteResponseListener(hash) {\n\t            globalStore(\"responseListeners\").del(hash);\n\t        }\n\t        function isResponseListenerErrored(hash) {\n\t            return globalStore(\"erroredResponseListeners\").has(hash);\n\t        }\n\t        function getRequestListener(_ref) {\n\t            var name = _ref.name, win = _ref.win, domain = _ref.domain;\n\t            var requestListeners = windowStore(\"requestListeners\");\n\t            \"*\" === win && (win = null);\n\t            \"*\" === domain && (domain = null);\n\t            if (!name) throw new Error(\"Name required to get request listener\");\n\t            for (var _i4 = 0, _ref3 = [ win, getWildcard() ]; _i4 < _ref3.length; _i4++) {\n\t                var winQualifier = _ref3[_i4];\n\t                if (winQualifier) {\n\t                    var nameListeners = requestListeners.get(winQualifier);\n\t                    if (nameListeners) {\n\t                        var domainListeners = nameListeners[name];\n\t                        if (domainListeners) {\n\t                            if (domain && \"string\" == typeof domain) {\n\t                                if (domainListeners[domain]) return domainListeners[domain];\n\t                                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {\n\t                                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;\n\t                                    if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;\n\t                                }\n\t                            }\n\t                            if (domainListeners[\"*\"]) return domainListeners[\"*\"];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function handleRequest(source, origin, message, _ref) {\n\t            var on = _ref.on, send = _ref.send;\n\t            var options = getRequestListener({\n\t                name: message.name,\n\t                win: source,\n\t                domain: origin\n\t            });\n\t            var logName = \"postrobot_method\" === message.name && message.data && \"string\" == typeof message.data.name ? message.data.name + \"()\" : message.name;\n\t            function sendResponse(ack, data, error) {\n\t                return promise_ZalgoPromise.flush().then((function() {\n\t                    if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                        return send_sendMessage(source, origin, {\n\t                            id: uniqueID(),\n\t                            origin: getDomain(window),\n\t                            type: \"postrobot_message_response\",\n\t                            hash: message.hash,\n\t                            name: message.name,\n\t                            ack: ack,\n\t                            data: data,\n\t                            error: error\n\t                        }, {\n\t                            on: on,\n\t                            send: send\n\t                        });\n\t                    } catch (err) {\n\t                        throw new Error(\"Send response message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }\n\t                }));\n\t            }\n\t            return promise_ZalgoPromise.all([ promise_ZalgoPromise.flush().then((function() {\n\t                if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                    return send_sendMessage(source, origin, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_ack\",\n\t                        hash: message.hash,\n\t                        name: message.name\n\t                    }, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    throw new Error(\"Send ack message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                }\n\t            })), promise_ZalgoPromise.try((function() {\n\t                if (!options) throw new Error(\"No handler found for post message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                return options.handler({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            })).then((function(data) {\n\t                return sendResponse(\"success\", data);\n\t            }), (function(error) {\n\t                return sendResponse(\"error\", null, error);\n\t            })) ]).then(src_util_noop).catch((function(err) {\n\t                if (options && options.handleError) return options.handleError(err);\n\t                throw err;\n\t            }));\n\t        }\n\t        function handleAck(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message ack for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                try {\n\t                    if (!matchDomain(options.domain, origin)) throw new Error(\"Ack origin \" + origin + \" does not match domain \" + options.domain.toString());\n\t                    if (source !== options.win) throw new Error(\"Ack source does not match registered window\");\n\t                } catch (err) {\n\t                    options.promise.reject(err);\n\t                }\n\t                options.ack = !0;\n\t            }\n\t        }\n\t        function handleResponse(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message response for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                if (!matchDomain(options.domain, origin)) throw new Error(\"Response origin \" + origin + \" does not match domain \" + (pattern = options.domain, \n\t                Array.isArray(pattern) ? \"(\" + pattern.join(\" | \") + \")\" : isRegex(pattern) ? \"RegExp(\" + pattern.toString() + \")\" : pattern.toString()));\n\t                var pattern;\n\t                if (source !== options.win) throw new Error(\"Response source does not match registered window\");\n\t                deleteResponseListener(message.hash);\n\t                \"error\" === message.ack ? options.promise.reject(message.error) : \"success\" === message.ack && options.promise.resolve({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            }\n\t        }\n\t        function receive_receiveMessage(event, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            var receivedMessages = globalStore(\"receivedMessages\");\n\t            try {\n\t                if (!window || window.closed || !event.source) return;\n\t            } catch (err) {\n\t                return;\n\t            }\n\t            var source = event.source, origin = event.origin;\n\t            var messages = function(message, source, origin, _ref) {\n\t                var on = _ref.on, send = _ref.send;\n\t                var parsedMessage;\n\t                try {\n\t                    parsedMessage = deserializeMessage(source, origin, message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    return;\n\t                }\n\t                if (parsedMessage && \"object\" == typeof parsedMessage && null !== parsedMessage) {\n\t                    var parseMessages = parsedMessage.__post_robot_10_0_46__;\n\t                    if (Array.isArray(parseMessages)) return parseMessages;\n\t                }\n\t            }(event.data, source, origin, {\n\t                on: on,\n\t                send: send\n\t            });\n\t            if (messages) {\n\t                markWindowKnown(source);\n\t                for (var _i2 = 0; _i2 < messages.length; _i2++) {\n\t                    var message = messages[_i2];\n\t                    if (receivedMessages.has(message.id)) return;\n\t                    receivedMessages.set(message.id, !0);\n\t                    if (isWindowClosed(source) && !message.fireAndForget) return;\n\t                    0 === message.origin.indexOf(\"file:\") && (origin = \"file://\");\n\t                    try {\n\t                        \"postrobot_message_request\" === message.type ? handleRequest(source, origin, message, {\n\t                            on: on,\n\t                            send: send\n\t                        }) : \"postrobot_message_response\" === message.type ? handleResponse(source, origin, message) : \"postrobot_message_ack\" === message.type && handleAck(source, origin, message);\n\t                    } catch (err) {\n\t                        setTimeout((function() {\n\t                            throw err;\n\t                        }), 0);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function on_on(name, options, handler) {\n\t            if (!name) throw new Error(\"Expected name\");\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            if (!handler) throw new Error(\"Expected handler\");\n\t            var requestListener = function addRequestListener(_ref4, listener) {\n\t                var name = _ref4.name, winCandidate = _ref4.win, domain = _ref4.domain;\n\t                var requestListeners = windowStore(\"requestListeners\");\n\t                if (!name || \"string\" != typeof name) throw new Error(\"Name required to add request listener\");\n\t                if (winCandidate && \"*\" !== winCandidate && window_ProxyWindow.isProxyWindow(winCandidate)) {\n\t                    var requestListenerPromise = winCandidate.awaitWindow().then((function(actualWin) {\n\t                        return addRequestListener({\n\t                            name: name,\n\t                            win: actualWin,\n\t                            domain: domain\n\t                        }, listener);\n\t                    }));\n\t                    return {\n\t                        cancel: function() {\n\t                            requestListenerPromise.then((function(requestListener) {\n\t                                return requestListener.cancel();\n\t                            }), src_util_noop);\n\t                        }\n\t                    };\n\t                }\n\t                var win = winCandidate;\n\t                if (Array.isArray(win)) {\n\t                    var listenersCollection = [];\n\t                    for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        domain: domain,\n\t                        win: _win2[_i8]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                if (Array.isArray(domain)) {\n\t                    var _listenersCollection = [];\n\t                    for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        win: win,\n\t                        domain: _domain2[_i12]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                var existingListener = getRequestListener({\n\t                    name: name,\n\t                    win: win,\n\t                    domain: domain\n\t                });\n\t                win && \"*\" !== win || (win = getWildcard());\n\t                var strDomain = (domain = domain || \"*\").toString();\n\t                if (existingListener) throw win && domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString() + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : win ? new Error(\"Request listener already exists for \" + name + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString()) : new Error(\"Request listener already exists for \" + name);\n\t                var winNameListeners = requestListeners.getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainListeners = util_getOrSet(winNameListeners, name, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainRegexListeners;\n\t                var winNameDomainRegexListener;\n\t                util_isRegex(domain) ? (winNameDomainRegexListeners = util_getOrSet(winNameDomainListeners, \"__domain_regex__\", (function() {\n\t                    return [];\n\t                }))).push(winNameDomainRegexListener = {\n\t                    regex: domain,\n\t                    listener: listener\n\t                }) : winNameDomainListeners[strDomain] = listener;\n\t                return {\n\t                    cancel: function() {\n\t                        delete winNameDomainListeners[strDomain];\n\t                        if (winNameDomainRegexListener) {\n\t                            winNameDomainRegexListeners.splice(winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1));\n\t                            winNameDomainRegexListeners.length || delete winNameDomainListeners.__domain_regex__;\n\t                        }\n\t                        Object.keys(winNameDomainListeners).length || delete winNameListeners[name];\n\t                        win && !Object.keys(winNameListeners).length && requestListeners.del(win);\n\t                    }\n\t                };\n\t            }({\n\t                name: name,\n\t                win: options.window,\n\t                domain: options.domain || \"*\"\n\t            }, {\n\t                handler: handler || options.handler,\n\t                handleError: options.errorHandler || function(err) {\n\t                    throw err;\n\t                }\n\t            });\n\t            return {\n\t                cancel: function() {\n\t                    requestListener.cancel();\n\t                }\n\t            };\n\t        }\n\t        function on_once(name, options, handler) {\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            var promise = new promise_ZalgoPromise;\n\t            var listener;\n\t            options.errorHandler = function(err) {\n\t                listener.cancel();\n\t                promise.reject(err);\n\t            };\n\t            listener = on_on(name, options, (function(event) {\n\t                listener.cancel();\n\t                promise.resolve(event);\n\t                if (handler) return handler(event);\n\t            }));\n\t            promise.cancel = listener.cancel;\n\t            return promise;\n\t        }\n\t        var send_send = function send(winOrProxyWin, name, data, options) {\n\t            var domainMatcher = (options = options || {}).domain || \"*\";\n\t            var responseTimeout = options.timeout || -1;\n\t            var childTimeout = options.timeout || 5e3;\n\t            var fireAndForget = options.fireAndForget || !1;\n\t            return window_ProxyWindow.toProxyWindow(winOrProxyWin, {\n\t                send: send\n\t            }).awaitWindow().then((function(win) {\n\t                return promise_ZalgoPromise.try((function() {\n\t                    !function(name, win, domain) {\n\t                        if (!name) throw new Error(\"Expected name\");\n\t                        if (domain && \"string\" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError(\"Can not send \" + name + \". Expected domain \" + JSON.stringify(domain) + \" to be a string, array, or regex\");\n\t                        if (isWindowClosed(win)) throw new Error(\"Can not send \" + name + \". Target window is closed\");\n\t                    }(name, win, domainMatcher);\n\t                    if (function(parent, child) {\n\t                        var actualParent = getAncestor(child);\n\t                        if (actualParent) return actualParent === parent;\n\t                        if (child === parent) return !1;\n\t                        if (function(win) {\n\t                            void 0 === win && (win = window);\n\t                            try {\n\t                                if (win.top) return win.top;\n\t                            } catch (err) {}\n\t                            if (getParent(win) === win) return win;\n\t                            try {\n\t                                if (isAncestorParent(window, win) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            try {\n\t                                if (isAncestorParent(win, window) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            for (var _i7 = 0, _getAllChildFrames4 = function getAllChildFrames(win) {\n\t                                var result = [];\n\t                                for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n\t                                    var frame = _getFrames2[_i3];\n\t                                    result.push(frame);\n\t                                    for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);\n\t                                }\n\t                                return result;\n\t                            }(win); _i7 < _getAllChildFrames4.length; _i7++) {\n\t                                var frame = _getAllChildFrames4[_i7];\n\t                                try {\n\t                                    if (frame.top) return frame.top;\n\t                                } catch (err) {}\n\t                                if (getParent(frame) === frame) return frame;\n\t                            }\n\t                        }(child) === child) return !1;\n\t                        for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return !0;\n\t                        return !1;\n\t                    }(window, win)) return function(win, timeout, name) {\n\t                        void 0 === timeout && (timeout = 5e3);\n\t                        void 0 === name && (name = \"Window\");\n\t                        var promise = function(win) {\n\t                            return windowStore(\"helloPromises\").getOrSet(win, (function() {\n\t                                return new promise_ZalgoPromise;\n\t                            }));\n\t                        }(win);\n\t                        -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + \" did not load after \" + timeout + \"ms\")));\n\t                        return promise;\n\t                    }(win, childTimeout);\n\t                })).then((function(_temp) {\n\t                    return function(win, targetDomain, actualDomain, _ref) {\n\t                        var send = _ref.send;\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            return \"string\" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try((function() {\n\t                                return actualDomain || sayHello(win, {\n\t                                    send: send\n\t                                }).then((function(_ref2) {\n\t                                    return _ref2.domain;\n\t                                }));\n\t                            })).then((function(normalizedDomain) {\n\t                                if (!matchDomain(targetDomain, targetDomain)) throw new Error(\"Domain \" + stringify(targetDomain) + \" does not match \" + stringify(targetDomain));\n\t                                return normalizedDomain;\n\t                            }));\n\t                        }));\n\t                    }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {\n\t                        send: send\n\t                    });\n\t                })).then((function(targetDomain) {\n\t                    var domain = targetDomain;\n\t                    var logName = \"postrobot_method\" === name && data && \"string\" == typeof data.name ? data.name + \"()\" : name;\n\t                    var promise = new promise_ZalgoPromise;\n\t                    var hash = name + \"_\" + uniqueID();\n\t                    if (!fireAndForget) {\n\t                        var responseListener = {\n\t                            name: name,\n\t                            win: win,\n\t                            domain: domain,\n\t                            promise: promise\n\t                        };\n\t                        !function(hash, listener) {\n\t                            globalStore(\"responseListeners\").set(hash, listener);\n\t                        }(hash, responseListener);\n\t                        var reqPromises = windowStore(\"requestPromises\").getOrSet(win, (function() {\n\t                            return [];\n\t                        }));\n\t                        reqPromises.push(promise);\n\t                        promise.catch((function() {\n\t                            !function(hash) {\n\t                                globalStore(\"erroredResponseListeners\").set(hash, !0);\n\t                            }(hash);\n\t                            deleteResponseListener(hash);\n\t                        }));\n\t                        var totalAckTimeout = function(win) {\n\t                            return windowStore(\"knownWindows\").get(win, !1);\n\t                        }(win) ? 1e4 : 2e3;\n\t                        var totalResTimeout = responseTimeout;\n\t                        var ackTimeout = totalAckTimeout;\n\t                        var resTimeout = totalResTimeout;\n\t                        var interval = function(method, time) {\n\t                            var timeout;\n\t                            !function loop() {\n\t                                timeout = setTimeout((function() {\n\t                                    !function() {\n\t                                        if (isWindowClosed(win)) return promise.reject(new Error(\"Window closed for \" + name + \" before \" + (responseListener.ack ? \"response\" : \"ack\")));\n\t                                        if (responseListener.cancelled) return promise.reject(new Error(\"Response listener was cancelled for \" + name));\n\t                                        ackTimeout = Math.max(ackTimeout - 500, 0);\n\t                                        -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));\n\t                                        responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout && promise.reject(new Error(\"No response for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalResTimeout + \"ms\")) : promise.reject(new Error(\"No ack for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalAckTimeout + \"ms\"));\n\t                                    }();\n\t                                    loop();\n\t                                }), 500);\n\t                            }();\n\t                            return {\n\t                                cancel: function() {\n\t                                    clearTimeout(timeout);\n\t                                }\n\t                            };\n\t                        }();\n\t                        promise.finally((function() {\n\t                            interval.cancel();\n\t                            reqPromises.splice(reqPromises.indexOf(promise, 1));\n\t                        })).catch(src_util_noop);\n\t                    }\n\t                    return send_sendMessage(win, domain, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_request\",\n\t                        hash: hash,\n\t                        name: name,\n\t                        data: data,\n\t                        fireAndForget: fireAndForget\n\t                    }, {\n\t                        on: on_on,\n\t                        send: send\n\t                    }).then((function() {\n\t                        return fireAndForget ? promise.resolve() : promise;\n\t                    }), (function(err) {\n\t                        throw new Error(\"Send request message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }));\n\t                }));\n\t            }));\n\t        };\n\t        function setup_serializeMessage(destination, domain, obj) {\n\t            return serializeMessage(destination, domain, obj, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup_deserializeMessage(source, origin, message) {\n\t            return deserializeMessage(source, origin, message, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function createProxyWindow(win) {\n\t            return new window_ProxyWindow({\n\t                send: send_send,\n\t                win: win\n\t            });\n\t        }\n\t        function setup_toProxyWindow(win) {\n\t            return window_ProxyWindow.toProxyWindow(win, {\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup() {\n\t            if (!global_getGlobal().initialized) {\n\t                global_getGlobal().initialized = !0;\n\t                on = (_ref3 = {\n\t                    on: on_on,\n\t                    send: send_send\n\t                }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function(message) {\n\t                    return receive_receiveMessage(message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                };\n\t                !function(_ref5) {\n\t                    var on = _ref5.on, send = _ref5.send;\n\t                    globalStore().getOrSet(\"postMessageListener\", (function() {\n\t                        return function(obj, event, handler) {\n\t                            obj.addEventListener(\"message\", handler);\n\t                            return {\n\t                                cancel: function() {\n\t                                    obj.removeEventListener(\"message\", handler);\n\t                                }\n\t                            };\n\t                        }(window, 0, (function(event) {\n\t                            !function(event, _ref4) {\n\t                                var on = _ref4.on, send = _ref4.send;\n\t                                promise_ZalgoPromise.try((function() {\n\t                                    var source = event.source || event.sourceElement;\n\t                                    var origin = event.origin || event.originalEvent && event.originalEvent.origin;\n\t                                    var data = event.data;\n\t                                    \"null\" === origin && (origin = \"file://\");\n\t                                    if (source) {\n\t                                        if (!origin) throw new Error(\"Post message did not have origin domain\");\n\t                                        receive_receiveMessage({\n\t                                            source: source,\n\t                                            origin: origin,\n\t                                            data: data\n\t                                        }, {\n\t                                            on: on,\n\t                                            send: send\n\t                                        });\n\t                                    }\n\t                                }));\n\t                            }(event, {\n\t                                on: on,\n\t                                send: send\n\t                            });\n\t                        }));\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t                !function(_ref8) {\n\t                    var on = _ref8.on, send = _ref8.send;\n\t                    globalStore(\"builtinListeners\").getOrSet(\"helloListener\", (function() {\n\t                        var listener = on(\"postrobot_hello\", {\n\t                            domain: \"*\"\n\t                        }, (function(_ref3) {\n\t                            resolveHelloPromise(_ref3.source, {\n\t                                domain: _ref3.origin\n\t                            });\n\t                            return {\n\t                                instanceID: getInstanceID()\n\t                            };\n\t                        }));\n\t                        var parent = getAncestor();\n\t                        parent && sayHello(parent, {\n\t                            send: send\n\t                        }).catch((function(err) {}));\n\t                        return listener;\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t            }\n\t            var _ref3, on, send, global;\n\t        }\n\t        function destroy() {\n\t            !function() {\n\t                var responseListeners = globalStore(\"responseListeners\");\n\t                for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {\n\t                    var hash = _responseListeners$ke2[_i2];\n\t                    var listener = responseListeners.get(hash);\n\t                    listener && (listener.cancelled = !0);\n\t                    responseListeners.del(hash);\n\t                }\n\t            }();\n\t            (listener = globalStore().get(\"postMessageListener\")) && listener.cancel();\n\t            var listener;\n\t            delete window.__post_robot_10_0_46__;\n\t        }\n\t        var src_types_TYPES_0 = !0;\n\t        function cleanUpWindow(win) {\n\t            for (var _i2 = 0, _requestPromises$get2 = windowStore(\"requestPromises\").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error(\"Window \" + (isWindowClosed(win) ? \"closed\" : \"cleaned up\") + \" before response\")).catch(src_util_noop);\n\t        }\n\t        setup();\n\t    } ]);\n\t})); \n} (postRobot));\n\nvar postRobotExports$1 = postRobot.exports;\n\n/* @flow */\n\n(function (module) {\n\t// $FlowFixMe\n\tmodule.exports = postRobotExports$1; // eslint-disable-line import/no-commonjs\n\n\t// $FlowFixMe\n\tmodule.exports.default = module.exports; // eslint-disable-line import/no-commonjs \n} (postRobot$1));\n\nvar postRobotExports = postRobot$1.exports;\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postRobotExports);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n\t__proto__: null,\n\tdefault: index\n}, [postRobotExports]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW1pbHkvbGliL2luZGV4LUREX2tuZERzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwrQkFBbUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUIsU0FBUywrQkFBbUI7QUFDNUIsU0FBUywrQkFBbUI7QUFDNUIsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCLGtDQUFrQywrQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDhFQUE4RSwrQkFBbUI7QUFDakc7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsK0JBQW1CO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixzQkFBc0I7QUFDdEI7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixnQkFBZ0IsK0JBQW1CLENBQUMsK0JBQW1CO0FBQ3ZELE1BQU0sb0JBQW9CLDBCQUFtQixFQUFFLCtCQUFtQjtBQUNsRSxTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRCxTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQiwwQkFBMEI7QUFDNUU7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsNkJBQTZCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YscUNBQXFDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLG9DQUFvQztBQUN4STtBQUNBO0FBQ0EsT0FBTztBQUNQLEVBQUU7QUFDRixFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUV1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZmFtaWx5L2xpYi9pbmRleC1ERF9rbmREcy5qcz8yNWYzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9tZXJnZU5hbWVzcGFjZXMobiwgbSkge1xuXHRtLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcblx0XHRlICYmIHR5cGVvZiBlICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShlKSAmJiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICEoayBpbiBuKSkge1xuXHRcdFx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBwb3N0Um9ib3QkMSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBwb3N0Um9ib3QgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQhZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgO1xuXHR9KFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgPyBzZWxmIDogY29tbW9uanNHbG9iYWwsIChmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbihtb2R1bGVzKSB7XG5cdCAgICAgICAgdmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0ICAgICAgICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdCAgICAgICAgICAgIGlmIChpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkgcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdCAgICAgICAgICAgIHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcblx0ICAgICAgICAgICAgICAgIGk6IG1vZHVsZUlkLFxuXHQgICAgICAgICAgICAgICAgbDogITEsXG5cdCAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0ICAgICAgICAgICAgbW9kdWxlLmwgPSAhMDtcblx0ICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuXHQgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG5cdCAgICAgICAgICAgICAgICBnZXQ6IGdldHRlclxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcblx0ICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogXCJNb2R1bGVcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogITBcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuXHQgICAgICAgICAgICAxICYgbW9kZSAmJiAodmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKSk7XG5cdCAgICAgICAgICAgIGlmICg4ICYgbW9kZSkgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICBpZiAoNCAmIG1vZGUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICB2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHQgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsIFwiZGVmYXVsdFwiLCB7XG5cdCAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgaWYgKDIgJiBtb2RlICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIHZhbHVlKSBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuXHQgICAgICAgICAgICB9LmJpbmQobnVsbCwga2V5KSk7XG5cdCAgICAgICAgICAgIHJldHVybiBucztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHQgICAgICAgICAgICB2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID8gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlLmRlZmF1bHQ7XG5cdCAgICAgICAgICAgIH0gOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIFwiYVwiLCBnZXR0ZXIpO1xuXHQgICAgICAgICAgICByZXR1cm4gZ2V0dGVyO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHQgICAgICAgICAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdCAgICAgICAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG5cdCAgICB9KFsgZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlByb21pc2VcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRZUEVTXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNyY190eXBlc19UWVBFU18wO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQcm94eVdpbmRvd1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3c7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNldHVwXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHVwO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZXN0cm95XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3k7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlcmlhbGl6ZU1lc3NhZ2VcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0dXBfc2VyaWFsaXplTWVzc2FnZTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVzZXJpYWxpemVNZXNzYWdlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHVwX2Rlc2VyaWFsaXplTWVzc2FnZTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3JlYXRlUHJveHlXaW5kb3dcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJveHlXaW5kb3c7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRvUHJveHlXaW5kb3dcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0dXBfdG9Qcm94eVdpbmRvdztcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib25cIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gb25fb247XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9uY2VcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gb25fb25jZTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2VuZFwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmQ7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1hcmtXaW5kb3dLbm93blwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBtYXJrV2luZG93S25vd247XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNsZWFuVXBXaW5kb3dcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gY2xlYW5VcFdpbmRvdztcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYnJpZGdlXCIsIChmdW5jdGlvbigpIHt9KSk7XG5cdCAgICAgICAgZnVuY3Rpb24gaXNSZWdleChpdGVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgSUVfV0lOX0FDQ0VTU19FUlJPUiA9IFwiQ2FsbCB3YXMgcmVqZWN0ZWQgYnkgY2FsbGVlLlxcclxcblwiO1xuXHQgICAgICAgIGZ1bmN0aW9uIGdldEFjdHVhbFByb3RvY29sKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbi5sb2NhdGlvbi5wcm90b2NvbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0UHJvdG9jb2wod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICBpZiAod2luLm1vY2tEb21haW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IHdpbi5tb2NrRG9tYWluLnNwbGl0KFwiLy9cIilbMF07XG5cdCAgICAgICAgICAgICAgICBpZiAocHJvdG9jb2wpIHJldHVybiBwcm90b2NvbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZ2V0QWN0dWFsUHJvdG9jb2wod2luKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNBYm91dFByb3RvY29sKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiYWJvdXQ6XCIgPT09IGdldFByb3RvY29sKHdpbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFBhcmVudCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIGlmICh3aW4pIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luLnBhcmVudCAmJiB3aW4ucGFyZW50ICE9PSB3aW4pIHJldHVybiB3aW4ucGFyZW50O1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldE9wZW5lcih3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIGlmICh3aW4gJiYgIWdldFBhcmVudCh3aW4pKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHdpbi5vcGVuZXI7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gY2FuUmVhZEZyb21XaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRBY3R1YWxEb21haW4od2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSB3aW4ubG9jYXRpb247XG5cdCAgICAgICAgICAgIGlmICghbG9jYXRpb24pIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVhZCB3aW5kb3cgbG9jYXRpb25cIik7XG5cdCAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IGdldEFjdHVhbFByb3RvY29sKHdpbik7XG5cdCAgICAgICAgICAgIGlmICghcHJvdG9jb2wpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVhZCB3aW5kb3cgcHJvdG9jb2xcIik7XG5cdCAgICAgICAgICAgIGlmIChcImZpbGU6XCIgPT09IHByb3RvY29sKSByZXR1cm4gXCJmaWxlOi8vXCI7XG5cdCAgICAgICAgICAgIGlmIChcImFib3V0OlwiID09PSBwcm90b2NvbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGdldFBhcmVudCh3aW4pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudCAmJiBjYW5SZWFkRnJvbVdpbmRvdygpID8gZ2V0QWN0dWFsRG9tYWluKHBhcmVudCkgOiBcImFib3V0Oi8vXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGhvc3QgPSBsb2NhdGlvbi5ob3N0O1xuXHQgICAgICAgICAgICBpZiAoIWhvc3QpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVhZCB3aW5kb3cgaG9zdFwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb3RvY29sICsgXCIvL1wiICsgaG9zdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RG9tYWluKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGdldEFjdHVhbERvbWFpbih3aW4pO1xuXHQgICAgICAgICAgICByZXR1cm4gZG9tYWluICYmIHdpbi5tb2NrRG9tYWluICYmIDAgPT09IHdpbi5tb2NrRG9tYWluLmluZGV4T2YoXCJtb2NrOlwiKSA/IHdpbi5tb2NrRG9tYWluIDogZG9tYWluO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc1NhbWVEb21haW4od2luKSB7XG5cdCAgICAgICAgICAgIGlmICghZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luLCBcImxvY2F0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICYmICExID09PSBkZXNjLmVudW1lcmFibGUpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWJvdXRQcm90b2NvbCh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibW9jazpcIiA9PT0gZ2V0UHJvdG9jb2wod2luKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KHdpbikgJiYgY2FuUmVhZEZyb21XaW5kb3coKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QWN0dWFsRG9tYWluKHdpbikgPT09IGdldEFjdHVhbERvbWFpbih3aW5kb3cpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgICAgIH0od2luKSkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNBYm91dFByb3RvY29sKHdpbikgJiYgY2FuUmVhZEZyb21XaW5kb3coKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgaWYgKGdldERvbWFpbih3aW5kb3cpID09PSBnZXREb21haW4od2luKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gYXNzZXJ0U2FtZURvbWFpbih3aW4pIHtcblx0ICAgICAgICAgICAgaWYgKCFpc1NhbWVEb21haW4od2luKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgd2luZG93IHRvIGJlIHNhbWUgZG9tYWluXCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gd2luO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc0FuY2VzdG9yUGFyZW50KHBhcmVudCwgY2hpbGQpIHtcblx0ICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgIHZhciBjaGlsZFBhcmVudCA9IGdldFBhcmVudChjaGlsZCk7XG5cdCAgICAgICAgICAgIHJldHVybiBjaGlsZFBhcmVudCA/IGNoaWxkUGFyZW50ID09PSBwYXJlbnQgOiAtMSAhPT0gZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoO3dpbi5wYXJlbnQgIT09IHdpbjsgKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHdpbi5wYXJlbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW4gPSB3aW4ucGFyZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH0oY2hpbGQpLmluZGV4T2YocGFyZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnJhbWVzKHdpbikge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgIHZhciBmcmFtZXM7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBmcmFtZXMgPSB3aW4uZnJhbWVzO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGZyYW1lcyA9IHdpbjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgbGVuO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgbGVuID0gZnJhbWVzLmxlbmd0aDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICBpZiAoMCA9PT0gbGVuKSByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICBpZiAobGVuKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lID0gZnJhbWVzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgMTAwOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBfZnJhbWUgPSBmcmFtZXNbX2ldO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICghX2ZyYW1lKSByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX2ZyYW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaWZyYW1lV2luZG93cyA9IFtdO1xuXHQgICAgICAgIHZhciBpZnJhbWVGcmFtZXMgPSBbXTtcblx0ICAgICAgICBmdW5jdGlvbiBpc1dpbmRvd0Nsb3NlZCh3aW4sIGFsbG93TW9jaykge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGFsbG93TW9jayAmJiAoYWxsb3dNb2NrID0gITApO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXdpbikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbi5jbG9zZWQpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gIWVyciB8fCBlcnIubWVzc2FnZSAhPT0gSUVfV0lOX0FDQ0VTU19FUlJPUjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoYWxsb3dNb2NrICYmIGlzU2FtZURvbWFpbih3aW4pKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbi5tb2NrY2xvc2VkKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghd2luLnBhcmVudCB8fCAhd2luLnRvcCkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHZhciBpZnJhbWVJbmRleCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGlvbltpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICAgIH0oaWZyYW1lV2luZG93cywgd2luKTtcblx0ICAgICAgICAgICAgaWYgKC0xICE9PSBpZnJhbWVJbmRleCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gaWZyYW1lRnJhbWVzW2lmcmFtZUluZGV4XTtcblx0ICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBmdW5jdGlvbihmcmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZnJhbWUuY29udGVudFdpbmRvdykgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZnJhbWUucGFyZW50Tm9kZSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSBmcmFtZS5vd25lckRvY3VtZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudCAmJiAhZG9jLmRvY3VtZW50RWxlbWVudC5jb250YWlucyhmcmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGZyYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDtwYXJlbnQucGFyZW50Tm9kZSAmJiBwYXJlbnQucGFyZW50Tm9kZSAhPT0gcGFyZW50OyApIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC5ob3N0IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHBhcmVudC5ob3N0KSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICB9KGZyYW1lKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0QW5jZXN0b3Iod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICByZXR1cm4gZ2V0T3BlbmVyKHdpbiA9IHdpbiB8fCB3aW5kb3cpIHx8IGdldFBhcmVudCh3aW4pIHx8IHZvaWQgMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gbWF0Y2hEb21haW4ocGF0dGVybiwgb3JpZ2luKSB7XG5cdCAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBwYXR0ZXJuKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2Ygb3JpZ2luKSByZXR1cm4gXCIqXCIgPT09IHBhdHRlcm4gfHwgb3JpZ2luID09PSBwYXR0ZXJuO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzUmVnZXgob3JpZ2luKSkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBpc1JlZ2V4KHBhdHRlcm4pID8gaXNSZWdleChvcmlnaW4pID8gcGF0dGVybi50b1N0cmluZygpID09PSBvcmlnaW4udG9TdHJpbmcoKSA6ICFBcnJheS5pc0FycmF5KG9yaWdpbikgJiYgQm9vbGVhbihvcmlnaW4ubWF0Y2gocGF0dGVybikpIDogISFBcnJheS5pc0FycmF5KHBhdHRlcm4pICYmIChBcnJheS5pc0FycmF5KG9yaWdpbikgPyBKU09OLnN0cmluZ2lmeShwYXR0ZXJuKSA9PT0gSlNPTi5zdHJpbmdpZnkob3JpZ2luKSA6ICFpc1JlZ2V4KG9yaWdpbikgJiYgcGF0dGVybi5zb21lKChmdW5jdGlvbihzdWJwYXR0ZXJuKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hEb21haW4oc3VicGF0dGVybiwgb3JpZ2luKTtcblx0ICAgICAgICAgICAgfSkpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqID09PSB3aW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChcIltvYmplY3QgV2luZG93XVwiID09PSB7fS50b1N0cmluZy5jYWxsKG9iaikpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuV2luZG93ICYmIG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5XaW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnNlbGYgPT09IG9iaikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmoucGFyZW50ID09PSBvYmopIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnRvcCA9PT0gb2JqKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqICYmIFwiX191bmxpa2VseV92YWx1ZV9fXCIgPT09IG9iai5fX2Nyb3NzX2RvbWFpbl91dGlsc193aW5kb3dfY2hlY2tfXykgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwicG9zdE1lc3NhZ2VcIiBpbiBvYmogJiYgXCJzZWxmXCIgaW4gb2JqICYmIFwibG9jYXRpb25cIiBpbiBvYmopIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYW1lRm9yV2luZG93KHdpbikge1xuXHQgICAgICAgICAgICBpZiAoaXNTYW1lRG9tYWluKHdpbikpIHJldHVybiBhc3NlcnRTYW1lRG9tYWluKHdpbikuZnJhbWVFbGVtZW50O1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaTIxID0gMCwgX2RvY3VtZW50JHF1ZXJ5U2VsZWN0MiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpZnJhbWVcIik7IF9pMjEgPCBfZG9jdW1lbnQkcXVlcnlTZWxlY3QyLmxlbmd0aDsgX2kyMSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBfZG9jdW1lbnQkcXVlcnlTZWxlY3QyW19pMjFdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZyYW1lICYmIGZyYW1lLmNvbnRlbnRXaW5kb3cgJiYgZnJhbWUuY29udGVudFdpbmRvdyA9PT0gd2luKSByZXR1cm4gZnJhbWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gY2xvc2VXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIGlmIChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0UGFyZW50KHdpbikpO1xuXHQgICAgICAgICAgICB9KHdpbikpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGdldEZyYW1lRm9yV2luZG93KHdpbik7XG5cdCAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgZnJhbWUucGFyZW50RWxlbWVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZyYW1lLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZnJhbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgd2luLmNsb3NlKCk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gdXRpbHNfaXNQcm9taXNlKGl0ZW0pIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghaXRlbSkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFByb21pc2UgJiYgaXRlbSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW5kb3cuV2luZG93ICYmIGl0ZW0gaW5zdGFuY2VvZiB3aW5kb3cuV2luZG93KSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygd2luZG93LmNvbnN0cnVjdG9yICYmIGl0ZW0gaW5zdGFuY2VvZiB3aW5kb3cuY29uc3RydWN0b3IpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIHZhciBfdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblx0ICAgICAgICAgICAgICAgIGlmIChfdG9TdHJpbmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF90b1N0cmluZy5jYWxsKGl0ZW0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChcIltvYmplY3QgV2luZG93XVwiID09PSBuYW1lIHx8IFwiW29iamVjdCBnbG9iYWxdXCIgPT09IG5hbWUgfHwgXCJbb2JqZWN0IERPTVdpbmRvd11cIiA9PT0gbmFtZSkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlbS50aGVuKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGRpc3BhdGNoZWRFcnJvcnMgPSBbXTtcblx0ICAgICAgICB2YXIgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMgPSBbXTtcblx0ICAgICAgICB2YXIgYWN0aXZlQ291bnQgPSAwO1xuXHQgICAgICAgIHZhciBmbHVzaFByb21pc2U7XG5cdCAgICAgICAgZnVuY3Rpb24gZmx1c2hBY3RpdmUoKSB7XG5cdCAgICAgICAgICAgIGlmICghYWN0aXZlQ291bnQgJiYgZmx1c2hQcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZsdXNoUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIGZsdXNoUHJvbWlzZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGFydEFjdGl2ZSgpIHtcblx0ICAgICAgICAgICAgYWN0aXZlQ291bnQgKz0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZW5kQWN0aXZlKCkge1xuXHQgICAgICAgICAgICBhY3RpdmVDb3VudCAtPSAxO1xuXHQgICAgICAgICAgICBmbHVzaEFjdGl2ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHJvbWlzZV9aYWxnb1Byb21pc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gWmFsZ29Qcm9taXNlKGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RlZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gITE7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gITE7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9ICExO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX2Vycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9ICExO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZWplY3RlZCA9ICExO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpc0FzeW5jID0gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKChmdW5jdGlvbihyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jKSBfdGhpcy5yZXNvbHZlKHJlcyk7IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdCA9IHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jKSBfdGhpcy5yZWplY3QoZXJyKTsgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXJyb3IgPSBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaXNBc3luYyA9ICEwO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID8gdGhpcy5yZXNvbHZlKF9yZXN1bHQpIDogcmVqZWN0ZWQgJiYgdGhpcy5yZWplY3QoX2Vycm9yKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgX3Byb3RvID0gWmFsZ29Qcm9taXNlLnByb3RvdHlwZTtcblx0ICAgICAgICAgICAgX3Byb3RvLnJlc29sdmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVkIHx8IHRoaXMucmVqZWN0ZWQpIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICAgICAgaWYgKHV0aWxzX2lzUHJvbWlzZShyZXN1bHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGFub3RoZXIgcHJvbWlzZVwiKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnJlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVkIHx8IHRoaXMucmVqZWN0ZWQpIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICAgICAgaWYgKHV0aWxzX2lzUHJvbWlzZShlcnJvcikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVqZWN0IHByb21pc2Ugd2l0aCBhbm90aGVyIHByb21pc2VcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9lcnIgPSBlcnJvciAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGVycm9yLnRvU3RyaW5nID8gZXJyb3IudG9TdHJpbmcoKSA6IHt9LnRvU3RyaW5nLmNhbGwoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiRXhwZWN0ZWQgcmVqZWN0IHRvIGJlIGNhbGxlZCB3aXRoIEVycm9yLCBnb3QgXCIgKyBfZXJyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkIHx8IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzMi5lcnJvckhhbmRsZWQgfHwgZnVuY3Rpb24oZXJyLCBwcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gZGlzcGF0Y2hlZEVycm9ycy5pbmRleE9mKGVycikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZWRFcnJvcnMucHVzaChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5sZW5ndGg7IGorKykgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnNbal0oZXJyLCBwcm9taXNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0oZXJyb3IsIF90aGlzMik7XG5cdCAgICAgICAgICAgICAgICB9KSwgMSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmFzeW5jUmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gITA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmRpc3BhdGNoID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmVkLCByZWplY3RlZCA9IHRoaXMucmVqZWN0ZWQsIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5kaXNwYXRjaGluZyAmJiAocmVzb2x2ZWQgfHwgcmVqZWN0ZWQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9ICEwO1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoYWluID0gZnVuY3Rpb24oZmlyc3RQcm9taXNlLCBzZWNvbmRQcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdFByb21pc2UudGhlbigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlc29sdmUocmVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9oYW5kbGVycyRpID0gaGFuZGxlcnNbaV0sIG9uU3VjY2VzcyA9IF9oYW5kbGVycyRpLm9uU3VjY2Vzcywgb25FcnJvciA9IF9oYW5kbGVycyRpLm9uRXJyb3IsIHByb21pc2UgPSBfaGFuZGxlcnMkaS5wcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdDIgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQyID0gb25TdWNjZXNzID8gb25TdWNjZXNzKHRoaXMudmFsdWUpIDogdGhpcy52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVqZWN0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb25FcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0MiA9IG9uRXJyb3IodGhpcy5lcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcmVzdWx0MiBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSAmJiAoX3Jlc3VsdDIucmVzb2x2ZWQgfHwgX3Jlc3VsdDIucmVqZWN0ZWQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZVJlc3VsdCA9IF9yZXN1bHQyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc3VsdC5yZXNvbHZlZCA/IHByb21pc2UucmVzb2x2ZShwcm9taXNlUmVzdWx0LnZhbHVlKSA6IHByb21pc2UucmVqZWN0KHByb21pc2VSZXN1bHQuZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc3VsdC5lcnJvckhhbmRsZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHV0aWxzX2lzUHJvbWlzZShfcmVzdWx0MikgPyBfcmVzdWx0MiBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSAmJiAoX3Jlc3VsdDIucmVzb2x2ZWQgfHwgX3Jlc3VsdDIucmVqZWN0ZWQpID8gX3Jlc3VsdDIucmVzb2x2ZWQgPyBwcm9taXNlLnJlc29sdmUoX3Jlc3VsdDIudmFsdWUpIDogcHJvbWlzZS5yZWplY3QoX3Jlc3VsdDIuZXJyb3IpIDogY2hhaW4oX3Jlc3VsdDIsIHByb21pc2UpIDogcHJvbWlzZS5yZXNvbHZlKF9yZXN1bHQyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMubGVuZ3RoID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by50aGVuID0gZnVuY3Rpb24ob25TdWNjZXNzLCBvbkVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob25TdWNjZXNzICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb25TdWNjZXNzICYmICFvblN1Y2Nlc3MuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS50aGVuIGV4cGVjdGVkIGEgZnVuY3Rpb24gZm9yIHN1Y2Nlc3MgaGFuZGxlclwiKTtcblx0ICAgICAgICAgICAgICAgIGlmIChvbkVycm9yICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb25FcnJvciAmJiAhb25FcnJvci5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRoZW4gZXhwZWN0ZWQgYSBmdW5jdGlvbiBmb3IgZXJyb3IgaGFuZGxlclwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFphbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaCh7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcblx0ICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IG9uU3VjY2Vzcyxcblx0ICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gITA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmNhdGNoID0gZnVuY3Rpb24ob25FcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIG9uRXJyb3IpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZmluYWxseSA9IGZ1bmN0aW9uKG9uRmluYWxseSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9uRmluYWxseSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uRmluYWxseSAmJiAhb25GaW5hbGx5LmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UuZmluYWxseSBleHBlY3RlZCBhIGZ1bmN0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbigoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS50cnkob25GaW5hbGx5KS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UudHJ5KG9uRmluYWxseSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by50aW1lb3V0ID0gZnVuY3Rpb24odGltZSwgZXJyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVkIHx8IHRoaXMucmVqZWN0ZWQpIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpczMucmVzb2x2ZWQgfHwgX3RoaXMzLnJlamVjdGVkIHx8IF90aGlzMy5yZWplY3QoZXJyIHx8IG5ldyBFcnJvcihcIlByb21pc2UgdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZSArIFwibXNcIikpO1xuXHQgICAgICAgICAgICAgICAgfSksIHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbigoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by50b1Byb21pc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBQcm9taXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ291bGQgbm90IGZpbmQgUHJvbWlzZVwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5sYXp5ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSA/IHZhbHVlIDogdXRpbHNfaXNQcm9taXNlKHZhbHVlKSA/IG5ldyBaYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICB9KSkgOiAobmV3IFphbGdvUHJvbWlzZSkucmVzb2x2ZSh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgWmFsZ29Qcm9taXNlKS5yZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuYXN5bmNSZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgWmFsZ29Qcm9taXNlKS5hc3luY1JlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5hbGwgPSBmdW5jdGlvbihwcm9taXNlcykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gcHJvbWlzZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXS5zbGljZSgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBjaGFpbiA9IGZ1bmN0aW9uKGksIGZpcnN0UHJvbWlzZSwgc2Vjb25kUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdFByb21pc2UudGhlbigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDAgPT0gKGNvdW50IC09IDEpICYmIHByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByb20gPSBwcm9taXNlc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvbSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvbS5yZXNvbHZlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHByb20udmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF1dGlsc19pc1Byb21pc2UocHJvbSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHByb207XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjaGFpbihpLCBaYWxnb1Byb21pc2UucmVzb2x2ZShwcm9tKSwgcHJvbWlzZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAwID09PSBjb3VudCAmJiBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmhhc2ggPSBmdW5jdGlvbihwcm9taXNlcykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgICAgICAgICAgICAgdmFyIGF3YWl0UHJvbWlzZXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb21pc2VzW2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzX2lzUHJvbWlzZSh2YWx1ZSkgPyBhd2FpdFByb21pc2VzLnB1c2godmFsdWUudGhlbigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSA6IHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9taXNlcykgX2xvb3Aoa2V5KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UuYWxsKGF3YWl0UHJvbWlzZXMpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5tYXAgPSBmdW5jdGlvbihpdGVtcywgbWV0aG9kKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLmFsbChpdGVtcy5tYXAobWV0aG9kKSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5vblBvc3NpYmx5VW5oYW5kbGVkRXhjZXB0aW9uID0gZnVuY3Rpb24oaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5zcGxpY2UocG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfShoYW5kbGVyKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnRyeSA9IGZ1bmN0aW9uKG1ldGhvZCwgY29udGV4dCwgYXJncykge1xuXHQgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG1ldGhvZCAmJiAhbWV0aG9kLmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UudHJ5IGV4cGVjdGVkIGEgZnVuY3Rpb25cIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgc3RhcnRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MgfHwgW10pO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uKF9kZWxheSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBaYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIF9kZWxheSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5pc1Byb21pc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlKSB8fCB1dGlsc19pc1Byb21pc2UodmFsdWUpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuZmx1c2ggPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihaYWxnbykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZmx1c2hQcm9taXNlID0gZmx1c2hQcm9taXNlIHx8IG5ldyBaYWxnbztcblx0ICAgICAgICAgICAgICAgICAgICBmbHVzaEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgfShaYWxnb1Byb21pc2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgIH0oKTtcblx0ICAgICAgICBmdW5jdGlvbiB1dGlsX3NhZmVJbmRleE9mKGNvbGxlY3Rpb24sIGl0ZW0pIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25baV0gPT09IGl0ZW0pIHJldHVybiBpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBDcm9zc0RvbWFpblNhZmVXZWFrTWFwKCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy53ZWFrbWFwID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5rZXlzID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBcIl9fd2Vha21hcF9cIiArICgxZTkgKiBNYXRoLnJhbmRvbSgpID4+PiAwKSArIFwiX19cIjtcblx0ICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IE9iamVjdC5mcmVlemUpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdFdlYWtNYXAgPSBuZXcgV2Vha01hcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RLZXkgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0ZXN0S2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGVzdFdlYWtNYXAuc2V0KHRlc3RLZXksIFwiX190ZXN0dmFsdWVfX1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiX190ZXN0dmFsdWVfX1wiID09PSB0ZXN0V2Vha01hcC5nZXQodGVzdEtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KCkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWFrbWFwID0gbmV3IFdlYWtNYXA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLmtleXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW107XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIF9wcm90byA9IENyb3NzRG9tYWluU2FmZVdlYWtNYXAucHJvdG90eXBlO1xuXHQgICAgICAgICAgICBfcHJvdG8uX2NsZWFudXBDbG9zZWRXaW5kb3dzID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0ga2V5c1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3codmFsdWUpICYmIGlzV2luZG93Q2xvc2VkKHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYWttYXAuZGVsZXRlKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uaXNTYWZlVG9SZWFkV3JpdGUgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhaXNXaW5kb3coa2V5KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIGV4cGVjdGVkIGtleVwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgd2Vha21hcC5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbbmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdID0gdmFsdWUgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkoa2V5LCBuYW1lLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbIGtleSwgdmFsdWUgXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZihrZXlzLCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKC0xID09PSBpbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXQgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIGV4cGVjdGVkIGtleVwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXAuaGFzKGtleSkpIHJldHVybiB3ZWFrbWFwLmdldChrZXkpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA6IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB1dGlsX3NhZmVJbmRleE9mKHRoaXMua2V5cywga2V5KTtcblx0ICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaW5kZXgpIHJldHVybiB0aGlzLnZhbHVlc1tpbmRleF07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5kZWxldGUgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIGV4cGVjdGVkIGtleVwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgd2Vha21hcC5kZWxldGUoa2V5KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkgJiYgKGVudHJ5WzBdID0gZW50cnlbMV0gPSB2b2lkIDApO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZihrZXlzLCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKC0xICE9PSBpbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleXMuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uaGFzID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwLmhhcyhrZXkpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gISghZW50cnkgfHwgZW50cnlbMF0gIT09IGtleSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xICE9PSB1dGlsX3NhZmVJbmRleE9mKHRoaXMua2V5cywga2V5KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldE9yU2V0ID0gZnVuY3Rpb24oa2V5LCBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSByZXR1cm4gdGhpcy5nZXQoa2V5KTtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldHRlcigpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBDcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuXHQgICAgICAgIH0oKTtcblx0ICAgICAgICBmdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZuLm5hbWUgfHwgZm4uX19uYW1lX18gfHwgZm4uZGlzcGxheU5hbWUgfHwgXCJhbm9ueW1vdXNcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0RnVuY3Rpb25OYW1lKGZuLCBuYW1lKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZm4ubmFtZTtcblx0ICAgICAgICAgICAgICAgIGZuLm5hbWUgPSBuYW1lO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIGZuLl9fbmFtZV9fID0gZm4uZGlzcGxheU5hbWUgPSBuYW1lO1xuXHQgICAgICAgICAgICByZXR1cm4gZm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHVuaXF1ZUlEKCkge1xuXHQgICAgICAgICAgICB2YXIgY2hhcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcblx0ICAgICAgICAgICAgcmV0dXJuIFwidWlkX1wiICsgXCJ4eHh4eHh4eHh4XCIucmVwbGFjZSgvLi9nLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCkpO1xuXHQgICAgICAgICAgICB9KSkgKyBcIl9cIiArIGZ1bmN0aW9uKHN0cikge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYnRvYSkgcmV0dXJuIGJ0b2EoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgKGZ1bmN0aW9uKG0sIHAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocDEsIDE2KSk7XG5cdCAgICAgICAgICAgICAgICB9KSkpLnJlcGxhY2UoL1s9XS9nLCBcIlwiKTtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBCdWZmZXIpIHJldHVybiBCdWZmZXIuZnJvbShzdHIsIFwidXRmOFwiKS50b1N0cmluZyhcImJhc2U2NFwiKS5yZXBsYWNlKC9bPV0vZywgXCJcIik7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGZpbmQgd2luZG93LmJ0b2Egb3IgQnVmZmVyXCIpO1xuXHQgICAgICAgICAgICB9KChuZXcgRGF0ZSkudG9JU09TdHJpbmcoKS5zbGljZSgxMSwgMTkpLnJlcGxhY2UoXCJUXCIsIFwiLlwiKSkucmVwbGFjZSgvW15hLXpBLVowLTldL2csIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBvYmplY3RJRHM7XG5cdCAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplQXJncyhhcmdzKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoW10uc2xpY2UuY2FsbChhcmdzKSwgKGZ1bmN0aW9uKHN1YmtleSwgdmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gXCJtZW1vaXplW1wiICsgZnVuY3Rpb24ob2JqKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdElEcyA9IG9iamVjdElEcyB8fCBuZXcgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PSBvYmogfHwgXCJvYmplY3RcIiAhPSB0eXBlb2Ygb2JqICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb2JqKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9iamVjdFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVpZCA9IG9iamVjdElEcy5nZXQob2JqKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1aWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZCA9IHR5cGVvZiBvYmogKyBcIjpcIiArIHVuaXF1ZUlEKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMuc2V0KG9iaiwgdWlkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdWlkO1xuXHQgICAgICAgICAgICAgICAgICAgIH0odmFsKSArIFwiXVwiIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIHZhbCBpbnN0YW5jZW9mIHdpbmRvdy5FbGVtZW50IHx8IG51bGwgIT09IHZhbCAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWwgJiYgMSA9PT0gdmFsLm5vZGVUeXBlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbC5zdHlsZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWwub3duZXJEb2N1bWVudCA/IHt9IDogdmFsO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50cyBub3Qgc2VyaWFsaXphYmxlIC0tIGNhbiBub3QgYmUgdXNlZCB0byBtZW1vaXplXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEVtcHR5T2JqZWN0KCkge1xuXHQgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBtZW1vaXplR2xvYmFsSW5kZXggPSAwO1xuXHQgICAgICAgIHZhciBtZW1vaXplR2xvYmFsSW5kZXhWYWxpZEZyb20gPSAwO1xuXHQgICAgICAgIGZ1bmN0aW9uIG1lbW9pemUobWV0aG9kLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0aW9ucyAmJiAob3B0aW9ucyA9IHt9KTtcblx0ICAgICAgICAgICAgdmFyIF9vcHRpb25zJHRoaXNOYW1lc3BhYyA9IG9wdGlvbnMudGhpc05hbWVzcGFjZSwgdGhpc05hbWVzcGFjZSA9IHZvaWQgMCAhPT0gX29wdGlvbnMkdGhpc05hbWVzcGFjICYmIF9vcHRpb25zJHRoaXNOYW1lc3BhYywgY2FjaGVUaW1lID0gb3B0aW9ucy50aW1lO1xuXHQgICAgICAgICAgICB2YXIgc2ltcGxlQ2FjaGU7XG5cdCAgICAgICAgICAgIHZhciB0aGlzQ2FjaGU7XG5cdCAgICAgICAgICAgIHZhciBtZW1vaXplSW5kZXggPSBtZW1vaXplR2xvYmFsSW5kZXg7XG5cdCAgICAgICAgICAgIG1lbW9pemVHbG9iYWxJbmRleCArPSAxO1xuXHQgICAgICAgICAgICB2YXIgbWVtb2l6ZWRGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgICAgICAgICAgICAgaWYgKG1lbW9pemVJbmRleCA8IG1lbW9pemVHbG9iYWxJbmRleFZhbGlkRnJvbSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHNpbXBsZUNhY2hlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzQ2FjaGUgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIG1lbW9pemVJbmRleCA9IG1lbW9pemVHbG9iYWxJbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICBtZW1vaXplR2xvYmFsSW5kZXggKz0gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBjYWNoZTtcblx0ICAgICAgICAgICAgICAgIGNhY2hlID0gdGhpc05hbWVzcGFjZSA/ICh0aGlzQ2FjaGUgPSB0aGlzQ2FjaGUgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcCkuZ2V0T3JTZXQodGhpcywgZ2V0RW1wdHlPYmplY3QpIDogc2ltcGxlQ2FjaGUgPSBzaW1wbGVDYWNoZSB8fCB7fTtcblx0ICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXkgPSBzZXJpYWxpemVBcmdzKGFyZ3MpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBjYWNoZVJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcblx0ICAgICAgICAgICAgICAgIGlmIChjYWNoZVJlc3VsdCAmJiBjYWNoZVRpbWUgJiYgRGF0ZS5ub3coKSAtIGNhY2hlUmVzdWx0LnRpbWUgPCBjYWNoZVRpbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVbY2FjaGVLZXldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhY2hlUmVzdWx0ID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChjYWNoZVJlc3VsdCkgcmV0dXJuIGNhY2hlUmVzdWx0LnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGltZTogdGltZSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIG1lbW9pemVkRnVuY3Rpb24ucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHNpbXBsZUNhY2hlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIHRoaXNDYWNoZSA9IG51bGw7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUobWVtb2l6ZWRGdW5jdGlvbiwgKG9wdGlvbnMubmFtZSB8fCBnZXRGdW5jdGlvbk5hbWUobWV0aG9kKSkgKyBcIjo6bWVtb2l6ZWRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG1lbW9pemUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZVByb21pc2UobWV0aG9kKSB7XG5cdCAgICAgICAgICAgIHZhciBjYWNoZSA9IHt9O1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBtZW1vaXplZFByb21pc2VGdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzLCBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXkgPSBzZXJpYWxpemVBcmdzKGFyZ3MpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybiBjYWNoZVtrZXldO1xuXHQgICAgICAgICAgICAgICAgY2FjaGVba2V5XSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShfdGhpcywgX2FyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICB9KSkuZmluYWxseSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVba2V5XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBtZW1vaXplZFByb21pc2VGdW5jdGlvbi5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgY2FjaGUgPSB7fTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldEZ1bmN0aW9uTmFtZShtZW1vaXplZFByb21pc2VGdW5jdGlvbiwgZ2V0RnVuY3Rpb25OYW1lKG1ldGhvZCkgKyBcIjo6cHJvbWlzZU1lbW9pemVkXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzcmNfdXRpbF9ub29wKCkge31cblx0ICAgICAgICBmdW5jdGlvbiBzdHJpbmdpZnlFcnJvcihlcnIsIGxldmVsKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gbGV2ZWwgJiYgKGxldmVsID0gMSk7XG5cdCAgICAgICAgICAgIGlmIChsZXZlbCA+PSAzKSByZXR1cm4gXCJzdHJpbmdpZnlFcnJvciBzdGFjayBvdmVyZmxvd1wiO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHJldHVybiBcIjx1bmtub3duIGVycm9yOiBcIiArIHt9LnRvU3RyaW5nLmNhbGwoZXJyKSArIFwiPlwiO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGVycikgcmV0dXJuIGVycjtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IGVyciAmJiBlcnIuc3RhY2s7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2U7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrICYmIG1lc3NhZ2UpIHJldHVybiAtMSAhPT0gc3RhY2suaW5kZXhPZihtZXNzYWdlKSA/IHN0YWNrIDogbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2spIHJldHVybiBzdGFjaztcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkgcmV0dXJuIG1lc3NhZ2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZXJyICYmIGVyci50b1N0cmluZyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGVyci50b1N0cmluZyA/IGVyci50b1N0cmluZygpIDoge30udG9TdHJpbmcuY2FsbChlcnIpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChuZXdFcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBcIkVycm9yIHdoaWxlIHN0cmluZ2lmeWluZyBlcnJvcjogXCIgKyBzdHJpbmdpZnlFcnJvcihuZXdFcnIsIGxldmVsICsgMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RyaW5naWZ5KGl0ZW0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGl0ZW0gPyBpdGVtIDogaXRlbSAmJiBpdGVtLnRvU3RyaW5nICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlbS50b1N0cmluZyA/IGl0ZW0udG9TdHJpbmcoKSA6IHt9LnRvU3RyaW5nLmNhbGwoaXRlbSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG1lbW9pemUoKGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcykgcmV0dXJuIE9iamVjdC52YWx1ZXMob2JqKTtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiByZXN1bHQucHVzaChvYmpba2V5XSk7XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIGZ1bmN0aW9uIHV0aWxfaXNSZWdleChpdGVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiB1dGlsX2dldE9yU2V0KG9iaiwga2V5LCBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gb2JqW2tleV07XG5cdCAgICAgICAgICAgIHZhciB2YWwgPSBnZXR0ZXIoKTtcblx0ICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG5cdCAgICAgICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblx0ICAgICAgICAgICAgaWYgKCFib2R5KSB0aHJvdyBuZXcgRXJyb3IoXCJCb2R5IGVsZW1lbnQgbm90IGZvdW5kXCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gYm9keTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNEb2N1bWVudFJlYWR5KCkge1xuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihkb2N1bWVudC5ib2R5KSAmJiBcImNvbXBsZXRlXCIgPT09IGRvY3VtZW50LnJlYWR5U3RhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRJbnRlcmFjdGl2ZSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZG9jdW1lbnQuYm9keSkgJiYgXCJpbnRlcmFjdGl2ZVwiID09PSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtZW1vaXplKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnRSZWFkeSgpIHx8IGlzRG9jdW1lbnRJbnRlcmFjdGl2ZSgpKSByZXR1cm4gcmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvY3VtZW50UmVhZHkoKSB8fCBpc0RvY3VtZW50SW50ZXJhY3RpdmUoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KSwgMTApO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIHZhciBjdXJyZW50U2NyaXB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZG9jdW1lbnQgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0IDogbnVsbDtcblx0ICAgICAgICB2YXIgZ2V0Q3VycmVudFNjcmlwdCA9IG1lbW9pemUoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudFNjcmlwdCkgcmV0dXJuIGN1cnJlbnRTY3JpcHQ7XG5cdCAgICAgICAgICAgIGlmIChjdXJyZW50U2NyaXB0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyLnN0YWNrIHx8IFwiXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrRGV0YWlscyA9IC8uKmF0IFteKF0qXFwoKC4qKTooLispOiguKylcXCkkL2dpLmV4ZWMoc3RhY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHRMb2NhdGlvbiA9IHN0YWNrRGV0YWlscyAmJiBzdGFja0RldGFpbHNbMV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFzY3JpcHRMb2NhdGlvbikgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMjIgPSAwLCBfQXJyYXkkcHJvdG90eXBlJHNsaWMyID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKSkucmV2ZXJzZSgpOyBfaTIyIDwgX0FycmF5JHByb3RvdHlwZSRzbGljMi5sZW5ndGg7IF9pMjIrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0ID0gX0FycmF5JHByb3RvdHlwZSRzbGljMltfaTIyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcmlwdC5zcmMgJiYgc2NyaXB0LnNyYyA9PT0gc2NyaXB0TG9jYXRpb24pIHJldHVybiBzY3JpcHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB9KCkpIHJldHVybiBjdXJyZW50U2NyaXB0O1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRldGVybWluZSBjdXJyZW50IHNjcmlwdFwiKTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRVSUQgPSB1bmlxdWVJRCgpO1xuXHQgICAgICAgIG1lbW9pemUoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgc2NyaXB0O1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgc2NyaXB0ID0gZ2V0Q3VycmVudFNjcmlwdCgpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50VUlEO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB1aWQgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS11aWRcIik7XG5cdCAgICAgICAgICAgIGlmICh1aWQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdWlkKSByZXR1cm4gdWlkO1xuXHQgICAgICAgICAgICBpZiAoKHVpZCA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVpZC1hdXRvXCIpKSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB1aWQpIHJldHVybiB1aWQ7XG5cdCAgICAgICAgICAgIGlmIChzY3JpcHQuc3JjKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaGFzaGVkU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IHN0cltpXS5jaGFyQ29kZUF0KDApICogaTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyW2kgKyAxXSAmJiAodG90YWwgKz0gc3RyW2kgKyAxXS5jaGFyQ29kZUF0KDApICogKGkgLSAxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIE1hdGguYWJzKHRvdGFsKSAlIDI2KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgICAgICAgICB9KEpTT04uc3RyaW5naWZ5KHtcblx0ICAgICAgICAgICAgICAgICAgICBzcmM6IHNjcmlwdC5zcmMsXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YXNldDogc2NyaXB0LmRhdGFzZXRcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHVpZCA9IFwidWlkX1wiICsgaGFzaGVkU3RyaW5nLnNsaWNlKGhhc2hlZFN0cmluZy5sZW5ndGggLSAzMCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB1aWQgPSB1bmlxdWVJRCgpO1xuXHQgICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKFwiZGF0YS11aWQtYXV0b1wiLCB1aWQpO1xuXHQgICAgICAgICAgICByZXR1cm4gdWlkO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBmdW5jdGlvbiBnbG9iYWxfZ2V0R2xvYmFsKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgdmFyIGdsb2JhbEtleSA9IFwiX19wb3N0X3JvYm90XzEwXzBfNDZfX1wiO1xuXHQgICAgICAgICAgICByZXR1cm4gd2luICE9PSB3aW5kb3cgPyB3aW5bZ2xvYmFsS2V5XSA6IHdpbltnbG9iYWxLZXldID0gd2luW2dsb2JhbEtleV0gfHwge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBnZXRPYmogPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZnVuY3Rpb24gZ2xvYmFsU3RvcmUoa2V5LCBkZWZTdG9yZSkge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGtleSAmJiAoa2V5ID0gXCJzdG9yZVwiKTtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBkZWZTdG9yZSAmJiAoZGVmU3RvcmUgPSBnZXRPYmopO1xuXHQgICAgICAgICAgICByZXR1cm4gdXRpbF9nZXRPclNldChnbG9iYWxfZ2V0R2xvYmFsKCksIGtleSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gZGVmU3RvcmUoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzOiBmdW5jdGlvbihzdG9yZUtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuaGFzT3duUHJvcGVydHkoc3RvcmVLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihzdG9yZUtleSwgZGVmVmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShzdG9yZUtleSkgPyBzdG9yZVtzdG9yZUtleV0gOiBkZWZWYWw7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHN0b3JlS2V5LCB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbc3RvcmVLZXldID0gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsOiBmdW5jdGlvbihzdG9yZUtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmVbc3RvcmVLZXldO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0T3JTZXQ6IGZ1bmN0aW9uKHN0b3JlS2V5LCBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoc3RvcmUsIHN0b3JlS2V5LCBnZXR0ZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZSA9IGRlZlN0b3JlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0b3JlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBXaWxkQ2FyZCA9IGZ1bmN0aW9uKCkge307XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0V2lsZGNhcmQoKSB7XG5cdCAgICAgICAgICAgIHZhciBnbG9iYWwgPSBnbG9iYWxfZ2V0R2xvYmFsKCk7XG5cdCAgICAgICAgICAgIGdsb2JhbC5XSU5ET1dfV0lMRENBUkQgPSBnbG9iYWwuV0lORE9XX1dJTERDQVJEIHx8IG5ldyBXaWxkQ2FyZDtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbC5XSU5ET1dfV0lMRENBUkQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHdpbmRvd1N0b3JlKGtleSwgZGVmU3RvcmUpIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBrZXkgJiYgKGtleSA9IFwic3RvcmVcIik7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVmU3RvcmUgJiYgKGRlZlN0b3JlID0gZ2V0T2JqKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwid2luZG93U3RvcmVcIikuZ2V0T3JTZXQoa2V5LCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luU3RvcmUgPSBuZXcgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuXHQgICAgICAgICAgICAgICAgdmFyIGdldFN0b3JlID0gZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblN0b3JlLmdldE9yU2V0KHdpbiwgZGVmU3RvcmUpO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzOiBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFN0b3JlKHdpbikuaGFzT3duUHJvcGVydHkoa2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24od2luLCBkZWZWYWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gZ2V0U3RvcmUod2luKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmhhc093blByb3BlcnR5KGtleSkgPyBzdG9yZVtrZXldIDogZGVmVmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih3aW4sIHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZXRTdG9yZSh3aW4pW2tleV0gPSB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBkZWw6IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZ2V0U3RvcmUod2luKVtrZXldO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0T3JTZXQ6IGZ1bmN0aW9uKHdpbiwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsX2dldE9yU2V0KGdldFN0b3JlKHdpbiksIGtleSwgZ2V0dGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEluc3RhbmNlSUQoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcImluc3RhbmNlXCIpLmdldE9yU2V0KFwiaW5zdGFuY2VJRFwiLCB1bmlxdWVJRCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVIZWxsb1Byb21pc2Uod2luLCBfcmVmKSB7XG5cdCAgICAgICAgICAgIHZhciBkb21haW4gPSBfcmVmLmRvbWFpbjtcblx0ICAgICAgICAgICAgdmFyIGhlbGxvUHJvbWlzZXMgPSB3aW5kb3dTdG9yZShcImhlbGxvUHJvbWlzZXNcIik7XG5cdCAgICAgICAgICAgIHZhciBleGlzdGluZ1Byb21pc2UgPSBoZWxsb1Byb21pc2VzLmdldCh3aW4pO1xuXHQgICAgICAgICAgICBleGlzdGluZ1Byb21pc2UgJiYgZXhpc3RpbmdQcm9taXNlLnJlc29sdmUoe1xuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHZhciBuZXdQcm9taXNlID0gcHJvbWlzZV9aYWxnb1Byb21pc2UucmVzb2x2ZSh7XG5cdCAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgaGVsbG9Qcm9taXNlcy5zZXQod2luLCBuZXdQcm9taXNlKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNheUhlbGxvKHdpbiwgX3JlZjQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVmNC5zZW5kKSh3aW4sIFwicG9zdHJvYm90X2hlbGxvXCIsIHtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlSUQ6IGdldEluc3RhbmNlSUQoKVxuXHQgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICBkb21haW46IFwiKlwiLFxuXHQgICAgICAgICAgICAgICAgdGltZW91dDogLTFcblx0ICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBfcmVmNS5vcmlnaW4sIGluc3RhbmNlSUQgPSBfcmVmNS5kYXRhLmluc3RhbmNlSUQ7XG5cdCAgICAgICAgICAgICAgICByZXNvbHZlSGVsbG9Qcm9taXNlKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgd2luOiB3aW4sXG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJRDogaW5zdGFuY2VJRFxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRXaW5kb3dJbnN0YW5jZUlEKHdpbiwgX3JlZjYpIHtcblx0ICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNi5zZW5kO1xuXHQgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJ3aW5kb3dJbnN0YW5jZUlEUHJvbWlzZXNcIikuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2F5SGVsbG8od2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjcpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjcuaW5zdGFuY2VJRDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBtYXJrV2luZG93S25vd24od2luKSB7XG5cdCAgICAgICAgICAgIHdpbmRvd1N0b3JlKFwia25vd25XaW5kb3dzXCIpLnNldCh3aW4sICEwKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNTZXJpYWxpemVkVHlwZShpdGVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiID09IHR5cGVvZiBpdGVtICYmIG51bGwgIT09IGl0ZW0gJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgaXRlbS5fX3R5cGVfXztcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZGV0ZXJtaW5lVHlwZSh2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdmFsID8gXCJ1bmRlZmluZWRcIiA6IG51bGwgPT09IHZhbCA/IFwibnVsbFwiIDogQXJyYXkuaXNBcnJheSh2YWwpID8gXCJhcnJheVwiIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWwgPyBcImZ1bmN0aW9uXCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWwgPyB2YWwgaW5zdGFuY2VvZiBFcnJvciA/IFwiZXJyb3JcIiA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsLnRoZW4gPyBcInByb21pc2VcIiA6IFwiW29iamVjdCBSZWdFeHBdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwodmFsKSA/IFwicmVnZXhcIiA6IFwiW29iamVjdCBEYXRlXVwiID09PSB7fS50b1N0cmluZy5jYWxsKHZhbCkgPyBcImRhdGVcIiA6IFwib2JqZWN0XCIgOiBcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgPyBcInN0cmluZ1wiIDogXCJudW1iZXJcIiA9PSB0eXBlb2YgdmFsID8gXCJudW1iZXJcIiA6IFwiYm9vbGVhblwiID09IHR5cGVvZiB2YWwgPyBcImJvb2xlYW5cIiA6IHZvaWQgMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplVHlwZSh0eXBlLCB2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIF9fdHlwZV9fOiB0eXBlLFxuXHQgICAgICAgICAgICAgICAgX192YWxfXzogdmFsXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBfU0VSSUFMSVpFUjtcblx0ICAgICAgICB2YXIgU0VSSUFMSVpFUiA9ICgoX1NFUklBTElaRVIgPSB7fSkuZnVuY3Rpb24gPSBmdW5jdGlvbigpIHt9LCBfU0VSSUFMSVpFUi5lcnJvciA9IGZ1bmN0aW9uKF9yZWYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJlcnJvclwiLCB7XG5cdCAgICAgICAgICAgICAgICBtZXNzYWdlOiBfcmVmLm1lc3NhZ2UsXG5cdCAgICAgICAgICAgICAgICBzdGFjazogX3JlZi5zdGFjayxcblx0ICAgICAgICAgICAgICAgIGNvZGU6IF9yZWYuY29kZSxcblx0ICAgICAgICAgICAgICAgIGRhdGE6IF9yZWYuZGF0YVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5wcm9taXNlID0gZnVuY3Rpb24oKSB7fSwgX1NFUklBTElaRVIucmVnZXggPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJyZWdleFwiLCB2YWwuc291cmNlKTtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5kYXRlID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwiZGF0ZVwiLCB2YWwudG9KU09OKCkpO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLmFycmF5ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIub2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIuc3RyaW5nID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIubnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIuYm9vbGVhbiA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLm51bGwgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUlt2b2lkIDBdID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwidW5kZWZpbmVkXCIsIHZhbCk7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIpO1xuXHQgICAgICAgIHZhciBkZWZhdWx0U2VyaWFsaXplcnMgPSB7fTtcblx0ICAgICAgICB2YXIgX0RFU0VSSUFMSVpFUjtcblx0ICAgICAgICB2YXIgREVTRVJJQUxJWkVSID0gKChfREVTRVJJQUxJWkVSID0ge30pLmZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHNlcmlhbGl6YXRpb24gaXMgbm90IGltcGxlbWVudGVkOyBub3RoaW5nIHRvIGRlc2VyaWFsaXplXCIpO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuZXJyb3IgPSBmdW5jdGlvbihfcmVmMikge1xuXHQgICAgICAgICAgICB2YXIgc3RhY2sgPSBfcmVmMi5zdGFjaywgY29kZSA9IF9yZWYyLmNvZGUsIGRhdGEgPSBfcmVmMi5kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoX3JlZjIubWVzc2FnZSk7XG5cdCAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuXHQgICAgICAgICAgICBkYXRhICYmIChlcnJvci5kYXRhID0gZGF0YSk7XG5cdCAgICAgICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2sgKyBcIlxcblxcblwiICsgZXJyb3Iuc3RhY2s7XG5cdCAgICAgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLnByb21pc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBzZXJpYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZDsgbm90aGluZyB0byBkZXNlcmlhbGl6ZVwiKTtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLnJlZ2V4ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHZhbCk7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5kYXRlID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWwpO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuYXJyYXkgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLm9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuc3RyaW5nID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5udW1iZXIgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmJvb2xlYW4gPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLm51bGwgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSW3ZvaWQgMF0gPSBmdW5jdGlvbigpIHt9LCBfREVTRVJJQUxJWkVSKTtcblx0ICAgICAgICB2YXIgZGVmYXVsdERlc2VyaWFsaXplcnMgPSB7fTtcblx0ICAgICAgICBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keSkgcmV0dXJuIHJlc29sdmUod2luZG93LmRvY3VtZW50LmJvZHkpO1xuXHQgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUod2luZG93LmRvY3VtZW50LmJvZHkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KSwgMTApO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBmdW5jdGlvbiBjbGVhbnVwUHJveHlXaW5kb3dzKCkge1xuXHQgICAgICAgICAgICB2YXIgaWRUb1Byb3h5V2luZG93ID0gZ2xvYmFsU3RvcmUoXCJpZFRvUHJveHlXaW5kb3dcIik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9pZFRvUHJveHlXaW5kb3cka2V5czIgPSBpZFRvUHJveHlXaW5kb3cua2V5cygpOyBfaTIgPCBfaWRUb1Byb3h5V2luZG93JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpZCA9IF9pZFRvUHJveHlXaW5kb3cka2V5czJbX2kyXTtcblx0ICAgICAgICAgICAgICAgIGlkVG9Qcm94eVdpbmRvdy5nZXQoaWQpLnNob3VsZENsZWFuKCkgJiYgaWRUb1Byb3h5V2luZG93LmRlbChpZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0U2VyaWFsaXplZFdpbmRvdyh3aW5Qcm9taXNlLCBfcmVmKSB7XG5cdCAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZi5zZW5kLCBfcmVmJGlkID0gX3JlZi5pZCwgaWQgPSB2b2lkIDAgPT09IF9yZWYkaWQgPyB1bmlxdWVJRCgpIDogX3JlZiRpZDtcblx0ICAgICAgICAgICAgdmFyIHdpbmRvd05hbWVQcm9taXNlID0gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpc1NhbWVEb21haW4od2luKSkgcmV0dXJuIGFzc2VydFNhbWVEb21haW4od2luKS5uYW1lO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHZhciB3aW5kb3dUeXBlUHJvbWlzZSA9IHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luZG93KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luZG93KSkgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IGlzIGNsb3NlZCwgY2FuIG5vdCBkZXRlcm1pbmUgdHlwZVwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBnZXRPcGVuZXIod2luZG93KSA/IFwicG9wdXBcIiA6IFwiaWZyYW1lXCI7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgd2luZG93TmFtZVByb21pc2UuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgICAgIHdpbmRvd1R5cGVQcm9taXNlLmNhdGNoKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgICAgICB2YXIgZ2V0TmFtZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1dpbmRvd0Nsb3NlZCh3aW4pKSByZXR1cm4gaXNTYW1lRG9tYWluKHdpbikgPyBhc3NlcnRTYW1lRG9tYWluKHdpbikubmFtZSA6IHdpbmRvd05hbWVQcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1R5cGVQcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGdldEluc3RhbmNlSUQ6IG1lbW9pemVQcm9taXNlKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvd0luc3RhbmNlSUQod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKSxcblx0ICAgICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKGNsb3NlV2luZG93KTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBnZXROYW1lOiBnZXROYW1lLFxuXHQgICAgICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW4uZm9jdXMoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgaXNDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNXaW5kb3dDbG9zZWQod2luKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgc2V0TG9jYXRpb246IGZ1bmN0aW9uKGhyZWYsIG9wdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG9wdHMgJiYgKG9wdHMgPSB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9vcHRzJG1ldGhvZCA9IG9wdHMubWV0aG9kLCBtZXRob2QgPSB2b2lkIDAgPT09IF9vcHRzJG1ldGhvZCA/IFwiZ2V0XCIgOiBfb3B0cyRtZXRob2QsIGJvZHkgPSBvcHRzLmJvZHk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBocmVmLmluZGV4T2YoXCIvXCIpKSBocmVmID0gXCJcIiArIGRvbWFpbiArIGhyZWY7IGVsc2UgaWYgKCFocmVmLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy8pICYmIDAgIT09IGhyZWYuaW5kZXhPZihkb21haW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB1cmwgdG8gYmUgaHR0cCBvciBodHRwcyB1cmwsIG9yIGFic29sdXRlIHBhdGgsIGdvdCBcIiArIEpTT04uc3RyaW5naWZ5KGhyZWYpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwicG9zdFwiID09PSBtZXRob2QpIHJldHVybiBnZXROYW1lKCkudGhlbigoZnVuY3Rpb24obmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHBvc3QgdG8gd2luZG93IHdpdGhvdXQgdGFyZ2V0IG5hbWVcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oX3JlZjMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gX3JlZjMudXJsLCB0YXJnZXQgPSBfcmVmMy50YXJnZXQsIGJvZHkgPSBfcmVmMy5ib2R5LCBfcmVmMyRtZXRob2QgPSBfcmVmMy5tZXRob2QsIG1ldGhvZCA9IHZvaWQgMCA9PT0gX3JlZjMkbWV0aG9kID8gXCJwb3N0XCIgOiBfcmVmMyRtZXRob2Q7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLCB0YXJnZXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwibWV0aG9kXCIsIG1ldGhvZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIiwgdXJsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSkgZm9yICh2YXIgX2kyNCA9IDAsIF9PYmplY3Qka2V5czQgPSBPYmplY3Qua2V5cyhib2R5KTsgX2kyNCA8IF9PYmplY3Qka2V5czQubGVuZ3RoOyBfaTI0KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9ib2R5JGtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9PYmplY3Qka2V5czRbX2kyNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBudWxsID09IChfYm9keSRrZXkgPSBib2R5W2tleV0pID8gdm9pZCAwIDogX2JvZHkka2V5LnRvU3RyaW5nKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Qm9keSgpLmFwcGVuZENoaWxkKGZvcm0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Qm9keSgpLnJlbW92ZUNoaWxkKGZvcm0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBocmVmLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJnZXRcIiAhPT0gbWV0aG9kKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBtZXRob2Q6IFwiICsgbWV0aG9kKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbi5sb2NhdGlvbiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbi5sb2NhdGlvbi5yZXBsYWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luLmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5sb2NhdGlvbiA9IGhyZWY7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhbWVEb21haW4gPSBpc1NhbWVEb21haW4od2luKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gZ2V0RnJhbWVGb3JXaW5kb3cod2luKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHNldCBuYW1lIGZvciBjcm9zcy1kb21haW4gd2luZG93OiBcIiArIG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRTYW1lRG9tYWluKHdpbikubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lICYmIGZyYW1lLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgbmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWVQcm9taXNlID0gcHJvbWlzZV9aYWxnb1Byb21pc2UucmVzb2x2ZShuYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB3aW5kb3dfUHJveHlXaW5kb3cgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gUHJveHlXaW5kb3coX3JlZjIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjIuc2VuZCwgd2luID0gX3JlZjIud2luLCBzZXJpYWxpemVkV2luZG93ID0gX3JlZjIuc2VyaWFsaXplZFdpbmRvdztcblx0ICAgICAgICAgICAgICAgIHRoaXMuaWQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlzUHJveHlXaW5kb3cgPSAhMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZFdpbmRvdyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93ID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZW5kID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlID0gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVkV2luZG93ID0gc2VyaWFsaXplZFdpbmRvdyB8fCBnZXRTZXJpYWxpemVkV2luZG93KHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoXCJpZFRvUHJveHlXaW5kb3dcIikuc2V0KHRoaXMuZ2V0SUQoKSwgdGhpcyk7XG5cdCAgICAgICAgICAgICAgICB3aW4gJiYgdGhpcy5zZXRXaW5kb3cod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIF9wcm90byA9IFByb3h5V2luZG93LnByb3RvdHlwZTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldElEID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmlkO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0VHlwZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5nZXRUeXBlKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5pc1BvcHVwID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkudGhlbigoZnVuY3Rpb24odHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInBvcHVwXCIgPT09IHR5cGU7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uKGhyZWYsIG9wdHMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LnNldExvY2F0aW9uKGhyZWYsIG9wdHMpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldE5hbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZ2V0TmFtZSgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2V0TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5zZXROYW1lKG5hbWUpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczI7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmNsb3NlKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMztcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmZvY3VzID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHZhciBpc1BvcHVwUHJvbWlzZSA9IHRoaXMuaXNQb3B1cCgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGdldE5hbWVQcm9taXNlID0gdGhpcy5nZXROYW1lKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVvcGVuUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLmhhc2goe1xuXHQgICAgICAgICAgICAgICAgICAgIGlzUG9wdXA6IGlzUG9wdXBQcm9taXNlLFxuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU6IGdldE5hbWVQcm9taXNlXG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmMykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICBfcmVmMy5pc1BvcHVwICYmIG5hbWUgJiYgd2luZG93Lm9wZW4oXCJcIiwgbmFtZSwgXCJub29wZW5lclwiKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHZhciBmb2N1c1Byb21pc2UgPSB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZm9jdXMoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwoWyByZW9wZW5Qcm9taXNlLCBmb2N1c1Byb21pc2UgXSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmlzQ2xvc2VkID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmlzQ2xvc2VkKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRXaW5kb3cgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdHVhbFdpbmRvdztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNldFdpbmRvdyA9IGZ1bmN0aW9uKHdpbiwgX3JlZjQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjQuc2VuZDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93ID0gd2luO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlLnJlc29sdmUodGhpcy5hY3R1YWxXaW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVkV2luZG93ID0gZ2V0U2VyaWFsaXplZFdpbmRvdyh0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kLFxuXHQgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmdldElEKClcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgd2luZG93U3RvcmUoXCJ3aW5Ub1Byb3h5V2luZG93XCIpLnNldCh3aW4sIHRoaXMpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uYXdhaXRXaW5kb3cgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2U7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5tYXRjaFdpbmRvdyA9IGZ1bmN0aW9uKHdpbiwgX3JlZjUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNS5zZW5kO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNS5hY3R1YWxXaW5kb3cgPyB3aW4gPT09IF90aGlzNS5hY3R1YWxXaW5kb3cgOiBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlJbnN0YW5jZUlEOiBfdGhpczUuZ2V0SW5zdGFuY2VJRCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBrbm93bldpbmRvd0luc3RhbmNlSUQ6IGdldFdpbmRvd0luc3RhbmNlSUQod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gX3JlZjYucHJveHlJbnN0YW5jZUlEID09PSBfcmVmNi5rbm93bldpbmRvd0luc3RhbmNlSUQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoICYmIF90aGlzNS5zZXRXaW5kb3cod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udW53cmFwID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaW5kb3cgfHwgdGhpcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldEluc3RhbmNlSUQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZ2V0SW5zdGFuY2VJRCgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2hvdWxkQ2xlYW4gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuYWN0dWFsV2luZG93ICYmIGlzV2luZG93Q2xvc2VkKHRoaXMuYWN0dWFsV2luZG93KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3c7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LnVud3JhcCA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFByb3h5V2luZG93LmlzUHJveHlXaW5kb3cod2luKSA/IHdpbi51bndyYXAoKSA6IHdpbjtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cuc2VyaWFsaXplID0gZnVuY3Rpb24od2luLCBfcmVmNykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNy5zZW5kO1xuXHQgICAgICAgICAgICAgICAgY2xlYW51cFByb3h5V2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFByb3h5V2luZG93LnRvUHJveHlXaW5kb3cod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSkuc2VyaWFsaXplKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LmRlc2VyaWFsaXplID0gZnVuY3Rpb24oc2VyaWFsaXplZFdpbmRvdywgX3JlZjgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjguc2VuZDtcblx0ICAgICAgICAgICAgICAgIGNsZWFudXBQcm94eVdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcImlkVG9Qcm94eVdpbmRvd1wiKS5nZXQoc2VyaWFsaXplZFdpbmRvdy5pZCkgfHwgbmV3IFByb3h5V2luZG93KHtcblx0ICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkV2luZG93OiBzZXJpYWxpemVkV2luZG93LFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93ID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihvYmogJiYgIWlzV2luZG93KG9iaikgJiYgb2JqLmlzUHJveHlXaW5kb3cpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy50b1Byb3h5V2luZG93ID0gZnVuY3Rpb24od2luLCBfcmVmOSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmOS5zZW5kO1xuXHQgICAgICAgICAgICAgICAgY2xlYW51cFByb3h5V2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgaWYgKFByb3h5V2luZG93LmlzUHJveHlXaW5kb3cod2luKSkgcmV0dXJuIHdpbjtcblx0ICAgICAgICAgICAgICAgIHZhciBhY3R1YWxXaW5kb3cgPSB3aW47XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJ3aW5Ub1Byb3h5V2luZG93XCIpLmdldChhY3R1YWxXaW5kb3cpIHx8IG5ldyBQcm94eVdpbmRvdyh7XG5cdCAgICAgICAgICAgICAgICAgICAgd2luOiBhY3R1YWxXaW5kb3csXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBQcm94eVdpbmRvdztcblx0ICAgICAgICB9KCk7XG5cdCAgICAgICAgZnVuY3Rpb24gYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIHNvdXJjZSwgZG9tYWluKSB7XG5cdCAgICAgICAgICAgIHZhciBtZXRob2RTdG9yZSA9IHdpbmRvd1N0b3JlKFwibWV0aG9kU3RvcmVcIik7XG5cdCAgICAgICAgICAgIHZhciBwcm94eVdpbmRvd01ldGhvZHMgPSBnbG9iYWxTdG9yZShcInByb3h5V2luZG93TWV0aG9kc1wiKTtcblx0ICAgICAgICAgICAgaWYgKHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHNvdXJjZSkpIHByb3h5V2luZG93TWV0aG9kcy5zZXQoaWQsIHtcblx0ICAgICAgICAgICAgICAgIHZhbDogdmFsLFxuXHQgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2Vcblx0ICAgICAgICAgICAgfSk7IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcHJveHlXaW5kb3dNZXRob2RzLmRlbChpZCk7XG5cdCAgICAgICAgICAgICAgICBtZXRob2RTdG9yZS5nZXRPclNldChzb3VyY2UsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgICAgICB9KSlbaWRdID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsOiB2YWwsXG5cdCAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2Vcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gbG9va3VwTWV0aG9kKHNvdXJjZSwgaWQpIHtcblx0ICAgICAgICAgICAgdmFyIG1ldGhvZFN0b3JlID0gd2luZG93U3RvcmUoXCJtZXRob2RTdG9yZVwiKTtcblx0ICAgICAgICAgICAgdmFyIHByb3h5V2luZG93TWV0aG9kcyA9IGdsb2JhbFN0b3JlKFwicHJveHlXaW5kb3dNZXRob2RzXCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gbWV0aG9kU3RvcmUuZ2V0T3JTZXQoc291cmNlLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgIH0pKVtpZF0gfHwgcHJveHlXaW5kb3dNZXRob2RzLmdldChpZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bmN0aW9uX3NlcmlhbGl6ZUZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCBfcmVmMykge1xuXHQgICAgICAgICAgICBvbiA9IChfcmVmID0ge1xuXHQgICAgICAgICAgICAgICAgb246IF9yZWYzLm9uLFxuXHQgICAgICAgICAgICAgICAgc2VuZDogX3JlZjMuc2VuZFxuXHQgICAgICAgICAgICB9KS5vbiwgc2VuZCA9IF9yZWYuc2VuZCwgZ2xvYmFsU3RvcmUoXCJidWlsdGluTGlzdGVuZXJzXCIpLmdldE9yU2V0KFwiZnVuY3Rpb25DYWxsc1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb24oXCJwb3N0cm9ib3RfbWV0aG9kXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IFwiKlwiXG5cdCAgICAgICAgICAgICAgICB9LCAoZnVuY3Rpb24oX3JlZjIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gX3JlZjIuc291cmNlLCBvcmlnaW4gPSBfcmVmMi5vcmlnaW4sIGRhdGEgPSBfcmVmMi5kYXRhO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGRhdGEuaWQsIG5hbWUgPSBkYXRhLm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGggPSBsb29rdXBNZXRob2Qoc291cmNlLCBpZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRoKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBtZXRob2QgJ1wiICsgbmFtZSArIFwiJyB3aXRoIGlkOiBcIiArIGRhdGEuaWQgKyBcIiBpbiBcIiArIGdldERvbWFpbih3aW5kb3cpKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kU291cmNlID0gbWV0aC5zb3VyY2UsIGRvbWFpbiA9IG1ldGguZG9tYWluLCB2YWwgPSBtZXRoLnZhbDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbihkb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCAnXCIgKyBkYXRhLm5hbWUgKyBcIicgZG9tYWluIFwiICsgSlNPTi5zdHJpbmdpZnkodXRpbF9pc1JlZ2V4KG1ldGguZG9tYWluKSA/IG1ldGguZG9tYWluLnNvdXJjZSA6IG1ldGguZG9tYWluKSArIFwiIGRvZXMgbm90IG1hdGNoIG9yaWdpbiBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgZ2V0RG9tYWluKHdpbmRvdykpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3cobWV0aG9kU291cmNlKSkgcmV0dXJuIG1ldGhvZFNvdXJjZS5tYXRjaFdpbmRvdyhzb3VyY2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24obWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBjYWxsICdcIiArIGRhdGEubmFtZSArIFwiJyBmYWlsZWQgLSBwcm94eSB3aW5kb3cgZG9lcyBub3QgbWF0Y2ggc291cmNlIGluIFwiICsgZ2V0RG9tYWluKHdpbmRvdykpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmFwcGx5KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGF0YS5hcmdzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwub25FcnJvcikgcmV0dXJuIHZhbC5vbkVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayAmJiAoZXJyLnN0YWNrID0gXCJSZW1vdGUgY2FsbCB0byBcIiArIG5hbWUgKyBcIihcIiArIGZ1bmN0aW9uKGFyZ3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGFyZ3MgJiYgKGFyZ3MgPSBbXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpdGVtID0gYXJncywgW10uc2xpY2UuY2FsbChpdGVtKSkubWFwKChmdW5jdGlvbihhcmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGFyZyA/IFwiJ1wiICsgYXJnICsgXCInXCIgOiB2b2lkIDAgPT09IGFyZyA/IFwidW5kZWZpbmVkXCIgOiBudWxsID09PSBhcmcgPyBcIm51bGxcIiA6IFwiYm9vbGVhblwiID09IHR5cGVvZiBhcmcgPyBhcmcudG9TdHJpbmcoKSA6IEFycmF5LmlzQXJyYXkoYXJnKSA/IFwiWyAuLi4gXVwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgYXJnID8gXCJ7IC4uLiB9XCIgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFyZyA/IFwiKCkgPT4geyAuLi4gfVwiIDogXCI8XCIgKyB0eXBlb2YgYXJnICsgXCI+XCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmpvaW4oXCIsIFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oZGF0YS5hcmdzKSArIFwiKSBmYWlsZWRcXG5cXG5cIiArIGVyci5zdGFjayk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgdmFyIF9yZWYsIG9uLCBzZW5kO1xuXHQgICAgICAgICAgICB2YXIgaWQgPSB2YWwuX19pZF9fIHx8IHVuaXF1ZUlEKCk7XG5cdCAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gd2luZG93X1Byb3h5V2luZG93LnVud3JhcChkZXN0aW5hdGlvbik7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gdmFsLl9fbmFtZV9fIHx8IHZhbC5uYW1lIHx8IGtleTtcblx0ICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgbmFtZSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG5hbWUuaW5kZXhPZiAmJiAwID09PSBuYW1lLmluZGV4T2YoXCJhbm9ueW1vdXM6OlwiKSAmJiAobmFtZSA9IG5hbWUucmVwbGFjZShcImFub255bW91czo6XCIsIGtleSArIFwiOjpcIikpO1xuXHQgICAgICAgICAgICBpZiAod2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3coZGVzdGluYXRpb24pKSB7XG5cdCAgICAgICAgICAgICAgICBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgZGVzdGluYXRpb24sIGRvbWFpbik7XG5cdCAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5hd2FpdFdpbmRvdygpLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIGFkZE1ldGhvZChpZCwgdmFsLCBuYW1lLCB3aW4sIGRvbWFpbik7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgZGVzdGluYXRpb24sIGRvbWFpbik7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwiY3Jvc3NfZG9tYWluX2Z1bmN0aW9uXCIsIHtcblx0ICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZU1lc3NhZ2UoZGVzdGluYXRpb24sIGRvbWFpbiwgb2JqLCBfcmVmKSB7XG5cdCAgICAgICAgICAgIHZhciBfc2VyaWFsaXplO1xuXHQgICAgICAgICAgICB2YXIgb24gPSBfcmVmLm9uLCBzZW5kID0gX3JlZi5zZW5kO1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBzZXJpYWxpemVycykge1xuXHQgICAgICAgICAgICAgICAgdm9pZCAwID09PSBzZXJpYWxpemVycyAmJiAoc2VyaWFsaXplcnMgPSBkZWZhdWx0U2VyaWFsaXplcnMpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KG9iaiwgKGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzW2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFR5cGUodGhpcykpIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBkZXRlcm1pbmVUeXBlKHZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlKSByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVyID0gc2VyaWFsaXplcnNbdHlwZV0gfHwgU0VSSUFMSVpFUlt0eXBlXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplciA/IHNlcmlhbGl6ZXIodmFsLCBrZXkpIDogdmFsO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gcmVzdWx0ID8gXCJ1bmRlZmluZWRcIiA6IHJlc3VsdDtcblx0ICAgICAgICAgICAgfShvYmosICgoX3NlcmlhbGl6ZSA9IHt9KS5wcm9taXNlID0gZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCB2YWwsIGtleSwgX3JlZikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwiY3Jvc3NfZG9tYWluX3phbGdvX3Byb21pc2VcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbl9zZXJpYWxpemVGdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCAoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSksIGtleSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IF9yZWYub24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBfcmVmLnNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIF9zZXJpYWxpemUuZnVuY3Rpb24gPSBmdW5jdGlvbih2YWwsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uX3NlcmlhbGl6ZUZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCBfc2VyaWFsaXplLm9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2luZG93KHZhbCkgfHwgd2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3codmFsKSA/IHNlcmlhbGl6ZVR5cGUoXCJjcm9zc19kb21haW5fd2luZG93XCIsIHdpbmRvd19Qcm94eVdpbmRvdy5zZXJpYWxpemUodmFsLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSkpIDogdmFsO1xuXHQgICAgICAgICAgICB9LCBfc2VyaWFsaXplKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGRlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwgX3JlZjIpIHtcblx0ICAgICAgICAgICAgdmFyIF9kZXNlcmlhbGl6ZTtcblx0ICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmMi5zZW5kO1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RyLCBkZXNlcmlhbGl6ZXJzKSB7XG5cdCAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGRlc2VyaWFsaXplcnMgJiYgKGRlc2VyaWFsaXplcnMgPSBkZWZhdWx0RGVzZXJpYWxpemVycyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gc3RyKSByZXR1cm4gSlNPTi5wYXJzZShzdHIsIChmdW5jdGlvbihrZXksIHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRUeXBlKHRoaXMpKSByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh2YWwpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSB2YWwuX190eXBlX187XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsLl9fdmFsX187XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGRldGVybWluZVR5cGUodmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdHlwZSkgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZXNlcmlhbGl6ZXIgPSBkZXNlcmlhbGl6ZXJzW3R5cGVdIHx8IERFU0VSSUFMSVpFUlt0eXBlXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVyID8gZGVzZXJpYWxpemVyKHZhbHVlLCBrZXkpIDogdmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0obWVzc2FnZSwgKChfZGVzZXJpYWxpemUgPSB7fSkuY3Jvc3NfZG9tYWluX3phbGdvX3Byb21pc2UgPSBmdW5jdGlvbihzZXJpYWxpemVkUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSwgb3JpZ2luLCBfcmVmMikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2UoX3JlZjIudGhlbik7XG5cdCAgICAgICAgICAgICAgICB9KDAsIDAsIHNlcmlhbGl6ZWRQcm9taXNlKTtcblx0ICAgICAgICAgICAgfSwgX2Rlc2VyaWFsaXplLmNyb3NzX2RvbWFpbl9mdW5jdGlvbiA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRGdW5jdGlvbikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSwgb3JpZ2luLCBfcmVmNCwgX3JlZjUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBfcmVmNC5pZCwgbmFtZSA9IF9yZWY0Lm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNS5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnZXREZXNlcmlhbGl6ZWRGdW5jdGlvbiA9IGZ1bmN0aW9uKG9wdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBvcHRzICYmIChvcHRzID0ge30pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHNvdXJjZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmF3YWl0V2luZG93KCkudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGggPSBsb29rdXBNZXRob2Qod2luLCBpZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGggJiYgbWV0aC52YWwgIT09IGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyKSByZXR1cm4gbWV0aC52YWwuYXBwbHkoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHdpbmRvdyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4oKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9hcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYXJncyA9IFtdLnNsaWNlLmNhbGwoX2FyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMuZmlyZUFuZEZvcmdldCA/IHNlbmQod2luLCBcInBvc3Ryb2JvdF9tZXRob2RcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IF9hcmdzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogITBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6IHNlbmQod2luLCBcInBvc3Ryb2JvdF9tZXRob2RcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IF9hcmdzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogITFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuY2F0Y2goKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX25hbWVfXyA9IG5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLl9fb3JpZ2luX18gPSBvcmlnaW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLl9fc291cmNlX18gPSBzb3VyY2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLl9faWRfXyA9IGlkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5vcmlnaW4gPSBvcmlnaW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcjtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlciA9IGdldERlc2VyaWFsaXplZEZ1bmN0aW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuZmlyZUFuZEZvcmdldCA9IGdldERlc2VyaWFsaXplZEZ1bmN0aW9uKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogITBcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXI7XG5cdCAgICAgICAgICAgICAgICB9KHNvdXJjZSwgb3JpZ2luLCBzZXJpYWxpemVkRnVuY3Rpb24sIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSwgX2Rlc2VyaWFsaXplLmNyb3NzX2RvbWFpbl93aW5kb3cgPSBmdW5jdGlvbihzZXJpYWxpemVkV2luZG93KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93LmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRXaW5kb3csIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSwgX2Rlc2VyaWFsaXplKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBTRU5EX01FU1NBR0VfU1RSQVRFR0lFUyA9IHt9O1xuXHQgICAgICAgIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTLnBvc3Ryb2JvdF9wb3N0X21lc3NhZ2UgPSBmdW5jdGlvbih3aW4sIHNlcmlhbGl6ZWRNZXNzYWdlLCBkb21haW4pIHtcblx0ICAgICAgICAgICAgMCA9PT0gZG9tYWluLmluZGV4T2YoXCJmaWxlOlwiKSAmJiAoZG9tYWluID0gXCIqXCIpO1xuXHQgICAgICAgICAgICB3aW4ucG9zdE1lc3NhZ2Uoc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmdW5jdGlvbiBzZW5kX3NlbmRNZXNzYWdlKHdpbiwgZG9tYWluLCBtZXNzYWdlLCBfcmVmMikge1xuXHQgICAgICAgICAgICB2YXIgb24gPSBfcmVmMi5vbiwgc2VuZCA9IF9yZWYyLnNlbmQ7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRvbWFpbkJ1ZmZlciA9IHdpbmRvd1N0b3JlKCkuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmJ1ZmZlciA9IGRvbWFpbkJ1ZmZlci5idWZmZXIgfHwgW107XG5cdCAgICAgICAgICAgICAgICBkb21haW5CdWZmZXIuYnVmZmVyLnB1c2gobWVzc2FnZSk7XG5cdCAgICAgICAgICAgICAgICBkb21haW5CdWZmZXIuZmx1c2ggPSBkb21haW5CdWZmZXIuZmx1c2ggfHwgcHJvbWlzZV9aYWxnb1Byb21pc2UuZmx1c2goKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IGlzIGNsb3NlZFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplZE1lc3NhZ2UgPSBzZXJpYWxpemVNZXNzYWdlKHdpbiwgZG9tYWluLCAoKF9yZWYgPSB7fSkuX19wb3N0X3JvYm90XzEwXzBfNDZfXyA9IGRvbWFpbkJ1ZmZlci5idWZmZXIgfHwgW10sIFxuXHQgICAgICAgICAgICAgICAgICAgIF9yZWYpLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkb21haW5CdWZmZXIuYnVmZmVyO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdHJhdGVnaWVzID0gT2JqZWN0LmtleXMoU0VORF9NRVNTQUdFX1NUUkFURUdJRVMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBzdHJhdGVnaWVzLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmF0ZWd5TmFtZSA9IHN0cmF0ZWdpZXNbX2kyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTW3N0cmF0ZWd5TmFtZV0od2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSBzdHJhdGVnaWVzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiQWxsIHBvc3Qtcm9ib3QgbWVzc2FnaW5nIHN0cmF0ZWdpZXMgZmFpbGVkOlxcblxcblwiICsgZXJyb3JzLm1hcCgoZnVuY3Rpb24oZXJyLCBpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpICsgXCIuIFwiICsgc3RyaW5naWZ5RXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSkuam9pbihcIlxcblxcblwiKSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluQnVmZmVyLmZsdXNoLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkb21haW5CdWZmZXIuZmx1c2g7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0pKS50aGVuKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRSZXNwb25zZUxpc3RlbmVyKGhhc2gpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuZ2V0KGhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBkZWxldGVSZXNwb25zZUxpc3RlbmVyKGhhc2gpIHtcblx0ICAgICAgICAgICAgZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKS5kZWwoaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQoaGFzaCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJlcnJvcmVkUmVzcG9uc2VMaXN0ZW5lcnNcIikuaGFzKGhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRSZXF1ZXN0TGlzdGVuZXIoX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSwgd2luID0gX3JlZi53aW4sIGRvbWFpbiA9IF9yZWYuZG9tYWluO1xuXHQgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVycyA9IHdpbmRvd1N0b3JlKFwicmVxdWVzdExpc3RlbmVyc1wiKTtcblx0ICAgICAgICAgICAgXCIqXCIgPT09IHdpbiAmJiAod2luID0gbnVsbCk7XG5cdCAgICAgICAgICAgIFwiKlwiID09PSBkb21haW4gJiYgKGRvbWFpbiA9IG51bGwpO1xuXHQgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIk5hbWUgcmVxdWlyZWQgdG8gZ2V0IHJlcXVlc3QgbGlzdGVuZXJcIik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9yZWYzID0gWyB3aW4sIGdldFdpbGRjYXJkKCkgXTsgX2k0IDwgX3JlZjMubGVuZ3RoOyBfaTQrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpblF1YWxpZmllciA9IF9yZWYzW19pNF07XG5cdCAgICAgICAgICAgICAgICBpZiAod2luUXVhbGlmaWVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVMaXN0ZW5lcnMgPSByZXF1ZXN0TGlzdGVuZXJzLmdldCh3aW5RdWFsaWZpZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lTGlzdGVuZXJzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW5MaXN0ZW5lcnMgPSBuYW1lTGlzdGVuZXJzW25hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGRvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnNbZG9tYWluXSkgcmV0dXJuIGRvbWFpbkxpc3RlbmVyc1tkb21haW5dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXykgZm9yICh2YXIgX2k2ID0gMCwgX2RvbWFpbkxpc3RlbmVycyRfX0RPMiA9IGRvbWFpbkxpc3RlbmVycy5fX2RvbWFpbl9yZWdleF9fOyBfaTYgPCBfZG9tYWluTGlzdGVuZXJzJF9fRE8yLmxlbmd0aDsgX2k2KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9kb21haW5MaXN0ZW5lcnMkX19ETzMgPSBfZG9tYWluTGlzdGVuZXJzJF9fRE8yW19pNl0sIGxpc3RlbmVyID0gX2RvbWFpbkxpc3RlbmVycyRfX0RPMy5saXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoRG9tYWluKF9kb21haW5MaXN0ZW5lcnMkX19ETzMucmVnZXgsIGRvbWFpbikpIHJldHVybiBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzW1wiKlwiXSkgcmV0dXJuIGRvbWFpbkxpc3RlbmVyc1tcIipcIl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgb24gPSBfcmVmLm9uLCBzZW5kID0gX3JlZi5zZW5kO1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldFJlcXVlc3RMaXN0ZW5lcih7XG5cdCAgICAgICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWUsXG5cdCAgICAgICAgICAgICAgICB3aW46IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB2YXIgbG9nTmFtZSA9IFwicG9zdHJvYm90X21ldGhvZFwiID09PSBtZXNzYWdlLm5hbWUgJiYgbWVzc2FnZS5kYXRhICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIG1lc3NhZ2UuZGF0YS5uYW1lID8gbWVzc2FnZS5kYXRhLm5hbWUgKyBcIigpXCIgOiBtZXNzYWdlLm5hbWU7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHNlbmRSZXNwb25zZShhY2ssIGRhdGEsIGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuZmx1c2goKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuZmlyZUFuZEZvcmdldCAmJiAhaXNXaW5kb3dDbG9zZWQoc291cmNlKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRfc2VuZE1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB1bmlxdWVJRCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4od2luZG93KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicG9zdHJvYm90X21lc3NhZ2VfcmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IG1lc3NhZ2UuaGFzaCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjazogYWNrLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZW5kIHJlc3BvbnNlIG1lc3NhZ2UgZmFpbGVkIGZvciBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCJcXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuYWxsKFsgcHJvbWlzZV9aYWxnb1Byb21pc2UuZmx1c2goKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5maXJlQW5kRm9yZ2V0ICYmICFpc1dpbmRvd0Nsb3NlZChzb3VyY2UpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB1bmlxdWVJRCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbih3aW5kb3cpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX2Fja1wiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBtZXNzYWdlLmhhc2gsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZVxuXHQgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZW5kIGFjayBtZXNzYWdlIGZhaWxlZCBmb3IgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiXFxuXFxuXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSkpLCBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuaGFuZGxlcih7XG5cdCAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YTogbWVzc2FnZS5kYXRhXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzZW5kUmVzcG9uc2UoXCJzdWNjZXNzXCIsIGRhdGEpO1xuXHQgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFJlc3BvbnNlKFwiZXJyb3JcIiwgbnVsbCwgZXJyb3IpO1xuXHQgICAgICAgICAgICB9KSkgXSkudGhlbihzcmNfdXRpbF9ub29wKS5jYXRjaCgoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZUVycm9yKSByZXR1cm4gb3B0aW9ucy5oYW5kbGVFcnJvcihlcnIpO1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUFjayhzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkge1xuXHQgICAgICAgICAgICBpZiAoIWlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQobWVzc2FnZS5oYXNoKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZSBhY2sgZm9yIG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKG9wdGlvbnMuZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2sgb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgZG9lcyBub3QgbWF0Y2ggZG9tYWluIFwiICsgb3B0aW9ucy5kb21haW4udG9TdHJpbmcoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gb3B0aW9ucy53aW4pIHRocm93IG5ldyBFcnJvcihcIkFjayBzb3VyY2UgZG9lcyBub3QgbWF0Y2ggcmVnaXN0ZXJlZCB3aW5kb3dcIik7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmFjayA9ICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSB7XG5cdCAgICAgICAgICAgIGlmICghaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZChtZXNzYWdlLmhhc2gpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldFJlc3BvbnNlTGlzdGVuZXIobWVzc2FnZS5oYXNoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKFwiTm8gaGFuZGxlciBmb3VuZCBmb3IgcG9zdCBtZXNzYWdlIHJlc3BvbnNlIGZvciBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcblx0ICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4ob3B0aW9ucy5kb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIG9yaWdpbiBcIiArIG9yaWdpbiArIFwiIGRvZXMgbm90IG1hdGNoIGRvbWFpbiBcIiArIChwYXR0ZXJuID0gb3B0aW9ucy5kb21haW4sIFxuXHQgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShwYXR0ZXJuKSA/IFwiKFwiICsgcGF0dGVybi5qb2luKFwiIHwgXCIpICsgXCIpXCIgOiBpc1JlZ2V4KHBhdHRlcm4pID8gXCJSZWdFeHAoXCIgKyBwYXR0ZXJuLnRvU3RyaW5nKCkgKyBcIilcIiA6IHBhdHRlcm4udG9TdHJpbmcoKSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm47XG5cdCAgICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSBvcHRpb25zLndpbikgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2Ugc291cmNlIGRvZXMgbm90IG1hdGNoIHJlZ2lzdGVyZWQgd2luZG93XCIpO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcihtZXNzYWdlLmhhc2gpO1xuXHQgICAgICAgICAgICAgICAgXCJlcnJvclwiID09PSBtZXNzYWdlLmFjayA/IG9wdGlvbnMucHJvbWlzZS5yZWplY3QobWVzc2FnZS5lcnJvcikgOiBcInN1Y2Nlc3NcIiA9PT0gbWVzc2FnZS5hY2sgJiYgb3B0aW9ucy5wcm9taXNlLnJlc29sdmUoe1xuXHQgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZV9yZWNlaXZlTWVzc2FnZShldmVudCwgX3JlZjIpIHtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZjIub24sIHNlbmQgPSBfcmVmMi5zZW5kO1xuXHQgICAgICAgICAgICB2YXIgcmVjZWl2ZWRNZXNzYWdlcyA9IGdsb2JhbFN0b3JlKFwicmVjZWl2ZWRNZXNzYWdlc1wiKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghd2luZG93IHx8IHdpbmRvdy5jbG9zZWQgfHwgIWV2ZW50LnNvdXJjZSkgcmV0dXJuO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgc291cmNlID0gZXZlbnQuc291cmNlLCBvcmlnaW4gPSBldmVudC5vcmlnaW47XG5cdCAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHNvdXJjZSwgb3JpZ2luLCBfcmVmKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmLm9uLCBzZW5kID0gX3JlZi5zZW5kO1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhcnNlZE1lc3NhZ2U7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcnNlZE1lc3NhZ2UgPSBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBwYXJzZWRNZXNzYWdlICYmIG51bGwgIT09IHBhcnNlZE1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VNZXNzYWdlcyA9IHBhcnNlZE1lc3NhZ2UuX19wb3N0X3JvYm90XzEwXzBfNDZfXztcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZU1lc3NhZ2VzKSkgcmV0dXJuIHBhcnNlTWVzc2FnZXM7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0oZXZlbnQuZGF0YSwgc291cmNlLCBvcmlnaW4sIHtcblx0ICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGlmIChtZXNzYWdlcykge1xuXHQgICAgICAgICAgICAgICAgbWFya1dpbmRvd0tub3duKHNvdXJjZSk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBtZXNzYWdlcy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBtZXNzYWdlc1tfaTJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlLmlkKSkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkTWVzc2FnZXMuc2V0KG1lc3NhZ2UuaWQsICEwKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQoc291cmNlKSAmJiAhbWVzc2FnZS5maXJlQW5kRm9yZ2V0KSByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgMCA9PT0gbWVzc2FnZS5vcmlnaW4uaW5kZXhPZihcImZpbGU6XCIpICYmIChvcmlnaW4gPSBcImZpbGU6Ly9cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJwb3N0cm9ib3RfbWVzc2FnZV9yZXF1ZXN0XCIgPT09IG1lc3NhZ2UudHlwZSA/IGhhbmRsZVJlcXVlc3Qoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3Jlc3BvbnNlXCIgPT09IG1lc3NhZ2UudHlwZSA/IGhhbmRsZVJlc3BvbnNlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSA6IFwicG9zdHJvYm90X21lc3NhZ2VfYWNrXCIgPT09IG1lc3NhZ2UudHlwZSAmJiBoYW5kbGVBY2soc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBvbl9vbihuYW1lLCBvcHRpb25zLCBoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbmFtZVwiKTtcblx0ICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgKG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9KSkge1xuXHQgICAgICAgICAgICAgICAgaGFuZGxlciA9IG9wdGlvbnM7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBoYW5kbGVyXCIpO1xuXHQgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVyID0gZnVuY3Rpb24gYWRkUmVxdWVzdExpc3RlbmVyKF9yZWY0LCBsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmNC5uYW1lLCB3aW5DYW5kaWRhdGUgPSBfcmVmNC53aW4sIGRvbWFpbiA9IF9yZWY0LmRvbWFpbjtcblx0ICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0TGlzdGVuZXJzID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0TGlzdGVuZXJzXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFuYW1lIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIG5hbWUpIHRocm93IG5ldyBFcnJvcihcIk5hbWUgcmVxdWlyZWQgdG8gYWRkIHJlcXVlc3QgbGlzdGVuZXJcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luQ2FuZGlkYXRlICYmIFwiKlwiICE9PSB3aW5DYW5kaWRhdGUgJiYgd2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3cod2luQ2FuZGlkYXRlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0TGlzdGVuZXJQcm9taXNlID0gd2luQ2FuZGlkYXRlLmF3YWl0V2luZG93KCkudGhlbigoZnVuY3Rpb24oYWN0dWFsV2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogYWN0dWFsV2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdExpc3RlbmVyUHJvbWlzZS50aGVuKChmdW5jdGlvbihyZXF1ZXN0TGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdExpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciB3aW4gPSB3aW5DYW5kaWRhdGU7XG5cdCAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3aW4pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyc0NvbGxlY3Rpb24gPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTggPSAwLCBfd2luMiA9IHdpbjsgX2k4IDwgX3dpbjIubGVuZ3RoOyBfaTgrKykgbGlzdGVuZXJzQ29sbGVjdGlvbi5wdXNoKGFkZFJlcXVlc3RMaXN0ZW5lcih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW46IF93aW4yW19pOF1cblx0ICAgICAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lcikpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IGxpc3RlbmVyc0NvbGxlY3Rpb24ubGVuZ3RoOyBfaTEwKyspIGxpc3RlbmVyc0NvbGxlY3Rpb25bX2kxMF0uY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZG9tYWluKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfbGlzdGVuZXJzQ29sbGVjdGlvbiA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTIgPSAwLCBfZG9tYWluMiA9IGRvbWFpbjsgX2kxMiA8IF9kb21haW4yLmxlbmd0aDsgX2kxMisrKSBfbGlzdGVuZXJzQ29sbGVjdGlvbi5wdXNoKGFkZFJlcXVlc3RMaXN0ZW5lcih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IF9kb21haW4yW19pMTJdXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIpKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxNCA9IDA7IF9pMTQgPCBfbGlzdGVuZXJzQ29sbGVjdGlvbi5sZW5ndGg7IF9pMTQrKykgX2xpc3RlbmVyc0NvbGxlY3Rpb25bX2kxNF0uY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nTGlzdGVuZXIgPSBnZXRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgd2luOiB3aW4sXG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgd2luICYmIFwiKlwiICE9PSB3aW4gfHwgKHdpbiA9IGdldFdpbGRjYXJkKCkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0ckRvbWFpbiA9IChkb21haW4gPSBkb21haW4gfHwgXCIqXCIpLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdMaXN0ZW5lcikgdGhyb3cgd2luICYmIGRvbWFpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIG9uIGRvbWFpbiBcIiArIGRvbWFpbi50b1N0cmluZygpICsgXCIgZm9yIFwiICsgKHdpbiA9PT0gZ2V0V2lsZGNhcmQoKSA/IFwid2lsZGNhcmRcIiA6IFwic3BlY2lmaWVkXCIpICsgXCIgd2luZG93XCIpIDogd2luID8gbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lICsgXCIgZm9yIFwiICsgKHdpbiA9PT0gZ2V0V2lsZGNhcmQoKSA/IFwid2lsZGNhcmRcIiA6IFwic3BlY2lmaWVkXCIpICsgXCIgd2luZG93XCIpIDogZG9tYWluID8gbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lICsgXCIgb24gZG9tYWluIFwiICsgZG9tYWluLnRvU3RyaW5nKCkpIDogbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lTGlzdGVuZXJzID0gcmVxdWVzdExpc3RlbmVycy5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZURvbWFpbkxpc3RlbmVycyA9IHV0aWxfZ2V0T3JTZXQod2luTmFtZUxpc3RlbmVycywgbmFtZSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnM7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICB1dGlsX2lzUmVnZXgoZG9tYWluKSA/ICh3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnMgPSB1dGlsX2dldE9yU2V0KHdpbk5hbWVEb21haW5MaXN0ZW5lcnMsIFwiX19kb21haW5fcmVnZXhfX1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgICAgICAgICAgfSkpKS5wdXNoKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBkb21haW4sXG5cdCAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG5cdCAgICAgICAgICAgICAgICB9KSA6IHdpbk5hbWVEb21haW5MaXN0ZW5lcnNbc3RyRG9tYWluXSA9IGxpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2luTmFtZURvbWFpbkxpc3RlbmVyc1tzdHJEb21haW5dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycy5zcGxpY2Uod2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzLmluZGV4T2Yod2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXIsIDEpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycy5sZW5ndGggfHwgZGVsZXRlIHdpbk5hbWVEb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh3aW5OYW1lRG9tYWluTGlzdGVuZXJzKS5sZW5ndGggfHwgZGVsZXRlIHdpbk5hbWVMaXN0ZW5lcnNbbmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbiAmJiAhT2JqZWN0LmtleXMod2luTmFtZUxpc3RlbmVycykubGVuZ3RoICYmIHJlcXVlc3RMaXN0ZW5lcnMuZGVsKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSh7XG5cdCAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgd2luOiBvcHRpb25zLndpbmRvdyxcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogb3B0aW9ucy5kb21haW4gfHwgXCIqXCJcblx0ICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlciB8fCBvcHRpb25zLmhhbmRsZXIsXG5cdCAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcjogb3B0aW9ucy5lcnJvckhhbmRsZXIgfHwgZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdExpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBvbl9vbmNlKG5hbWUsIG9wdGlvbnMsIGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgKG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9KSkge1xuXHQgICAgICAgICAgICAgICAgaGFuZGxlciA9IG9wdGlvbnM7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgIHZhciBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgb3B0aW9ucy5lcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgbGlzdGVuZXIgPSBvbl9vbihuYW1lLCBvcHRpb25zLCAoZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSByZXR1cm4gaGFuZGxlcihldmVudCk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgcHJvbWlzZS5jYW5jZWwgPSBsaXN0ZW5lci5jYW5jZWw7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc2VuZF9zZW5kID0gZnVuY3Rpb24gc2VuZCh3aW5PclByb3h5V2luLCBuYW1lLCBkYXRhLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciBkb21haW5NYXRjaGVyID0gKG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9KS5kb21haW4gfHwgXCIqXCI7XG5cdCAgICAgICAgICAgIHZhciByZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgLTE7XG5cdCAgICAgICAgICAgIHZhciBjaGlsZFRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgNWUzO1xuXHQgICAgICAgICAgICB2YXIgZmlyZUFuZEZvcmdldCA9IG9wdGlvbnMuZmlyZUFuZEZvcmdldCB8fCAhMTtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHdpbk9yUHJveHlXaW4sIHtcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgfSkuYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihuYW1lLCB3aW4sIGRvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5hbWVcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZG9tYWluICYmICFBcnJheS5pc0FycmF5KGRvbWFpbikgJiYgIXV0aWxfaXNSZWdleChkb21haW4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBzZW5kIFwiICsgbmFtZSArIFwiLiBFeHBlY3RlZCBkb21haW4gXCIgKyBKU09OLnN0cmluZ2lmeShkb21haW4pICsgXCIgdG8gYmUgYSBzdHJpbmcsIGFycmF5LCBvciByZWdleFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3Qgc2VuZCBcIiArIG5hbWUgKyBcIi4gVGFyZ2V0IHdpbmRvdyBpcyBjbG9zZWRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfShuYW1lLCB3aW4sIGRvbWFpbk1hdGNoZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbihwYXJlbnQsIGNoaWxkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3R1YWxQYXJlbnQgPSBnZXRBbmNlc3RvcihjaGlsZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3R1YWxQYXJlbnQpIHJldHVybiBhY3R1YWxQYXJlbnQgPT09IHBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4udG9wKSByZXR1cm4gd2luLnRvcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRQYXJlbnQod2luKSA9PT0gd2luKSByZXR1cm4gd2luO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbmNlc3RvclBhcmVudCh3aW5kb3csIHdpbikgJiYgd2luZG93LnRvcCkgcmV0dXJuIHdpbmRvdy50b3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FuY2VzdG9yUGFyZW50KHdpbiwgd2luZG93KSAmJiB3aW5kb3cudG9wKSByZXR1cm4gd2luZG93LnRvcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNyA9IDAsIF9nZXRBbGxDaGlsZEZyYW1lczQgPSBmdW5jdGlvbiBnZXRBbGxDaGlsZEZyYW1lcyh3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMCwgX2dldEZyYW1lczIgPSBnZXRGcmFtZXMod2luKTsgX2kzIDwgX2dldEZyYW1lczIubGVuZ3RoOyBfaTMrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBfZ2V0RnJhbWVzMltfaTNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNSA9IDAsIF9nZXRBbGxDaGlsZEZyYW1lczIgPSBnZXRBbGxDaGlsZEZyYW1lcyhmcmFtZSk7IF9pNSA8IF9nZXRBbGxDaGlsZEZyYW1lczIubGVuZ3RoOyBfaTUrKykgcmVzdWx0LnB1c2goX2dldEFsbENoaWxkRnJhbWVzMltfaTVdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0od2luKTsgX2k3IDwgX2dldEFsbENoaWxkRnJhbWVzNC5sZW5ndGg7IF9pNysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX2dldEFsbENoaWxkRnJhbWVzNFtfaTddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZS50b3ApIHJldHVybiBmcmFtZS50b3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRQYXJlbnQoZnJhbWUpID09PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KGNoaWxkKSA9PT0gY2hpbGQpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxNSA9IDAsIF9nZXRGcmFtZXM4ID0gZ2V0RnJhbWVzKHBhcmVudCk7IF9pMTUgPCBfZ2V0RnJhbWVzOC5sZW5ndGg7IF9pMTUrKykgaWYgKF9nZXRGcmFtZXM4W19pMTVdID09PSBjaGlsZCkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW5kb3csIHdpbikpIHJldHVybiBmdW5jdGlvbih3aW4sIHRpbWVvdXQsIG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB0aW1lb3V0ICYmICh0aW1lb3V0ID0gNWUzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBuYW1lICYmIChuYW1lID0gXCJXaW5kb3dcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJoZWxsb1Byb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0od2luKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLTEgIT09IHRpbWVvdXQgJiYgKHByb21pc2UgPSBwcm9taXNlLnRpbWVvdXQodGltZW91dCwgbmV3IEVycm9yKG5hbWUgKyBcIiBkaWQgbm90IGxvYWQgYWZ0ZXIgXCIgKyB0aW1lb3V0ICsgXCJtc1wiKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9KHdpbiwgY2hpbGRUaW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihfdGVtcCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih3aW4sIHRhcmdldERvbWFpbiwgYWN0dWFsRG9tYWluLCBfcmVmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZi5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0YXJnZXREb21haW4gPyB0YXJnZXREb21haW4gOiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxEb21haW4gfHwgc2F5SGVsbG8od2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjIuZG9tYWluO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihub3JtYWxpemVkRG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbih0YXJnZXREb21haW4sIHRhcmdldERvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkRvbWFpbiBcIiArIHN0cmluZ2lmeSh0YXJnZXREb21haW4pICsgXCIgZG9lcyBub3QgbWF0Y2ggXCIgKyBzdHJpbmdpZnkodGFyZ2V0RG9tYWluKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWREb21haW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KHdpbiwgZG9tYWluTWF0Y2hlciwgKHZvaWQgMCA9PT0gX3RlbXAgPyB7fSA6IF90ZW1wKS5kb21haW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKHRhcmdldERvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB0YXJnZXREb21haW47XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ05hbWUgPSBcInBvc3Ryb2JvdF9tZXRob2RcIiA9PT0gbmFtZSAmJiBkYXRhICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGRhdGEubmFtZSA/IGRhdGEubmFtZSArIFwiKClcIiA6IG5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBuYW1lICsgXCJfXCIgKyB1bmlxdWVJRCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZmlyZUFuZEZvcmdldCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VMaXN0ZW5lciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaGFzaCwgbGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuc2V0KGhhc2gsIGxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfShoYXNoLCByZXNwb25zZUxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcVByb21pc2VzID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0UHJvbWlzZXNcIikuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxUHJvbWlzZXMucHVzaChwcm9taXNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5jYXRjaCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaGFzaCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwiZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzXCIpLnNldChoYXNoLCAhMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGhhc2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcihoYXNoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxBY2tUaW1lb3V0ID0gZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJrbm93bldpbmRvd3NcIikuZ2V0KHdpbiwgITEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbikgPyAxZTQgOiAyZTM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbFJlc1RpbWVvdXQgPSByZXNwb25zZVRpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY2tUaW1lb3V0ID0gdG90YWxBY2tUaW1lb3V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzVGltZW91dCA9IHRvdGFsUmVzVGltZW91dDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gZnVuY3Rpb24obWV0aG9kLCB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbiBsb29wKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbikpIHJldHVybiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJXaW5kb3cgY2xvc2VkIGZvciBcIiArIG5hbWUgKyBcIiBiZWZvcmUgXCIgKyAocmVzcG9uc2VMaXN0ZW5lci5hY2sgPyBcInJlc3BvbnNlXCIgOiBcImFja1wiKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTGlzdGVuZXIuY2FuY2VsbGVkKSByZXR1cm4gcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiUmVzcG9uc2UgbGlzdGVuZXIgd2FzIGNhbmNlbGxlZCBmb3IgXCIgKyBuYW1lKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2tUaW1lb3V0ID0gTWF0aC5tYXgoYWNrVGltZW91dCAtIDUwMCwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMSAhPT0gcmVzVGltZW91dCAmJiAocmVzVGltZW91dCA9IE1hdGgubWF4KHJlc1RpbWVvdXQgLSA1MDAsIDApKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTGlzdGVuZXIuYWNrIHx8IDAgIT09IGFja1RpbWVvdXQgPyAwID09PSByZXNUaW1lb3V0ICYmIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGZvciBwb3N0TWVzc2FnZSBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCIgaW4gXCIgKyB0b3RhbFJlc1RpbWVvdXQgKyBcIm1zXCIpKSA6IHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIGFjayBmb3IgcG9zdE1lc3NhZ2UgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiIGluIFwiICsgdG90YWxBY2tUaW1lb3V0ICsgXCJtc1wiKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCA1MDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmZpbmFsbHkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFQcm9taXNlcy5zcGxpY2UocmVxUHJvbWlzZXMuaW5kZXhPZihwcm9taXNlLCAxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5jYXRjaChzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRfc2VuZE1lc3NhZ2Uod2luLCBkb21haW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHVuaXF1ZUlEKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKHdpbmRvdyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicG9zdHJvYm90X21lc3NhZ2VfcmVxdWVzdFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBoYXNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiBmaXJlQW5kRm9yZ2V0XG5cdCAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcmVBbmRGb3JnZXQgPyBwcm9taXNlLnJlc29sdmUoKSA6IHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZCByZXF1ZXN0IG1lc3NhZ2UgZmFpbGVkIGZvciBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCJcXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0dXBfc2VyaWFsaXplTWVzc2FnZShkZXN0aW5hdGlvbiwgZG9tYWluLCBvYmopIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU1lc3NhZ2UoZGVzdGluYXRpb24sIGRvbWFpbiwgb2JqLCB7XG5cdCAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNldHVwX2Rlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3h5V2luZG93KHdpbikge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvd19Qcm94eVdpbmRvdyh7XG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmQsXG5cdCAgICAgICAgICAgICAgICB3aW46IHdpblxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0dXBfdG9Qcm94eVdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXR1cCgpIHtcblx0ICAgICAgICAgICAgaWYgKCFnbG9iYWxfZ2V0R2xvYmFsKCkuaW5pdGlhbGl6ZWQpIHtcblx0ICAgICAgICAgICAgICAgIGdsb2JhbF9nZXRHbG9iYWwoKS5pbml0aWFsaXplZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgb24gPSAoX3JlZjMgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICAgICAgfSkub24sIHNlbmQgPSBfcmVmMy5zZW5kLCAoZ2xvYmFsID0gZ2xvYmFsX2dldEdsb2JhbCgpKS5yZWNlaXZlTWVzc2FnZSA9IGdsb2JhbC5yZWNlaXZlTWVzc2FnZSB8fCBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAhZnVuY3Rpb24oX3JlZjUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmNS5vbiwgc2VuZCA9IF9yZWY1LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoKS5nZXRPclNldChcInBvc3RNZXNzYWdlTGlzdGVuZXJcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBldmVudCwgaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW5kb3csIDAsIChmdW5jdGlvbihldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGV2ZW50LCBfcmVmNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWY0Lm9uLCBzZW5kID0gX3JlZjQuc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gZXZlbnQuc291cmNlIHx8IGV2ZW50LnNvdXJjZUVsZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBldmVudC5vcmlnaW4gfHwgZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50Lm9yaWdpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm51bGxcIiA9PT0gb3JpZ2luICYmIChvcmlnaW4gPSBcImZpbGU6Ly9cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luKSB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0IG1lc3NhZ2UgZGlkIG5vdCBoYXZlIG9yaWdpbiBkb21haW5cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlX3JlY2VpdmVNZXNzYWdlKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShldmVudCwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKF9yZWY4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZjgub24sIHNlbmQgPSBfcmVmOC5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwiYnVpbHRpbkxpc3RlbmVyc1wiKS5nZXRPclNldChcImhlbGxvTGlzdGVuZXJcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBvbihcInBvc3Ryb2JvdF9oZWxsb1wiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IFwiKlwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIChmdW5jdGlvbihfcmVmMykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUhlbGxvUHJvbWlzZShfcmVmMy5zb3VyY2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IF9yZWYzLm9yaWdpblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSUQ6IGdldEluc3RhbmNlSUQoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZ2V0QW5jZXN0b3IoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ICYmIHNheUhlbGxvKHBhcmVudCwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZnVuY3Rpb24oZXJyKSB7fSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSh7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIF9yZWYzLCBvbiwgc2VuZCwgZ2xvYmFsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICAgICAgICAhZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VMaXN0ZW5lcnMgPSBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMiA9IHJlc3BvbnNlTGlzdGVuZXJzLmtleXMoKTsgX2kyIDwgX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMi5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBfcmVzcG9uc2VMaXN0ZW5lcnMka2UyW19pMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gcmVzcG9uc2VMaXN0ZW5lcnMuZ2V0KGhhc2gpO1xuXHQgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyICYmIChsaXN0ZW5lci5jYW5jZWxsZWQgPSAhMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VMaXN0ZW5lcnMuZGVsKGhhc2gpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgIChsaXN0ZW5lciA9IGdsb2JhbFN0b3JlKCkuZ2V0KFwicG9zdE1lc3NhZ2VMaXN0ZW5lclwiKSkgJiYgbGlzdGVuZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgIHZhciBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5fX3Bvc3Rfcm9ib3RfMTBfMF80Nl9fO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc3JjX3R5cGVzX1RZUEVTXzAgPSAhMDtcblx0ICAgICAgICBmdW5jdGlvbiBjbGVhblVwV2luZG93KHdpbikge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfcmVxdWVzdFByb21pc2VzJGdldDIgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RQcm9taXNlc1wiKS5nZXQod2luLCBbXSk7IF9pMiA8IF9yZXF1ZXN0UHJvbWlzZXMkZ2V0Mi5sZW5ndGg7IF9pMisrKSBfcmVxdWVzdFByb21pc2VzJGdldDJbX2kyXS5yZWplY3QobmV3IEVycm9yKFwiV2luZG93IFwiICsgKGlzV2luZG93Q2xvc2VkKHdpbikgPyBcImNsb3NlZFwiIDogXCJjbGVhbmVkIHVwXCIpICsgXCIgYmVmb3JlIHJlc3BvbnNlXCIpKS5jYXRjaChzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgc2V0dXAoKTtcblx0ICAgIH0gXSk7XG5cdH0pKTsgXG59IChwb3N0Um9ib3QpKTtcblxudmFyIHBvc3RSb2JvdEV4cG9ydHMkMSA9IHBvc3RSb2JvdC5leHBvcnRzO1xuXG4vKiBAZmxvdyAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQvLyAkRmxvd0ZpeE1lXG5cdG1vZHVsZS5leHBvcnRzID0gcG9zdFJvYm90RXhwb3J0cyQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1jb21tb25qc1xuXG5cdC8vICRGbG93Rml4TWVcblx0bW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1jb21tb25qcyBcbn0gKHBvc3RSb2JvdCQxKSk7XG5cbnZhciBwb3N0Um9ib3RFeHBvcnRzID0gcG9zdFJvYm90JDEuZXhwb3J0cztcbnZhciBpbmRleCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhwb3N0Um9ib3RFeHBvcnRzKTtcblxudmFyIGluZGV4JDEgPSAvKiNfX1BVUkVfXyovX21lcmdlTmFtZXNwYWNlcyh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0ZGVmYXVsdDogaW5kZXhcbn0sIFtwb3N0Um9ib3RFeHBvcnRzXSk7XG5cbmV4cG9ydCB7IGluZGV4JDEgYXMgaSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/family/lib/index-DD_kndDs.js\n"));

/***/ })

}]);